<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;数据结构与算法 训练营四期&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="训练营四期12给定一个数组arr，再给定一个k值返回累加和小于等于k，但是离k最近的子数组累加和  1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F;思路如同数组累加和三连的第三题&#x2F;&#x2F; 请返回arr中，求个子数组的累加和，是&lt;&#x3D;K的，并且是最大的。&#x2F;&#x2F; 返回这个最大的累加和public sta">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;数据结构与算法 训练营四期&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="训练营四期12给定一个数组arr，再给定一个k值返回累加和小于等于k，但是离k最近的子数组累加和  1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F;思路如同数组累加和三连的第三题&#x2F;&#x2F; 请返回arr中，求个子数组的累加和，是&lt;&#x3D;K的，并且是最大的。&#x2F;&#x2F; 返回这个最大的累加和public sta">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-01T01:00:00.000Z">
<meta property="article:modified_time" content="2021-01-26T07:03:36.308Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?code-JRipY21QjX";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-algorithm-trainingcamp4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;数据结构与算法 训练营四期&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/algorithm/">algorithm</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-11-01
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="训练营四期"><a href="#训练营四期" class="headerlink" title="训练营四期"></a>训练营四期</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，再给定一个k值</span><br><span class="line">返回累加和小于等于k，但是离k最近的子数组累加和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路如同数组累加和三连的第三题</span></span><br><span class="line"><span class="comment">// 请返回arr中，求个子数组的累加和，是&lt;=K的，并且是最大的。</span></span><br><span class="line"><span class="comment">// 返回这个最大的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLessOrEqualK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录i之前的，前缀和，按照有序表组织</span></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 一个数也没有的时候，就已经有一个前缀和是0了</span></span><br><span class="line">    set.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是&lt;=K的，并且是最大的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i]; <span class="comment">// sum -&gt; arr[0..i];</span></span><br><span class="line">        <span class="keyword">if</span> (set.ceiling(sum - K) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            max = Math.max(max, sum - set.ceiling(sum - K));</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(sum); <span class="comment">// 当前的前缀和加入到set中去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">// 请返回arr中，求个子数组的累加和，是&lt;=K的，并且是最大的。</span></span><br><span class="line"><span class="comment">// 返回这个最大的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxLessOrEqualK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录i之前的，前缀和，按照有序表组织</span></span><br><span class="line">    TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 一个数也没有的时候，就已经有一个前缀和是0了</span></span><br><span class="line">    set.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每一步的i，都求子数组必须以i结尾的情况下，求个子数组的累加和，是&lt;=K的，并且是最大的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i]; <span class="comment">// sum -&gt; arr[0..i];</span></span><br><span class="line">        <span class="keyword">if</span> (set.ceiling(sum - K) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            max = Math.max(max, sum - set.ceiling(sum - K));</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(sum); <span class="comment">// 当前的前缀和加入到set中去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维数组matrix，再给定一个k值</span><br><span class="line">返回累加和小于等于k，但是离k最近的子矩阵累加和</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">把第一行求出答案，把第二行的列数据累加到第一行中，压缩成一维数组，得出来的答案就是[0,1]行的答案</span><br><span class="line">以此类推，能够求得以第0行开始，一直到[0..N-1]行的答案</span><br><span class="line">要求[1..N-1]行的答案，只需要用[0..N-1]行的答案减去[0,1]行的答案即可</span><br><span class="line"></span><br><span class="line">一行长度为M，计算一行的时间复杂度O(M * logM)，整体时间复杂度O(N^2 * M * logM)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维数组matrix，可以从任何位置出发，每一步可以走向上、下、左、右，四个方向。返回最大递增链的长度。</span><br><span class="line">例子：</span><br><span class="line">matrix &#x3D; </span><br><span class="line">5  4  3</span><br><span class="line">3  1  2</span><br><span class="line">2  1  3</span><br><span class="line">从最中心的1出发，是可以走出1 2 3 4 5的链的，而且这是最长的递增链。所以返回长度5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">暴力递归任何一个点，上下左右四个分支的递增链，取Max</span><br><span class="line">优化：</span><br><span class="line">建立计算过的每个点的dp[i][j]值，记忆化搜索复用，时间复杂度O(M * N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPath2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            ans = Math.max(ans, process(matrix, row, col, dp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设在matrix中，从i行，j列出发，能走出的最长递增路径，返回</span></span><br><span class="line"><span class="comment">// dp[i][j] == 0 process(i,j) 之前没遇到过</span></span><br><span class="line"><span class="comment">// dp[i][j] != 0 process(i,j) 之前已经算过了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> next1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i - <span class="number">1</span>][j] &gt; matrix[i][j]) &#123;</span><br><span class="line">        next1 = process(matrix, i - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; matrix.length &amp;&amp; matrix[i + <span class="number">1</span>][j] &gt; matrix[i][j]) &#123;</span><br><span class="line">        next2 = process(matrix, i + <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j - <span class="number">1</span>] &gt; matrix[i][j]) &#123;</span><br><span class="line">        next3 = process(matrix, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[i][j + <span class="number">1</span>] &gt; matrix[i][j]) &#123;</span><br><span class="line">        next4 = process(matrix, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> + Math.max(Math.max(next1, next2), Math.max(next3, next4));</span><br><span class="line">    dp[i][j] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符类型的二维数组board，和一个字符串组成的列表words。</span><br><span class="line">可以从board任何位置出发，每一步可以走向上、下、左、右，四个方向，</span><br><span class="line">但是一条路径已经走过的位置，不能重复走。</span><br><span class="line">返回words哪些单词可以被走出来。</span><br><span class="line">例子 </span><br><span class="line">board &#x3D; [</span><br><span class="line">  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],</span><br><span class="line">  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],</span><br><span class="line">  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],</span><br><span class="line">  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]</span><br><span class="line">]</span><br><span class="line">words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">输出：[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">words生成前缀树，加速查找过程，递归上下左右位置</span><br><span class="line">通过修改原数组中的值来验证不能重复走的问题，深度优先遍历后还原数组中的值</span><br><span class="line">通过一个List缓存每次走过的字符，匹配上前缀树的end，则记录答案</span><br><span class="line">通过一个List记录每次合法的答案，一次深度优先遍历求多个合法答案</span><br><span class="line">通过递归方法返回值记录匹配到多少个合法答案，前缀树的pass--，同样答案的不会再走</span><br><span class="line">用来避免求得答案的不同位置重新计算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">    TrieNode head = <span class="keyword">new</span> TrieNode(); <span class="comment">// 前缀树最顶端的头</span></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(word)) &#123;</span><br><span class="line">            fillWord(head, word);</span><br><span class="line">            set.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 答案</span></span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 沿途走过的字符，收集起来，存在path里</span></span><br><span class="line">    LinkedList&lt;Character&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="comment">// 枚举在board中的所有位置</span></span><br><span class="line">            <span class="comment">// 每一个位置出发的情况下，答案都收集</span></span><br><span class="line">            process(board, row, col, path, head, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从board[row][col]位置的字符出发，</span></span><br><span class="line"><span class="comment">// 之前的路径上，走过的字符，记录在path里</span></span><br><span class="line"><span class="comment">// cur还没有登上，有待检查能不能登上去的前缀树的节点</span></span><br><span class="line"><span class="comment">// 如果找到words中的某个str，就记录在 res里</span></span><br><span class="line"><span class="comment">// 返回值，从row,col 出发，一共找到了多少个str</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span>[][] board, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> row, <span class="keyword">int</span> col,</span></span></span><br><span class="line"><span class="function"><span class="params">    LinkedList&lt;Character&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">    TrieNode cur, </span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cha = board[row][col];</span><br><span class="line">    <span class="keyword">if</span> (cha == <span class="number">0</span>) &#123; <span class="comment">// 这个row col位置是之前走过的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (row,col) 不是回头路   cha 有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = cha - <span class="string">'a'</span>;</span><br><span class="line">    <span class="comment">// 如果没路，或者这条路上最终的字符串之前加入过结果里</span></span><br><span class="line">    <span class="keyword">if</span> (cur.nexts[index] == <span class="keyword">null</span> || cur.nexts[index].pass == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有走回头路且能登上去</span></span><br><span class="line">    cur = cur.nexts[index];</span><br><span class="line">    path.addLast(cha);<span class="comment">// 当前位置的字符加到路径里去</span></span><br><span class="line">    <span class="keyword">int</span> fix = <span class="number">0</span>; <span class="comment">// 从row和col位置出发，后续一共搞定了多少答案</span></span><br><span class="line">    <span class="comment">// 当我来到row col位置，如果决定不往后走了。是不是已经搞定了某个字符串了</span></span><br><span class="line">    <span class="keyword">if</span> (cur.end &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        res.add(generatePath(path));</span><br><span class="line">        cur.end--;</span><br><span class="line">        fix++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往上、下、左、右，四个方向尝试</span></span><br><span class="line">    board[row][col] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fix += process(board, row - <span class="number">1</span>, col, path, cur, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; board.length - <span class="number">1</span>) &#123;</span><br><span class="line">        fix += process(board, row + <span class="number">1</span>, col, path, cur, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fix += process(board, row, col - <span class="number">1</span>, path, cur, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (col &lt; board[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">        fix += process(board, row, col + <span class="number">1</span>, path, cur, res);</span><br><span class="line">    &#125;</span><br><span class="line">    board[row][col] = cha;</span><br><span class="line">    path.pollLast();</span><br><span class="line">    cur.pass -= fix;</span><br><span class="line">    <span class="keyword">return</span> fix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        pass = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillWord</span><span class="params">(TrieNode head, String word)</span> </span>&#123;</span><br><span class="line">    head.pass++;</span><br><span class="line">    <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    TrieNode node = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.nexts[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.nexts[index];</span><br><span class="line">        node.pass++;</span><br><span class="line">    &#125;</span><br><span class="line">    node.end++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串S和T，返回S子序列等于T的不同子序列个数有多少个? 如果得到子序列A删除的位置与得到子序列B删除的位置不同，那么认为A和B就是不同的。</span><br><span class="line">【例子】</span><br><span class="line">S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">返回: 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">dp问题，一个样本做行，一个样本做列的对应模型</span><br><span class="line">dp[i][j]：</span><br><span class="line">可能性一：与i无关 dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">可能性二：与i有关 s[i] &#x3D;&#x3D; t[j]的前提下，dp[i][j] &#x3D; dp[i-1][j-1] + 1</span><br><span class="line">两种可能性相加</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维数组 map，含义是一张地图，例如，如下矩阵: </span><br><span class="line">-2 -3   3</span><br><span class="line">-5 -10  1</span><br><span class="line"> 0  30 -5</span><br><span class="line">游戏的规则如下: </span><br><span class="line">骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。</span><br><span class="line">地图中每个位置的值代表骑士要遭遇的事情。</span><br><span class="line">如果是负数，说明此处有怪兽，要让骑士损失血量。</span><br><span class="line">如果是非负数，代表此处有血瓶，能让骑士回血。</span><br><span class="line">骑士从左上角到右下角的过程中，走到任何一个位置时，血量都不能少于1。</span><br><span class="line">为了保证骑士能见到公主，初始血量至少是多少?根据map，返回至少的初始血量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">dp问题，baseCase：到达最后公右下角格子的时候，最少需要多少血量</span><br><span class="line">假设到了最后一行，一直往右走，最少需要多少血量 dp[N-1][j]，取决于它右边的格子</span><br><span class="line">假设到了最后一列，一直往下走，最少需要多少血量 dp[i][N-1]，取决于它下面的格子</span><br><span class="line">在中间，取决于下面和右边的血量最小值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">needMin</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(matrix, matrix.length, matrix[<span class="number">0</span>].length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来到了matrix[row][col]，还没登上去，到达右下角，返回至少的初始血量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == N - <span class="number">1</span> &amp;&amp; col == M - <span class="number">1</span>) &#123; <span class="comment">// 已经达到右下角了</span></span><br><span class="line">        <span class="keyword">return</span> matrix[N-<span class="number">1</span>][M-<span class="number">1</span>] &lt; <span class="number">0</span> ? (-matrix[N-<span class="number">1</span>][M-<span class="number">1</span>] + <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(row == N - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightNeed = process(matrix, N, M, row, col+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &lt; <span class="number">0</span>) &#123; <span class="comment">// 3    -7    10</span></span><br><span class="line">            <span class="keyword">return</span> -matrix[row][col] + rightNeed;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt;= rightNeed) &#123;  <span class="comment">// 3    3    1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//  3   1    2</span></span><br><span class="line">            <span class="keyword">return</span> rightNeed - matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(col == M - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> downNeed = process(matrix, N, M, row+<span class="number">1</span>, col);</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &lt; <span class="number">0</span>) &#123; <span class="comment">// 3    -7    10</span></span><br><span class="line">            <span class="keyword">return</span> -matrix[row][col] + downNeed;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt;= downNeed) &#123;  <span class="comment">// 3    3    1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//  3   1    2</span></span><br><span class="line">            <span class="keyword">return</span> downNeed - matrix[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minNextNeed = Math.min(process(matrix, N, M, row, col+<span class="number">1</span>), process(matrix, N, M, row+<span class="number">1</span>, col));</span><br><span class="line">    <span class="keyword">if</span>(matrix[row][col] &lt; <span class="number">0</span>) &#123; <span class="comment">// 3    -7    10</span></span><br><span class="line">        <span class="keyword">return</span> -matrix[row][col] + minNextNeed;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt;= minNextNeed) &#123;  <span class="comment">// 3    3    1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">//  3   1    2</span></span><br><span class="line">        <span class="keyword">return</span> minNextNeed - matrix[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">BaseCase：两个点同时出发，到达相同点和最后一个点时只累加一次值，不同点累加两个点的值</span><br><span class="line">第二个点的一个坐标可以通过另一个点计算坐标出来</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从matrix左上角，走到右下角，过程中只能向右或者向下</span></span><br><span class="line"><span class="comment">// 到达后，回来，过程中只能向左或者向上，沿途数字只能获得一遍</span></span><br><span class="line"><span class="comment">// 返回，最大路径和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">comeGoMaxPathSum</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(matrix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matrix中，没有负数</span></span><br><span class="line"><span class="comment">// A来到的位置是 Ar,Ac</span></span><br><span class="line"><span class="comment">// B来到的位置是 Br, Ar + Ac - Br</span></span><br><span class="line"><span class="comment">// A和B，一定迈出的步数，一样多，同步走的</span></span><br><span class="line"><span class="comment">// 两人会共同到达右下角，返回两个人路径的最大累加和</span></span><br><span class="line"><span class="comment">// 重要限制：来到同一个位置时，只获得一份</span></span><br><span class="line"><span class="comment">//   3  7     5     ?</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> Ar, <span class="keyword">int</span> Ac, <span class="keyword">int</span> Br)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> M = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(Ar == N - <span class="number">1</span> &amp;&amp; Ac == M - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[Ar][Ac];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还没到右下角</span></span><br><span class="line">    <span class="comment">// A 下   B 右</span></span><br><span class="line">    <span class="comment">// A 下   B 下</span></span><br><span class="line">    <span class="comment">// A 右   B 右</span></span><br><span class="line">    <span class="comment">// A 右   B 下</span></span><br><span class="line">    <span class="keyword">int</span> Bc = Ar + Ac - Br;</span><br><span class="line">    <span class="keyword">int</span> ADownBRight = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ar + <span class="number">1</span> &lt; N &amp;&amp; Bc + <span class="number">1</span> &lt; M) &#123;</span><br><span class="line">        ADownBRight = process(matrix, Ar + <span class="number">1</span>, Ac, Br);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ADownBDown = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ar + <span class="number">1</span> &lt; N &amp;&amp; Br + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">        ADownBDown = process(matrix, Ar + <span class="number">1</span>, Ac, Br + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ARightBRight = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ac + <span class="number">1</span> &lt; M &amp;&amp; Bc + <span class="number">1</span> &lt; M) &#123;</span><br><span class="line">        ARightBRight = process(matrix, Ar, Ac+<span class="number">1</span>, Br);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ARightBDown = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Ac + <span class="number">1</span> &lt; M &amp;&amp; Br + <span class="number">1</span> &lt; N) &#123;</span><br><span class="line">        ARightBDown = process(matrix, Ar, Ac + <span class="number">1</span>, Br + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextBest = Math.max(Math.max(ADownBRight, ADownBDown), Math.max(ARightBRight, ARightBDown));</span><br><span class="line">    <span class="comment">// A B 相同位置，只能累加一次</span></span><br><span class="line">    <span class="keyword">if</span>(Ar == Br) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[Ar][Ac] + nextBest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A 和 B，一定是不同位置</span></span><br><span class="line">    <span class="comment">//A + B + 递归最好的结果</span></span><br><span class="line">    <span class="keyword">return</span> matrix[Ar][Ac] + matrix[Br][Bc] + nextBest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序数组arr，返回如果排序之后，相邻数之间的最大差值</span><br><span class="line">&#123;3,1,7,9&#125;，如果排序后&#123;1,3,7,9&#125;，相邻数之间的最大差值来自3和7，返回4</span><br><span class="line">要求：不能真的进行排序，并且要求在时间复杂度O(N)内解决</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先遍历一遍数组，求最大值和最小值，根据数组长度分成N + 1份个桶</span><br><span class="line">将N个数字放进N+1个桶中，桶的左右两侧是数组的最大值和最小值，那么必然会存在空桶</span><br><span class="line">空桶的定义是为了忽略桶内部的差值结果，因为空桶左侧桶内最大值和右侧桶内最小值势必大于一个桶的结果</span><br><span class="line">这样做的目的是忽略掉最平凡的解</span><br><span class="line">每个桶记录桶中的最大值和最小值，结果必然在两个不同的桶的最大值最小值之差</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = Math.min(min, nums[i]);</span><br><span class="line">        max = Math.max(max, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不止一种数，min~max一定有range,  len个数据，准备len+1个桶</span></span><br><span class="line">    <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>]; <span class="comment">// hasNum[i] i号桶是否进来过数字</span></span><br><span class="line">    <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];  <span class="comment">// maxs[i] i号桶收集的所有数字的最大值</span></span><br><span class="line">    <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];  <span class="comment">// mins[i] i号桶收集的所有数字的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bid = <span class="number">0</span>; <span class="comment">// 桶号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        bid = bucket(nums[i], len, min, max);</span><br><span class="line">        mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];</span><br><span class="line">        maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];</span><br><span class="line">        hasNum[bid] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>]; <span class="comment">// 上一个非空桶的最大值</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">            res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">            lastMax = maxs[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * len / (max - min));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设所有字符都是小写字母.   长字符串是str</span><br><span class="line">arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次</span><br><span class="line">使用arr中的单词有多少种拼接str的方式，返回方法数.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：</span><br><span class="line">枚举从[0...i]上，在数组中的单词，匹配上则进入递归</span><br><span class="line">截取子串并且Set的Contains操作时间复杂度O(N)，所以总体时间复杂度O（N^3）</span><br><span class="line">解法二：</span><br><span class="line">前缀树，先生成数组的前缀，通过O(1)优化了Set的O(N)过程，并且前缀树不满足的字符串直接跳出</span><br><span class="line">建前缀树O(K)，总体时间复杂度O(K) + O(N^2)</span><br><span class="line"></span><br><span class="line">根据数据量选择不同的解法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways</span><span class="params">(String str, String[] arr)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String candidate : arr) &#123;</span><br><span class="line">        set.add(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(str, <span class="number">0</span>, set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的贴纸，都已经放在了set中</span></span><br><span class="line"><span class="comment">// str[i....] 能够被set中的贴纸分解的话，返回分解的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(String str, <span class="keyword">int</span> i, HashSet&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == str.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// [i ... end] 前缀串 每一个前缀串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = i; end &lt; str.length(); end++) &#123;</span><br><span class="line">        String pre = str.substring(i, end + <span class="number">1</span>);<span class="comment">// [)</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(pre)) &#123;</span><br><span class="line">            ways += process(str, end + <span class="number">1</span>, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> end;</span><br><span class="line">    <span class="keyword">public</span> Node[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        end = <span class="keyword">false</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(String str, String[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.nexts[index] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.end = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g(str.toCharArray(), root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[i...] 被分解的方法数，返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">char</span>[] str, Node root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    Node cur = root;</span><br><span class="line">    <span class="comment">// i...end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> end = i; end &lt; str.length; end++) &#123;</span><br><span class="line">        <span class="keyword">int</span> path = str[end] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//如果没有前缀树匹配了，直接break加速</span></span><br><span class="line">        <span class="keyword">if</span> (cur.nexts[path] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.nexts[path];</span><br><span class="line">        <span class="keyword">if</span> (cur.end) &#123; <span class="comment">// i...end</span></span><br><span class="line">            ways += g(str, root, end + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，和一个数K</span><br><span class="line">路径的定义: </span><br><span class="line">可以从任何一个点开始，但是只能往下走，往下可以走到任何节点停止</span><br><span class="line">返回路径累加和为K的所有路径中，最长的路径最多有几个节点？</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">树每一条分支都是一个一维数组，求每个一维数组中累加和为K的最长子数组问题，数组三连</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 收集累加和为K的，最长路径有多少个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longest</span><span class="params">(Node head, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// key ： 前缀和</span></span><br><span class="line">    <span class="comment">// value : 该前缀和，最早出现在哪一层</span></span><br><span class="line">    <span class="comment">// sumMap：只维持，从头节点出发到当前节点，这条路径上的前缀和</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    sumMap.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    process(head, <span class="number">0</span>, <span class="number">0</span>, K, sumMap);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点X在level层，从头节点到X的父节点形成的累加和是preSum，</span></span><br><span class="line"><span class="comment">// 从头节点到X的路径上，每一个前缀和都存在sumMap里(key)，记录的是该前缀和最早出现的层数(value)</span></span><br><span class="line"><span class="comment">// 求出必须以X节点结尾的、累加和是K的所有路径中，含有最多的节点是多少？</span></span><br><span class="line"><span class="comment">// 并看看能不能更新全局的ans</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node X, <span class="keyword">int</span> level, <span class="keyword">int</span> preSum, <span class="keyword">int</span> K, HashMap&lt;Integer, Integer&gt; sumMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从头节点出发，到当前X节点，总的前缀和是多少，allSum</span></span><br><span class="line">        <span class="keyword">int</span> allSum = preSum + X.value;</span><br><span class="line">        <span class="keyword">if</span> (sumMap.containsKey(allSum - K)) &#123;</span><br><span class="line">            ans = Math.max(ans, level - sumMap.get(allSum - K));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sumMap.containsKey(allSum)) &#123;</span><br><span class="line">            sumMap.put(allSum, level);</span><br><span class="line">        &#125;</span><br><span class="line">        process(X.left, level + <span class="number">1</span>, allSum, K, sumMap);</span><br><span class="line">        process(X.right, level + <span class="number">1</span>, allSum, K, sumMap);</span><br><span class="line">        <span class="keyword">if</span> (sumMap.get(allSum) == level) &#123;</span><br><span class="line">            sumMap.remove(allSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个int类型的数组arr，已知除了一种数只出现1次之外，</span><br><span class="line">剩下所有的数都出现了k次，如何使用O(1)的额外空间，找到这个数。</span><br><span class="line">int[] arr,  int K,   K &gt; 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">出现K次的数，把他理解成一个无进位相加的K进制数，累加计算他们的位数然后模K，出现K次的数一定能被整除</span><br><span class="line">剩下的就是出现1次的数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">onceNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] eO = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前数是arr[i], 请把arr[i]变成K进制的形式，每一位累加到eO</span></span><br><span class="line">        setExclusiveOr(eO, arr[i], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = getNumFromKSysNum(eO, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setExclusiveOr</span><span class="params">(<span class="keyword">int</span>[] eO, <span class="keyword">int</span> value, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] curKSysNum = getKSysNumFromNum(value, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != eO.length; i++) &#123;</span><br><span class="line">        eO[i] = (eO[i] + curKSysNum[i]) % k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getKSysNumFromNum(<span class="keyword">int</span> value, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line">        res[index++] = value % k;</span><br><span class="line">        value = value / k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumFromKSysNum</span><span class="params">(<span class="keyword">int</span>[] eO, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = eO.length - <span class="number">1</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        res = res * k + eO[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，如果有某个数出现次数超过了数组长度的一半，打印这个数，如果没有不打印</span><br><span class="line">额外空间O(1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">每次同时删掉两个不同的数，最后那个留下来的一定是超过数组长度的一半的数</span><br><span class="line">代码实现的思想很重要！！！！</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHalfMajor</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cand = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//通过一个值自增自减来达到同时删除两个数的目的O(1)，很重要的思想！！！！</span></span><br><span class="line">    <span class="keyword">int</span> HP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HP == <span class="number">0</span>) &#123;</span><br><span class="line">            cand = arr[i];</span><br><span class="line">            HP = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == cand) &#123;</span><br><span class="line">            HP++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HP--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(HP == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"no such number."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == cand) &#123;</span><br><span class="line">            HP++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (HP &gt; arr.length / <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(cand);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"no such number."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr和整数k，arr长度为N，如果有某些数出现次数超过了N&#x2F;K，打印这些数，如果没有不打印</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">用一个长度为K的Map来存储，Key是数字，Value是HP的值，和上题相同思路解答</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printKMajor</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (K &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"the value of K is invalid."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; cands = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cands.containsKey(arr[i])) &#123;</span><br><span class="line">            cands.put(arr[i], cands.get(arr[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cands.size() == K - <span class="number">1</span>) &#123;</span><br><span class="line">                allCandsMinusOne(cands);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cands.put(arr[i], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; reals = getReals(arr, cands);</span><br><span class="line">    <span class="keyword">boolean</span> hasPrint = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; set : cands.entrySet()) &#123;</span><br><span class="line">        Integer key = set.getKey();</span><br><span class="line">        <span class="keyword">if</span> (reals.get(key) &gt; arr.length / K) &#123;</span><br><span class="line">            hasPrint = <span class="keyword">true</span>;</span><br><span class="line">            System.out.print(key + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(hasPrint ? <span class="string">""</span> : <span class="string">"no such number."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allCandsMinusOne</span><span class="params">(HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; removeList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; set : map.entrySet()) &#123;</span><br><span class="line">        Integer key = set.getKey();</span><br><span class="line">        Integer value = set.getValue();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">            removeList.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer removeKey : removeList) &#123;</span><br><span class="line">        map.remove(removeKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; <span class="title">getReals</span><span class="params">(<span class="keyword">int</span>[] arr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 HashMap&lt;Integer, Integer&gt; cands)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; reals = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> curNum = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (cands.containsKey(curNum)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reals.containsKey(curNum)) &#123;</span><br><span class="line">                reals.put(curNum, reals.get(curNum) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reals.put(curNum, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组arr代表每一个咖啡机冲一杯咖啡的时间，每个咖啡机只能串行的制造咖啡。</span><br><span class="line">现在有n个人需要喝咖啡，只能用咖啡机来制造咖啡。</span><br><span class="line">认为每个人喝咖啡的时间非常短，冲好的时间即是喝完的时间。</span><br><span class="line">每个人喝完之后咖啡杯可以选择洗或者自然挥发干净，只有一台洗咖啡杯的机器，只能串行的洗咖啡杯。</span><br><span class="line">洗杯子的机器洗完一个杯子时间为a，任何一个杯子自然挥发干净的时间为b。</span><br><span class="line">四个参数：arr, n, a, b</span><br><span class="line">假设时间点从0开始，返回所有人喝完咖啡并洗完咖啡杯的全部过程结束后，至少来到什么时间点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">小根堆，把每个咖啡的（时间总和，单次时长））放小根堆里，依次弹出使用增加</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeMachine</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        start = s;</span><br><span class="line">        work = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachineComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">CoffeeMachine</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(CoffeeMachine o1, CoffeeMachine o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.start + o1.work - o2.start - o2.work;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bestChoices(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> M) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    PriorityQueue&lt;CoffeeMachine&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> CoffeeMachineComparator());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coffeWork : arr) &#123;</span><br><span class="line">        heap.add(<span class="keyword">new</span> CoffeeMachine(<span class="number">0</span>, coffeWork));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; M; i++) &#123;</span><br><span class="line">        CoffeeMachine cur = heap.poll();</span><br><span class="line">        ans[i] = cur.start + cur.work;</span><br><span class="line">        cur.start = ans[i];</span><br><span class="line">        heap.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定两个整数数组A和B</span><br><span class="line">A是长度为m、元素从小到大排好序了</span><br><span class="line">B是长度为n、元素从小到大排好序了</span><br><span class="line">希望从A和B数组中，找出最大的k个数字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：卡两个指针一直移动，时间复杂度O(K)</span><br><span class="line"></span><br><span class="line">解法二：二分A数组，然后二分的那个值去B里面二分，判断A左边的数量+B左边的数量和K有什么关系</span><br><span class="line">大于则表示这个二分的值拿大了，小于则拿小了</span><br><span class="line">若这个值不在A数组中，则重复操作数组B</span><br><span class="line">时间复杂度O(logN * logM)</span><br><span class="line"></span><br><span class="line">解法三：</span><br><span class="line">假设把两个数组看做等长的偶数数组N，求第N小，可以先求出这两个数组的上中位数</span><br><span class="line">若他们上中位数相等，则这个值是两个数组中第N小的值</span><br><span class="line">若数组A的中位数X大于数组B的中位数Y，则有X左边部分（包括X）和Y右边部分（不包括Y）都可能是第N小的值</span><br><span class="line">把这两段数组当做一个新数组递归下去，新数组长度是N&#x2F;2，等于求第N&#x2F;2小的值</span><br><span class="line"></span><br><span class="line">若数组的长度是奇数，求第N小，则分类：</span><br><span class="line">若数组A的中位数X大于数组B的中位数Y，则有X左边部分（不包括X）和Y右边部分（包括Y）都可能是第N小的值</span><br><span class="line">在这种情况下，Y部分的长度会比X部分的长度大一，可以通过程序匹配过滤掉一个，使得他们长度等长，接着计算</span><br><span class="line"></span><br><span class="line">所以通过这种方式求得了数组长度都是N的情况下，第N小的值</span><br><span class="line">上面的题目若K &lt; Min(M,N),则可以直接按照K长数组来算，其他情况看代码...</span><br><span class="line">时间复杂度O(log Min(M,N))</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findKthNum</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2, <span class="keyword">int</span> kth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> || arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kth &lt; <span class="number">1</span> || kth &gt; arr1.length + arr2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] longs = arr1.length &gt;= arr2.length ? arr1 : arr2;</span><br><span class="line">    <span class="keyword">int</span>[] shorts = arr1.length &lt; arr2.length ? arr1 : arr2;</span><br><span class="line">    <span class="keyword">int</span> l = longs.length;</span><br><span class="line">    <span class="keyword">int</span> s = shorts.length;</span><br><span class="line">    <span class="keyword">if</span> (kth &lt;= s) &#123;</span><br><span class="line">        <span class="keyword">return</span> getUpMedian(shorts, <span class="number">0</span>, kth - <span class="number">1</span>, longs, <span class="number">0</span>, kth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kth &gt; l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shorts[kth - l - <span class="number">1</span>] &gt;= longs[l - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> shorts[kth - l - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (longs[kth - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> longs[kth - s - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getUpMedian(shorts, kth - l, s - <span class="number">1</span>, longs, kth - s, l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 短数组长度 &lt; k &lt;= 长数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (longs[kth - s - <span class="number">1</span>] &gt;= shorts[s - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> longs[kth - s - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUpMedian(shorts, <span class="number">0</span>, s - <span class="number">1</span>, longs, kth - s, kth - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A[s1...e1]</span></span><br><span class="line"><span class="comment">// B[s2...e2]</span></span><br><span class="line"><span class="comment">// 这两段一定等长且都有序</span></span><br><span class="line"><span class="comment">// 求这两段整体的上中位数，上中位数值返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getUpMedian</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> s1, <span class="keyword">int</span> e1, <span class="keyword">int</span>[] B, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s1 &lt; e1) &#123;</span><br><span class="line">        mid1 = (s1 + e1) / <span class="number">2</span>;</span><br><span class="line">        mid2 = (s2 + e2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid1] == B[mid2]) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[mid1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (((e1 - s1 + <span class="number">1</span>) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 奇数长度</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid1] &gt; B[mid2]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[mid2] &gt;= A[mid1 - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> B[mid2];</span><br><span class="line">                &#125;</span><br><span class="line">                e1 = mid1 - <span class="number">1</span>;</span><br><span class="line">                s2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// A[mid1] &lt; B[mid2]</span></span><br><span class="line">                <span class="keyword">if</span> (A[mid1] &gt;= B[mid2 - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> A[mid1];</span><br><span class="line">                &#125;</span><br><span class="line">                e2 = mid2 - <span class="number">1</span>;</span><br><span class="line">                s1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数长度</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid1] &gt; B[mid2]) &#123;</span><br><span class="line">                e1 = mid1;</span><br><span class="line">                s2 = mid2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e2 = mid2;</span><br><span class="line">                s1 = mid1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(A[s1], B[s2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">约瑟夫环问题</span><br><span class="line">给定一圈人，报数从1开始，报到m位置，就杀死他，然后下一个重新报数，求最后活下来的人在最开始的编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">函数一：y &#x3D; x%i （剃刀函数）通过它来推导</span><br><span class="line">假设在不杀人的情况下，编号是从x&#x3D;1,y&#x3D;1的，所以是函数一右移1，上移1</span><br><span class="line">得到函数二：报数y和编号x的关系 y &#x3D; (x - 1)%i + 1  </span><br><span class="line"></span><br><span class="line">旧：1 2 3 4 5 6 7</span><br><span class="line">新：5 6   1 2 3 4</span><br><span class="line">假设报S &#x3D; 3被杀，新编号做x轴，旧编号做y轴，画图</span><br><span class="line">然后延伸线段，能够发现第一条线段最后会落在 -2 位置上</span><br><span class="line">所以第一个线段当 y &#x3D; 1时，x &#x3D; -S + 1</span><br><span class="line">这个函数的图像等于函数二左移(-S + 1)</span><br><span class="line">得到函数三：旧编号 y &#x3D; (x + S - 1)%i + 1</span><br><span class="line">S是老链表中被杀掉时的报数（函数二中的y，带入函数二到函数三）</span><br><span class="line">i是老链表的杀掉之前的长度</span><br><span class="line">x是新的编号</span><br><span class="line"></span><br><span class="line">得到函数四 旧编号 y &#x3D; (x + (m-1)%i)%i + 1</span><br><span class="line">m是被杀的报数</span><br><span class="line"></span><br><span class="line">最后简化成 y &#x3D; (x + m - 1)%i + 1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">josephusKill2</span><span class="params">(Node head, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == head || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">1</span>; <span class="comment">// tmp -&gt; list size</span></span><br><span class="line">    <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> live = getLive(size, m); <span class="comment">// tmp -&gt; service node position</span></span><br><span class="line">    <span class="keyword">while</span> (--live != <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在一共有i个节点，数到m就杀死节点，最终会活下来的节点，请返回它在有i个节点时候的编号</span></span><br><span class="line"><span class="comment">// 旧 </span></span><br><span class="line"><span class="comment">// getLive(N, m)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLive</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getLive(i - 1, m)   长度为i-1时候，活下来的编号</span></span><br><span class="line">    <span class="keyword">return</span> (getLive(i - <span class="number">1</span>, m) + m - <span class="number">1</span>) % i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个 N×3 的矩阵 matrix，对于每一个长度为 3 的小数组 arr，都表示一个大楼的三个数 据。</span><br><span class="line">arr[0]表示大楼的左边界，arr[1]表示大楼的右边界，arr[2]表示大楼的高度(一定大于 0)。 </span><br><span class="line">每座大楼的地基都在 X 轴上，大楼之间可能会有重叠，请返回整体的轮廓线数组。</span><br><span class="line"></span><br><span class="line">【举例】 matrix &#x3D;&#123;&#123;2,5,6&#125;, &#123;1,7,4&#125;, &#123;4,6,7&#125;, &#123;3,6,5&#125;, &#123;10,13,2&#125;, &#123;9,11,3&#125;, &#123;12,14,4&#125;,&#123;10,12,5&#125; &#125;</span><br><span class="line"></span><br><span class="line">返回: &#123;&#123;1,2,4&#125;,&#123;2,4,6&#125;, &#123;4,6,7&#125;, &#123;6,7,4&#125;, &#123;9,10,3&#125;, &#123;10,12,5&#125;, &#123;12,14,4&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">思考如何计算出每个坐标当前高度即可</span><br><span class="line">&#123;2,5,6&#125;-&gt; 坐标2高度+6，坐标5高度-6，这样就计算出每个坐标的高度</span><br><span class="line">如果有多个坐标点相同，先计算+，再计算-</span><br><span class="line">如果有多个高度相同，要统计累加次数，当高度减掉时减掉次数</span><br><span class="line">用两个Map实现</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述高度变化的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x; <span class="comment">// x轴上的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAdd;<span class="comment">// true为加入，false为删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h; <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Op</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">boolean</span> isAdd, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.isAdd = isAdd;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序的比较策略</span></span><br><span class="line"><span class="comment">// 1，第一个维度的x值从小到大。</span></span><br><span class="line"><span class="comment">// 2，如果第一个维度的值相等，看第二个维度的值，“加入”排在前，“删除”排在后</span></span><br><span class="line"><span class="comment">// 3，如果两个对象第一维度和第二个维度的值都相等，则认为两个对象相等，谁在前都行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OpComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Op</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Op o1, Op o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.x != o2.x) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.x - o2.x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o1.isAdd != o2.isAdd) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.isAdd ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部流程的主方法</span></span><br><span class="line"><span class="comment">// [s,e,h]</span></span><br><span class="line"><span class="comment">// [s,e,h]</span></span><br><span class="line"><span class="comment">// &#123; &#123;1,5,3&#125; , &#123;6,8,4&#125;  .. ...  ...    &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; buildingOutline(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">    Op[] ops = <span class="keyword">new</span> Op[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        ops[i * <span class="number">2</span>] = <span class="keyword">new</span> Op(matrix[i][<span class="number">0</span>], <span class="keyword">true</span>, matrix[i][<span class="number">2</span>]);</span><br><span class="line">        ops[i * <span class="number">2</span> + <span class="number">1</span>] = <span class="keyword">new</span> Op(matrix[i][<span class="number">1</span>], <span class="keyword">false</span>, matrix[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把描述高度变化的对象数组，按照规定的排序策略排序</span></span><br><span class="line">    Arrays.sort(ops, <span class="keyword">new</span> OpComparator());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TreeMap就是java中的红黑树结构，直接当作有序表来使用</span></span><br><span class="line">    <span class="comment">// key  某个高度  value  次数</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; mapHeightTimes = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// key   x点，   value 最大高度</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; mapXHeight = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ops.length; i++) &#123;</span><br><span class="line">        <span class="comment">// ops[i]</span></span><br><span class="line">        <span class="keyword">if</span> (ops[i].isAdd) &#123; <span class="comment">// 如果当前是加入操作</span></span><br><span class="line">            <span class="keyword">if</span> (!mapHeightTimes.containsKey(ops[i].h)) &#123; <span class="comment">// 没有出现的高度直接新加记录</span></span><br><span class="line">                mapHeightTimes.put(ops[i].h, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 之前出现的高度，次数加1即可</span></span><br><span class="line">                mapHeightTimes.put(ops[i].h, mapHeightTimes.get(ops[i].h) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前是删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (mapHeightTimes.get(ops[i].h) == <span class="number">1</span>) &#123; <span class="comment">// 如果当前的高度出现次数为1，直接删除记录</span></span><br><span class="line">                mapHeightTimes.remove(ops[i].h);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前的高度出现次数大于1，次数减1即可</span></span><br><span class="line">                mapHeightTimes.put(ops[i].h, mapHeightTimes.get(ops[i].h) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据mapHeightTimes中的最大高度，设置mapXvalueHeight表</span></span><br><span class="line">        <span class="keyword">if</span> (mapHeightTimes.isEmpty()) &#123; <span class="comment">// 如果mapHeightTimes为空，说明最大高度为0</span></span><br><span class="line">            mapXHeight.put(ops[i].x, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果mapHeightTimes不为空，通过mapHeightTimes.lastKey()取得最大高度</span></span><br><span class="line">            mapXHeight.put(ops[i].x, mapHeightTimes.lastKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res为结果数组，每一个List&lt;Integer&gt;代表一个轮廓线，有开始位置，结束位置，高度，一共三个信息</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 一个新轮廓线的开始位置</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 之前的最大高度</span></span><br><span class="line">    <span class="keyword">int</span> preHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据mapXvalueHeight生成res数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, Integer&gt; entry : mapXHeight.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 当前位置</span></span><br><span class="line">        <span class="keyword">int</span> curX = entry.getKey();</span><br><span class="line">        <span class="comment">// 当前最大高度</span></span><br><span class="line">        <span class="keyword">int</span> curMaxHeight = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (preHeight != curMaxHeight) &#123; <span class="comment">// 之前最大高度和当前最大高度不一样时</span></span><br><span class="line">            <span class="keyword">if</span> (preHeight != <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(start, curX, preHeight)));</span><br><span class="line">            &#125;</span><br><span class="line">            start = curX;</span><br><span class="line">            preHeight = curMaxHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Nim博弈问题</span><br><span class="line">给定一个非负数组，每一个值代表该位置上有几个铜板。</span><br><span class="line">a和b玩游戏，a先手，b后手， 轮到某个人的时候，只能在一个位置上拿任意数量的铜板，但是不能不拿。谁最先把铜 板拿完谁赢。</span><br><span class="line">假设a和b都极度聪明，请返回获胜者的名字</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先手让自己每次拿的时候，异或和都不等于0，并且让后手拿的时候，异或和等于0，就能保证自己先手赢</span><br><span class="line"></span><br><span class="line">结论：数组的eor !&#x3D; 0，先手win，eor &#x3D;&#x3D; 0,后手win</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，长度为N且每个值都是正数，代表N个人的体重。再给定一个正数 limit，代表一艘船的载重。</span><br><span class="line">以下是坐船规则 :</span><br><span class="line">1)每艘船最多只能坐两人;</span><br><span class="line">2)乘客 的体重和不能超过limit</span><br><span class="line">返回如果同时让这N个人过河最少需要几条船。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">排序，在limit&#x2F;2的位置上，L往左移动，R往右移动，L+R&lt;limit，则R++</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请保证arr有序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBoat</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="comment">// Arrays.sort(arr);</span></span><br><span class="line">    <span class="keyword">if</span>(arr[N - <span class="number">1</span>] &gt; limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lessR = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 所有的人体重都不超过limit，继续讨论,  &lt;= limit / 2  最右的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N  - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= (limit / <span class="number">2</span>)) &#123;</span><br><span class="line">            lessR = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lessR == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  &lt;= limit / 2</span></span><br><span class="line">    <span class="keyword">int</span> L = lessR;</span><br><span class="line">    <span class="keyword">int</span> R = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> noUsed = <span class="number">0</span>; <span class="comment">// 画X的数量统计，画对号的量(加工出来的)</span></span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> solved = <span class="number">0</span>; <span class="comment">// 此时的[L]，让R画过了几个数</span></span><br><span class="line">        <span class="keyword">while</span> (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            solved++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// R来到又不达标的位置</span></span><br><span class="line">        <span class="keyword">if</span> (solved == <span class="number">0</span>) &#123;</span><br><span class="line">            noUsed++;</span><br><span class="line">            L--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时的[L]，让R画过了solved（&gt;0）个数</span></span><br><span class="line">            L = Math.max(-<span class="number">1</span>, L - solved);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = lessR + <span class="number">1</span>;<span class="comment">// 左半区总个数  &lt;= limit /2 的区域</span></span><br><span class="line">    <span class="keyword">int</span> used = all - noUsed; <span class="comment">// 画对号的量</span></span><br><span class="line">    <span class="keyword">int</span> moreUnsolved = (N - all) - used; <span class="comment">// &gt; limit/2 区中，没搞定的数量</span></span><br><span class="line">    <span class="keyword">return</span> used + ((noUsed + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + moreUnsolved;</span><br><span class="line">&#125;<span class="comment">// 请保证arr有序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBoat</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="comment">// Arrays.sort(arr);</span></span><br><span class="line">    <span class="keyword">if</span>(arr[N - <span class="number">1</span>] &gt; limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lessR = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 所有的人体重都不超过limit，继续讨论,  &lt;= limit / 2  最右的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N  - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= (limit / <span class="number">2</span>)) &#123;</span><br><span class="line">            lessR = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lessR == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  &lt;= limit / 2</span></span><br><span class="line">    <span class="keyword">int</span> L = lessR;</span><br><span class="line">    <span class="keyword">int</span> R = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> noUsed = <span class="number">0</span>; <span class="comment">// 画X的数量统计，画对号的量(加工出来的)</span></span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> solved = <span class="number">0</span>; <span class="comment">// 此时的[L]，让R画过了几个数</span></span><br><span class="line">        <span class="keyword">while</span> (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            solved++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// R来到又不达标的位置</span></span><br><span class="line">        <span class="keyword">if</span> (solved == <span class="number">0</span>) &#123;</span><br><span class="line">            noUsed++;</span><br><span class="line">            L--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时的[L]，让R画过了solved（&gt;0）个数</span></span><br><span class="line">            L = Math.max(-<span class="number">1</span>, L - solved);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = lessR + <span class="number">1</span>;<span class="comment">// 左半区总个数  &lt;= limit /2 的区域</span></span><br><span class="line">    <span class="keyword">int</span> used = all - noUsed; <span class="comment">// 画对号的量</span></span><br><span class="line">    <span class="keyword">int</span> moreUnsolved = (N - all) - used; <span class="comment">// &gt; limit/2 区中，没搞定的数量</span></span><br><span class="line">    <span class="keyword">return</span> used + ((noUsed + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + moreUnsolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串str，求最长回文子序列长度</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：把str逆序，一个样本做行，一个样本做列，求最长公共子序列</span><br><span class="line">解法二：范围上尝试模型，L..R，填一半的dp表，右下角无效</span><br><span class="line">四种可能：</span><br><span class="line">和L有关，和R有关，和L&#x2F;R无关，和L&#x2F;R有关</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个二维数组matrix，每个单元都是一个整数，有正有负。</span><br><span class="line">最开始一条长度为0的蛇，从矩阵最左侧任选一个单元格进入地图，蛇每次只能够到达当前位置的右上相邻，右侧相邻和右下相邻的单元格。</span><br><span class="line">蛇蛇到达一个单元格后，自身的长度会 瞬间加上该单元格的数值，任何情况下长度为负则游戏结束。</span><br><span class="line">小Q是个天才，他拥有一 个超能力，可以在游戏开始的时候把地图中的某一个节点的值变为其相反数(注:最多 只能改变一个节点)。</span><br><span class="line">问在小Q游戏过程中，他的蛇蛇最长长度可以到多少?</span><br><span class="line">比如:</span><br><span class="line">1 -4  10</span><br><span class="line">3 -2 -1</span><br><span class="line">2 -1  0</span><br><span class="line">0  5 -2</span><br><span class="line">最优路径为从最左侧的3开始，3 -&gt; -4(利用能力变成4) -&gt; 10。所以返回17。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">业务上尝试模型</span><br><span class="line">每次都递归统计使用能力和非使用能力的解</span><br><span class="line">baseCase：</span><br><span class="line">当前使用&#x2F;不使用能力，以及当前第0行的答案</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从假想的最优左侧到达(i,j)的旅程中</span></span><br><span class="line"><span class="comment">// 0) 在没有使用过能力的情况下，返回路径最大和，没有可能到达的话，返回负</span></span><br><span class="line"><span class="comment">// 1) 在使用过能力的情况下，返回路径最大和，没有可能到达的话，返回负</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] process(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123; <span class="comment">// (i,j)就是最左侧的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; m[i][j], -m[i][j] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] preAns = process(m, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 所有的路中，完全不使用能力的情况下，能够到达的最好长度是多大</span></span><br><span class="line">    <span class="keyword">int</span> preUnuse = preAns[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 所有的路中，使用过一次能力的情况下，能够到达的最好长度是多大</span></span><br><span class="line">    <span class="keyword">int</span> preUse = preAns[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        preAns = process(m, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        preUnuse = Math.max(preUnuse, preAns[<span class="number">0</span>]);</span><br><span class="line">        preUse = Math.max(preUse, preAns[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m.length) &#123;</span><br><span class="line">        preAns = process(m, i + <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        preUnuse = Math.max(preUnuse, preAns[<span class="number">0</span>]);</span><br><span class="line">        preUse = Math.max(preUse, preAns[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// preUnuse 之前旅程，没用过能力</span></span><br><span class="line">    <span class="comment">// preUse 之前旅程，已经使用过能力了</span></span><br><span class="line">    <span class="keyword">int</span> no = -<span class="number">1</span>; <span class="comment">// 之前没使用过能力，当前位置也不使用能力，的最优解</span></span><br><span class="line">    <span class="keyword">int</span> yes = -<span class="number">1</span>; <span class="comment">// 不管是之前使用能力，还是当前使用了能力，请保证能力只使用一次，最优解</span></span><br><span class="line">    <span class="keyword">if</span> (preUnuse &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        no = m[i][j] + preUnuse;</span><br><span class="line">        yes = -m[i][j] + preUnuse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preUse &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        yes = Math.max(yes, m[i][j] + preUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; no, yes &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右 括号，返回公式的计算结果。</span><br><span class="line">【举例】</span><br><span class="line">str&#x3D;&quot;48*((70-65)-43)+8*1&quot;，返回-1816。</span><br><span class="line">str&#x3D;&quot;3+1*4&quot;，返回7。</span><br><span class="line">str&#x3D;&quot;3+(1*4)&quot;，返回7。</span><br><span class="line">【说明】 </span><br><span class="line">1.可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查。 </span><br><span class="line">2.如果是负数，就需要用括号括起来，比如&quot;4*(-3)&quot;。</span><br><span class="line">但如果负数作为公式的开头 或括号部分的开头，则可以没有括号，比如&quot;-3*4&quot;和&quot;(-3*4)&quot;都是合法的。 </span><br><span class="line">3.不用考虑计算过程中会发生溢出的情况。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">通过递归f(0)，当遇到&#39;)&#39;则终止计算，遇到&#39;(&#39;则迭代计算,返回值返回递归结果和当前计算到的index</span><br><span class="line">将每个符号压入队列中，遇到符号&#39;+-*&#x2F;&#39;时，把前面的符号合成一个数字</span><br><span class="line">每次压入队列中判断的队列的头部是否是&#39;*&#x2F;&#39;，若是，则弹出前两个字符进行计算合并后再压入队列中</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value(str.toCharArray(), <span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止</span></span><br><span class="line"><span class="comment">// 返回两个值，长度为2的数组</span></span><br><span class="line"><span class="comment">// 0) 负责的这一段的结果是多少</span></span><br><span class="line"><span class="comment">// 1) 负责的这一段计算到了哪个位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] value(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    LinkedList&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] bra = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 从i出发，开始撸串</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.length &amp;&amp; str[i] != <span class="string">')'</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是数字，就一直累加字符</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + str[i++] - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] != <span class="string">'('</span>) &#123; <span class="comment">// 遇到的是运算符号，添加累加的字符数字</span></span><br><span class="line">            addNum(que, cur);</span><br><span class="line">            que.addLast(String.valueOf(str[i++]));</span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到左括号了</span></span><br><span class="line">            bra = value(str, i + <span class="number">1</span>);</span><br><span class="line">            cur = bra[<span class="number">0</span>];</span><br><span class="line">            i = bra[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addNum(que, cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; getNum(que), i &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把当前数字添加进队列，队列顶部是 '* /'时，拿出来计算，再放回去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(LinkedList&lt;String&gt; que, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        String top = que.pollLast();</span><br><span class="line">        <span class="keyword">if</span> (top.equals(<span class="string">"+"</span>) || top.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            que.addLast(top);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = Integer.valueOf(que.pollLast());</span><br><span class="line">            num = top.equals(<span class="string">"*"</span>) ? (cur * num) : (cur / num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    que.addLast(String.valueOf(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把队列的数据都拿出来计算，里面只有加号和减号了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(LinkedList&lt;String&gt; que)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">true</span>;</span><br><span class="line">    String cur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        cur = que.pollFirst();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            add = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            add = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = Integer.valueOf(cur);</span><br><span class="line">            res += add ? num : (-num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">对于一个字符串, 从前开始读和从后开始读是一样的, 我们就称这个字符串是回文串。</span><br><span class="line">例如&quot;ABCBA&quot;,&quot;AA&quot;, &quot;A&quot; 是回文串, 而&quot;ABCD&quot;, &quot;AAB&quot;不是回文串。</span><br><span class="line">牛牛特别喜欢回文串, 他手中有一个字符串s, 牛牛在思考能否从字 符串中移除部分(0个或多个)字符使其变为回文串，并且牛牛认为空串不是回文串。</span><br><span class="line">牛牛发现移除的方案可能有 很多种, 希望你来帮他计算一下一共有多少种移除方案可以使s变为回文串。</span><br><span class="line">对于两种移除方案, 如果移除的字 符依次构成的序列不一样就是不同的方案。</span><br><span class="line">例如，XXY 4种 ABA 5种</span><br><span class="line">【说明】 这是今年的原题，提供的说明和例子都很让人费解。现在根据当时题目的所有测试用例，重新解释当时的题目</span><br><span class="line">含义:</span><br><span class="line"></span><br><span class="line"> 1) &quot;1AB23CD21&quot;，你可以选择删除A、B、C、D，然后剩下子序列&#123;1,2,3,2,1&#125;，只要剩下的子序列是同一个，</span><br><span class="line">那么就只算1种方法，和A、B、C、D选择什么样的删除顺序没有关系。 </span><br><span class="line"></span><br><span class="line">2)&quot;121A1&quot;，其中有两个&#123;1,2,1&#125;的子序列，第一个&#123;1,2,1&#125;是由&#123;位置0，位置1，位置2&#125;构成，第二个&#123;1,2,1&#125; 是由&#123;位置0，位置1，位置4&#125;构成。</span><br><span class="line">这两个子序列被认为是不同的子序列。也就是说在本题中，认为字面值一样 但是位置不同的字符就是不同的。 </span><br><span class="line"></span><br><span class="line">3)其实这道题是想求，str中有多少个不同的子序列，每一种子序列只对应一种删除方法，那就是把多余的东 西去掉，而和去掉的顺序无关。</span><br><span class="line"></span><br><span class="line">4)也许你觉得我的解释很荒谬，但真的是这样，不然解释不了为什么，XXY 4种 ABA 5种，而且其他的测试用例都印证了这一点。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">范围上尝试模型，dp表，右下角没用，中间对角线L&#x3D;&#x3D;R，第二条判断L和L+1的是否相等</span><br><span class="line">dp[L][R]的可能性：</span><br><span class="line">一：L无关，R无关 &#x3D; a</span><br><span class="line">二：L有关，R无关 &#x3D; b</span><br><span class="line">三：L无关，R有关 &#x3D; c</span><br><span class="line">四：L有关，R有关 &#x3D; d(str[L]&#x3D;&#x3D;str[R]时成立)</span><br><span class="line"></span><br><span class="line">所以最后dp[L][R] &#x3D; a+ b + c + d</span><br><span class="line">而dp[L+1][R-1] &#x3D; a   dp[L+1][R] &#x3D; a + c     dp[L][R-1] &#x3D; a + b</span><br><span class="line">所以 a + b + c &#x3D; dp[L+1][R] + dp[L][R-1] - dp[L+1][R-1]</span><br><span class="line">str[L]&#x3D;&#x3D;str[R]时，d &#x3D; dp[L+1][R-1] + 1 (因为中间可以是空串)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">way1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = s.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>][len + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]，在空串不算回文串的情况下，求str[i..j]有多少不同的回文子序列</span></span><br><span class="line">    <span class="comment">// index -&gt; dp</span></span><br><span class="line">    <span class="comment">// str[index-1]</span></span><br><span class="line">    <span class="comment">// dp 1 str 0</span></span><br><span class="line">    <span class="comment">// dp 2 str 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> subLen = <span class="number">2</span>; subLen &lt;= len; subLen++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= len - subLen + <span class="number">1</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + subLen - <span class="number">1</span>;</span><br><span class="line">            dp[l][r] += dp[l + <span class="number">1</span>][r];</span><br><span class="line">            dp[l][r] += dp[l][r - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s[l - <span class="number">1</span>] == s[r - <span class="number">1</span>])</span><br><span class="line">                dp[l][r] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[l][r] -= dp[l + <span class="number">1</span>][r - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个正数1，裂开的方法有一种，(1) 给定一个正数2，裂开的方法有两种，(1和1)、(2) 给定一个正数3，裂开的方法有三种，(1、1、1)、(1、2)、</span><br><span class="line">(3) 给定一个正数4，裂开的方法有五种，</span><br><span class="line">(1、1、1、1)、(1、1、2)、(1、3)、(2、2)、 (4)</span><br><span class="line">给定一个正数n，求裂开的方法数。 动态规划优化状态依赖的技巧</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">定义一个函数f(1,N)，限制裂开的值不能比1小，递归调用f(X,N-X)，若调用到f(N,0)，则认为是一种方法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pre  要裂开rest的，前一个约束(rest裂开的第一个部分不能&lt;pre)</span></span><br><span class="line"><span class="comment">// rest 还剩多少值，需要去裂开</span></span><br><span class="line"><span class="comment">// 返回裂开的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 之前裂开的方案，构成了1种有效方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果rest还剩下东西</span></span><br><span class="line">    <span class="keyword">if</span> (pre &gt; rest) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pre; i &lt;= rest; i++) &#123; <span class="comment">// i : rest第一个裂开的部分，值是多少</span></span><br><span class="line">        ways += process(i, rest - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改动态规划</span></span><br><span class="line"><span class="comment">//枚举行为可以优化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pre -&gt; 0  ~ n  (0不用)</span></span><br><span class="line">    <span class="comment">// rest -&gt; 0 ~ n</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[0][...]不需要填</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">        dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pre = n; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rest = pre; rest &lt;= n; rest++) &#123;</span><br><span class="line">            <span class="comment">// dp[pre][rest]</span></span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pre; i &lt;= rest; i++) &#123; <span class="comment">// i : rest第一个裂开的部分，值是多少</span></span><br><span class="line">                ways += dp[i] [rest - i];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[pre][rest] = ways;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;优化动态规划的枚举行为</span><br><span class="line">&#x2F;&#x2F;dp[i][j] &#x3D; dp[i+1][j] + dp[i][j-i]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; dp.length; pre++) &#123;</span><br><span class="line">        dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">1</span>; pre &lt; dp.length; pre++) &#123;</span><br><span class="line">        dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = n - <span class="number">1</span>; pre &gt; <span class="number">0</span>; pre--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line">            dp[pre][rest] = dp[pre + <span class="number">1</span>][rest] + dp[pre][rest - pre];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定一个正数N，代表你有1～N这些数字。在给定一个整数K。</span><br><span class="line">你可以随意排列这些数字，但是每一种排列都有若干个逆序对。返回有多少种排列，正好有K个逆序对</span><br><span class="line"></span><br><span class="line">例子1:</span><br><span class="line">Input: n &#x3D; 3, k &#x3D; 0</span><br><span class="line">Output: 1</span><br><span class="line">解释：</span><br><span class="line">只有[1,2,3]这一个排列有0个逆序对。 </span><br><span class="line"></span><br><span class="line">例子2:</span><br><span class="line">Input: n &#x3D; 3, k &#x3D; 1</span><br><span class="line">Output: 2</span><br><span class="line">解释</span><br><span class="line">[3,2,1]有(3,2)、(3,1)、(2,1)三个逆序对，所以不达标。</span><br><span class="line">达标的只有：</span><br><span class="line">[1,3,2]只有(3,2)这一个逆序对，所以达标。</span><br><span class="line">[2,1,3]只有(2,1)这一个逆序对，所以达标。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">一个样本做行，一个样本做列的尝试模型</span><br><span class="line">dp[i][j]表示在i行，j列中，长度是i的数中，有j个逆序对的排列数量</span><br><span class="line">dp[i][j]的可能性：</span><br><span class="line">一：i&lt;j时，i放在任意一个位置S，产生的新的排列，依赖dp[i-1][j...0]</span><br><span class="line">二：j&gt;&#x3D;j时，i依赖dp[i-1][j...j-i+1]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span> || K &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[0][...] 不要</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// dp[1][1...] 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">// dp[i][j] i &gt; j dp[i-1][j...0]</span></span><br><span class="line">            <span class="comment">// dp[i][j] i &gt;= j dp[i-1][j....j-i+1]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = j; s &gt;= Math.max(<span class="number">0</span>, j - i + <span class="number">1</span>); s--) &#123;</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][s];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化枚举行为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span> || K &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[0][...] 不要</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// dp[1][1...] 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">            <span class="comment">// dp[i][j] -&gt; dp[i][j-1]</span></span><br><span class="line">            <span class="comment">// j == 1 dp[i][1] dp[i][0]</span></span><br><span class="line">            <span class="comment">//				if (i &gt; j) &#123;</span></span><br><span class="line">            <span class="comment">//					dp[i][j] = dp[i][j - 1] + dp[i - 1][j];</span></span><br><span class="line">            <span class="comment">//				&#125;</span></span><br><span class="line">            <span class="comment">//				if (i &lt;= j) &#123;</span></span><br><span class="line">            <span class="comment">//					dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i];</span></span><br><span class="line">            <span class="comment">//				&#125;</span></span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] - (i &lt;= j ? dp[i - <span class="number">1</span>][j - i] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符 合搜索二叉树条件的最大拓扑结构的大小。 </span><br><span class="line">拓扑结构：不是子树，只要能连起来的结构都算。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bstTopoSize1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = maxTopo(head, head);</span><br><span class="line">    max = Math.max(bstTopoSize1(head.left), max);</span><br><span class="line">    max = Math.max(bstTopoSize1(head.right), max);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxTopo</span><span class="params">(Node h, Node n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; n != <span class="keyword">null</span> &amp;&amp; isBSTNode(h, n, n.value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxTopo(h, n.left) + maxTopo(h, n.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBSTNode</span><span class="params">(Node h, Node n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isBSTNode(h.value &gt; value ? h.left : h.right, n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个长度为偶数的数组arr，长度记为2*N。前N个为左部分，后N个为右部分。 arr就可以表示为&#123;L1,L2,..,Ln,R1,R2,..,Rn&#125;， 请将数组调整成&#123;R1,L1,R2,L2,..,Rn,Ln&#125;的样子。</span><br><span class="line">时间复杂度O(N),空间复杂度O(1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">一个f函数，i&lt;N时，他对应的坐标是 2 * i , i &gt; N时，对应的(i - N) * 2 - 1</span><br><span class="line">循环替换数字，一直踢到环结束，但是环结束不一定表示数组的数据都替换完了</span><br><span class="line"></span><br><span class="line">结论一（背）：当S &#x3D; 3^K - 1(偶数)时，它环的出发点是1,3,9...3^(K-1)</span><br><span class="line"></span><br><span class="line">结论二：如何把 abcde fgh   变成 fgh abcde?</span><br><span class="line">解：abcde逆序，fgh逆序 -》 edcbahgf -&gt;再逆序  fgh abcde</span><br><span class="line"></span><br><span class="line">那么当S &#x3D; 14时，他不是3^K - 1 这种数时，找到和他最接近小于他的值 8，</span><br><span class="line">L1L2L3L4[L5L6L7 R1R2R3R4]R5R6R7    把括号中的按照 结论二操作</span><br><span class="line">得到 L1L2L3L4 R1R2R3R4 L5L6L7 R5R6R7 ,那么，前8个就可以调用f函数找下一个环搞定</span><br><span class="line">后面6个值，接着重复操作分解即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的长度为len，调整前的位置是i，返回调整之后的位置</span></span><br><span class="line"><span class="comment">// 下标不从0开始，从1开始</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">modifyIndex2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= len / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (i - (len / <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="comment">// 数组必须不为空，且长度为偶数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr != <span class="keyword">null</span> &amp;&amp; arr.length != <span class="number">0</span> &amp;&amp; (arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        shuffle(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在arr[L..R]上做完美洗牌的调整（arr[L..R]范围上一定要是偶数个数字）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (R - L + <span class="number">1</span> &gt; <span class="number">0</span>) &#123; <span class="comment">// 切成一块一块的解决，每一块的长度满足(3^k)-1</span></span><br><span class="line">        <span class="keyword">int</span> len = R - L + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算小于等于len并且是离len最近的，满足(3^k)-1的数</span></span><br><span class="line">        <span class="comment">// 也就是找到最大的k，满足3^k &lt;= len+1</span></span><br><span class="line">        <span class="keyword">while</span> (base &lt;= (len + <span class="number">1</span>) / <span class="number">3</span>) &#123; <span class="comment">// base &gt; (N+1)/3</span></span><br><span class="line">            base *= <span class="number">3</span>;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3^k -1</span></span><br><span class="line">        <span class="comment">// 当前要解决长度为base-1的块，一半就是再除2</span></span><br><span class="line">        <span class="keyword">int</span> half = (base - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// [L..R]的中点位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 要旋转的左部分为[L+half...mid], 右部分为arr[mid+1..mid+half]</span></span><br><span class="line">        <span class="comment">// 注意在这里，arr下标是从0开始的</span></span><br><span class="line">        rotate(arr, L + half, mid, mid + half);</span><br><span class="line">        <span class="comment">// 旋转完成后，从L开始算起，长度为base-1的部分进行下标连续推</span></span><br><span class="line">        cycles(arr, L, base - <span class="number">1</span>, k);</span><br><span class="line">        <span class="comment">// 解决了前base-1的部分，剩下的部分继续处理</span></span><br><span class="line">        L = L + base - <span class="number">1</span>; <span class="comment">// L -&gt;     [] [+1...R]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从start位置开始，往右len的长度这一段，做下标连续推</span></span><br><span class="line"><span class="comment">// 出发位置依次为1,3,9...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cycles</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> len, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到每一个出发位置trigger，一共k个</span></span><br><span class="line">    <span class="comment">// 每一个trigger都进行下标连续推</span></span><br><span class="line">    <span class="comment">// 出发位置是从1开始算的，而数组下标是从0开始算的。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, trigger = <span class="number">1</span>; i &lt; k; i++, trigger *= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> preValue = arr[trigger + start - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cur = modifyIndex2(trigger, len);</span><br><span class="line">        <span class="keyword">while</span> (cur != trigger) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[cur + start - <span class="number">1</span>];</span><br><span class="line">            arr[cur + start - <span class="number">1</span>] = preValue;</span><br><span class="line">            preValue = tmp;</span><br><span class="line">            cur = modifyIndex2(cur, len);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[cur + start - <span class="number">1</span>] = preValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [L..M]为左部分，[M+1..R]为右部分，左右两部分互换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    reverse(arr, L, M);</span><br><span class="line">    reverse(arr, M + <span class="number">1</span>, R);</span><br><span class="line">    reverse(arr, L, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [L..R]做逆序调整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[L];</span><br><span class="line">        arr[L++] = arr[R];</span><br><span class="line">        arr[R--] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。</span><br><span class="line">比如， &#123;3,1,2,4,5&#125;、&#123;4,5,3,1,2&#125;或&#123;1,2,4,5,3&#125;都代表同样结构的环形山。 </span><br><span class="line">山峰A和山峰B能够相互看见的条件为: </span><br><span class="line">1.如果A和B是同一座山，认为不能相互看见。 </span><br><span class="line">2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见。 </span><br><span class="line">3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min。</span><br><span class="line">1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见</span><br><span class="line">2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互 看见</span><br><span class="line">3)两个方向只要有一个能看见，就算A和B可以相互看见 给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见。</span><br><span class="line">进阶: 给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">不重复：2N - 3 O(1)</span><br><span class="line">进阶：</span><br><span class="line">单调栈解决</span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年01月26日 15:03</p>
        <p>原始链接： <a class="post-url" href="/2020/11/01/algorithm-trainingcamp4/" title="&#39;数据结构与算法 训练营四期&#39;">https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/&title=《'数据结构与算法 训练营四期'》 — Kuro's Blog&pic=images/algorithm.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/&title=《'数据结构与算法 训练营四期'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'数据结构与算法 训练营四期'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/11/01/algorithm-trainingcamp4/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/algorithm/" class="color5">algorithm</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#训练营四期"><span class="post-toc-text">训练营四期</span></a></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/11/01/algorithm-topinterview/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;数据结构与算法 精选TOP面试题&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/10/31/algorithm-trainingcamp3/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;数据结构与算法 训练营三期&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="algorithm-trainingcamp4" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Elasticsearch/">Elasticsearch</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/MySql/">MySql</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Transaction/">Transaction</a><a class="category-link" href="/categories/Zookeeper/">Zookeeper</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/algorithm/">algorithm</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 12px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 12px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>