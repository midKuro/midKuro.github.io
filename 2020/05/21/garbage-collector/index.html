<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;JVM（三） 垃圾收集器&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="垃圾收集器与内存分配策略GC回收的区间  清理Eden区和Survivor区叫Minor GC； 清理Old区叫Major GC； 清理整个堆空间————包括年轻代和老年代叫Full GC；   GC回收的定位保守式 GC在进行 GC 的时候，会从一些已知的位置（也就是GC Roots）开始扫描内存，扫描到一个数字就判断他是不是可能是指向GC堆中的一个指针,然后一直递归的扫描下去，最后完成可达性分">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;JVM（三） 垃圾收集器&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/05/21/garbage-collector/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="垃圾收集器与内存分配策略GC回收的区间  清理Eden区和Survivor区叫Minor GC； 清理Old区叫Major GC； 清理整个堆空间————包括年轻代和老年代叫Full GC；   GC回收的定位保守式 GC在进行 GC 的时候，会从一些已知的位置（也就是GC Roots）开始扫描内存，扫描到一个数字就判断他是不是可能是指向GC堆中的一个指针,然后一直递归的扫描下去，最后完成可达性分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-1.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-2.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-3.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-4.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-5.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-6.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-7.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-8.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-13.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-9.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-14.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-15.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-16.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-17.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-18.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-10.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-11.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-12.png">
<meta property="article:published_time" content="2020-05-21T14:40:00.000Z">
<meta property="article:modified_time" content="2020-12-07T02:41:47.754Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://midkuro.gitee.io/images/garbage-collector/collector-1.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?code-JRipY21QjX";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-garbage-collector" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;JVM（三） 垃圾收集器&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/JVM/">JVM</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-05-21
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="GC回收的区间"><a href="#GC回收的区间" class="headerlink" title="GC回收的区间"></a>GC回收的区间</h3><p><img src="/images/garbage-collector/collector-1.png" alt="collector-1"></p>
<ul>
<li>清理<code>Eden</code>区和<code>Survivor</code>区叫<code>Minor GC</code>；</li>
<li>清理<code>Old</code>区叫<code>Major GC</code>；</li>
<li>清理整个堆空间————包括年轻代和老年代叫<code>Full GC</code>；</li>
</ul>
<p><img src="/images/garbage-collector/collector-2.png" alt="collector-2"></p>
<h3 id="GC回收的定位"><a href="#GC回收的定位" class="headerlink" title="GC回收的定位"></a>GC回收的定位</h3><h4 id="保守式-GC"><a href="#保守式-GC" class="headerlink" title="保守式 GC"></a>保守式 GC</h4><p>在进行 <code>GC</code> 的时候，会从一些已知的位置（也就是<code>GC Roots</code>）开始扫描内存，<strong>扫描到一个数字就判断他是不是可能是指向GC堆中的一个指针</strong>,然后一直递归的扫描下去，最后完成可达性分析。</p>
<p>这里扫描会涉及上下边界检查，GC堆的上下界是已知的、对齐检查，通常分配空间的时候会有对齐要求，假如说是4字节对齐，那么不能被4整除的数字就肯定不是指针。</p>
<p>这种模糊的判断方法因为无法准确判断一个位置上是否是真的指向 <code>GC</code> ，<code>GC</code> 采取一种保守的态度，把所有可疑的引用均当作指针，所以被命名为<strong>保守式 GC</strong>。 </p>
<ul>
<li>优点：不需要准确的判断出一个指针，所以效率快。</li>
<li>缺点：不能识别指针和非指针，对于一些已经死掉的对象，很可能会被误认为仍有地方引用他们，引起无用的内存占用，造成资源浪费。</li>
</ul>
<h4 id="准确式-GC"><a href="#准确式-GC" class="headerlink" title="准确式 GC"></a>准确式 GC</h4><p>与<strong>保守式 GC</strong> 相对的就是<strong>准确式 GC</strong>，何为 准确式 GC？就是我们准确的知道，某个位置上面是否是指针。</p>
<p>也就是说给定某个位置上的某块数据，要能知道它的准确类型是什么，这样才可以合理地解读数据的含义； <code>GC</code> 所关心的含义就是 <strong>这块数据是不是指针</strong>。<br>要实现这样的 <code>GC</code>，JVM就要能够判断出所有位置上的数据是不是指向 <code>GC</code> 堆里的引用，包括活动记录（栈、寄存器）里的数据。</p>
<p>在java中实现的方式是：从外部记录下类型信息，存成映射表，在<code>HotSpot</code>虚拟机中把这种映射表称之为<code>OopMap</code>，不同的虚拟机名称可能不一样。</p>
<p><code>GC</code>开始的时候，就通过<code>OopMap</code>这样的一个映射表知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<p>生成映射表的两种方式：</p>
<ul>
<li>每次都遍历原始的映射表，循环的一个个偏移量扫描过去；这种用法也叫 “ 解释式 ”。</li>
<li>为每个映射表生成一块定制的扫描代码（想像扫描映射表的循环被展开的样子），以后每次要用映射表就直接执行生成的扫描代码；这种用法也叫 “ 编译式 ”。</li>
</ul>
<h4 id="半保守式-GC"><a href="#半保守式-GC" class="headerlink" title="半保守式 GC"></a>半保守式 GC</h4><p>JVM可以选择在栈上不记录类型信息，而是通过让数据自身带上标记，也就是对象上记录类型信息。这样的话，扫描栈的时候仍然会跟<strong>保守式 GC</strong>的过程一样，但扫描到 <code>GC</code> 堆内的对象时因为对象带有足够类型信息了，JVM就能够判断出在该对象内什么位置的数据是引用类型了，这种是<strong>半保守式 GC</strong>。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。这里讨论的收集器基于JDK 1.7 Update 14之后的 <code>HotSpot</code> 虚拟机，这个虚拟机包含的所有收集器如下图所示</p>
<p><img src="/images/garbage-collector/collector-3.png" alt="collector-3"></p>
<p>上图展示了作用于不同分代的多种收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析 <code>CMS</code> 和 <code>G1</code> 这两款相对复杂的收集器，了解它们的部分运作细节。</p>
<p>先明确一点：下文是各个收集器的比较，但不是为了挑出最好的收集器，而是挑选最合适的收集器。</p>
<p><strong>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型，G1是逻辑分代，物理不分代，除此之外不仅逻辑分代，而且物理分代。</strong></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><code>Serial</code>收集器是最基本、发展历史最悠久的收集器，曾经是虚拟机新生代收集的唯一选择。这<strong>是一个单线程的收集器</strong>，但它的 “ 单线程 ” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>“<code>Stop The World</code>“ 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了 <code>Serial/Serial Old</code> 收集器的运行过程。</p>
<p><img src="/images/garbage-collector/collector-4.png" alt="collector-4"></p>
<p>实际上到现在为止，它依然是虚拟机运行在 <code>Client</code> 模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，<code>Serial</code> 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，<code>Serial</code> 收集器对于运行在 <code>Client</code> 模式下的虚拟机来说是一个很好的选择。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><code>ParNew</code> 收集器其实就是 <code>Serial</code> 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 <code>Serial</code> 收集器可用的所有控制参数（例如：<code>-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure</code>等）、收集算法、Stop The World、对象分配规则、回收策略等都与 <code>Serial</code> 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。<code>ParNew</code> 收集器的工作过程如下图所示。</p>
<p><img src="/images/garbage-collector/collector-5.png" alt="collector-5"></p>
<p><code>ParNew</code> 收集器除了多线程收集之外，其他与 <code>Serial</code> 收集器相比并没有太多创新之处，但它却是许多运行在 <code>Server</code> 模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了 <code>Serial</code> 收集器外，目前只有它能与 <code>CMS</code> 收集器（并发收集器，后面有介绍）配合工作。</p>
<p><code>ParNew</code> 收集器在单 CPU 的环境中不会有比 <code>Serial</code> 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百地保证可以超越 <code>Serial</code> 收集器。</p>
<p>当然，随着可以使用的 CPU 的数量的增加，它对于 <code>GC</code> 时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（如 32 个)的环境下，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。</p>
<p>注意，从 <code>ParNew</code> 收集器开始，后面还会接触到几款并发和并行的收集器。这里有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<ul>
<li>并行（<code>Parallel</code>）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（<code>Concurrent</code>）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个 CPU 上。</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p><code>Parallel Scavenge</code> 收集器是一个新生代收集器，它也<strong>是使用复制算法的收集器，又是并行的多线程收集器</strong>……看上去和 <code>ParNew</code> 都一样，那它有什么特别之处呢？</p>
<p><code>Parallel Scavenge</code> 收集器的特点是它的关注点与其他收集器不同，<strong>CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 <code>Parallel Scavenge</code> 收集器的目标则是达到一个可控制的吞吐量（<code>Throughput</code>）</strong>。</p>
<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉1分钟，那吞吐量就是99% 。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p><code>Parallel Scavenge</code>收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p>
<p><code>MaxGCPauseMillis</code>参数允许的值是一个大于 0 的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。</p>
<p>不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集 300MB 新生代肯定比收集 500MB 快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p><code>GCTimeRatio</code> 参数的值应当是一个 0 到 100 的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为 19，那允许的最大 GC 时间就占总时间的 5%（即 1/（1+19）），默认值为 99 ，就是允许最大 1%（即 1/（1+99））的垃圾收集时间。</p>
<p>由于与吞吐量关系密切，<code>Parallel Scavenge</code> 收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，<code>Parallel Scavenge</code> 收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 与 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为 GC 自适应的调节策略（<code>GC Ergonomics</code>）。</p>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><code>Serial Old</code> 是 <code>Serial</code> 收集器的老年代版本，它同样<strong>是一个单线程收集器，使用“标记-整理”算法</strong>。这个收集器的主要意义也是在于给 <code>Client</code> 模式下的虚拟机使用。如果在 <code>Server</code> 模式下，那么它主要还有两大用途：一种用途是在 JDK 1.5 以及之前的版本中与 <code>Parallel Scavenge</code> 收集器搭配使用，另一种用途就是作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。这两点都将在后面的内容中详细讲解。<code>Serial Old</code> 收集器的工作过程如下图所示。</p>
<p><img src="/images/garbage-collector/collector-6.png" alt="collector-6"></p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><code>Parallel Old</code> 是 <code>Parallel Scavenge</code> 收集器的老年代版本，<strong>使用多线程和“标记-整理”算法</strong>。这个收集器是在 JDK 1.6 中才开始提供的，在此之前，新生代的 <code>Parallel Scavenge</code> 收集器一直处于比较尴尬的状态。</p>
<p>原因是，如果新生代选择了 <code>Parallel Scavenge</code> 收集器，老年代除了 <code>Serial Old（PS MarkSweep）</code>收集器外别无选择（<code>Parallel Scavenge</code> 收集器无法与 <code>CMS</code> 收集器配合工作）。</p>
<p>由于老年代 <code>Serial Old</code> 收集器在服务端应用性能上的 “ 拖累 ”，使用了 <code>Parallel Scavenge</code> 收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 <code>ParNew</code> 加 <code>CMS</code> 的组合 “ 给力 ”。</p>
<p>直到 <code>Parallel Old</code> 收集器出现后，“ 吞吐量优先 ” 收集器终于有了比较名副其实的应用组合，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 <code>Parallel Scavenge</code> 加 <code>Parallel Old</code> 收集器。<code>Parallel Old</code> 收集器的工作过程如下图所示。</p>
<p><img src="/images/garbage-collector/collector-7.png" alt="collector-7"></p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><code>CMS（Concurrent Mark Sweep）</code>收集器是一种以<strong>获取最短回收停顿时间为目标</strong>的收集器。</p>
<p>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求，<strong>默认对象年龄是6</strong>。</p>
<p>从名字（包含”Mark Sweep”）上就可以看出，<code>CMS</code> 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（<code>CMS initial mark</code>）</li>
<li>并发标记（<code>CMS concurrent mark</code>）</li>
<li>重新标记（<code>CMS remark</code>）</li>
<li>并发清除（<code>CMS concurrent sweep</code>）</li>
</ul>
<p>其中，<strong>初始标记、重新标记这两个步骤仍然需要 “<code>Stop The World</code>“</strong>。初始标记仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，速度很快，并发标记阶段就是进行 <code>GC RootsTracing</code> 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，<strong>从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。</strong></p>
<p><img src="/images/garbage-collector/collector-8.png" alt="collector-8"></p>
<p><code>CMS</code> 是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，但是 CMS 还远达不到完美的程度，它有以下 3 个明显的缺点：</p>
<p>第一、<strong>导致吞吐量降低。</strong><code>CMS</code> 收集器对 CPU 资源非常敏感。其实，面向并发设计的程序都对 CPU 资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。</p>
<p><code>CMS</code> 默认启动的回收线程数是（CPU数量+3）/4，也就是当 CPU 在4个以上时，并发回收时垃圾收集线程不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降。但是当 CPU 不足 4 个（譬如2个）时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。</p>
<p>第二、<strong><code>CMS</code> 收集器无法处理浮动垃圾（<code>Floating Garbage</code>），可能出现”Concurrent Mode Failure”失败而导致另一次 <code>Full GC</code>（新生代和老年代同时回收） 的产生。</strong>由于 <code>CMS</code> 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，<code>CMS</code> 无法在当次收集中处理掉它们，只好留待下一次 <code>GC</code> 时再清理掉。这一部分垃圾就称为 “ 浮动垃圾 ” 。</p>
<p>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此<code>CMS</code> 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
<p>在 JDK 1.5 的默认设置下，<code>CMS</code>收集器当老年代使用了 68% 的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在 JDK 1.6 中，CMS 收集器的启动阈值已经提升至 92% 。</p>
<p>要是 <code>CMS</code> 运行期间预留的内存无法满足程序需要，就会出现一次 “Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用 <code>Serial Old</code> 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数<code>-XX:CM SInitiatingOccupancyFraction</code>设置得太高很容易导致大量 “Concurrent Mode Failure” 失败，性能反而降低。</p>
<p>第三、<strong>产生空间碎片。</strong> <code>CMS</code> 是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code> 。</p>
<p>为了解决这个问题，CMS 收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数（默认就是开启的），用于在<code>CMS</code>收集器顶不住要进行 <code>Full GC</code> 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数是用于设置执行多少次不压缩的 <code>Full GC</code> 后，跟着来一次带压缩的（默认值为0，表示每次进入<code>Full GC</code>时都进行碎片整理）。</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><img src="/images/garbage-collector/collector-13.png" alt="collector-13"></p>
<p><code>G1（Garbage-First）</code>收集器是当今收集器技术发展的最前沿成果之一，<code>G1</code> 是一款面向服务端应用的垃圾收集器。<code>HotSpot</code> 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 <code>CMS</code> 收集器。与其他 <code>GC</code> 收集器相比，<code>G1</code> 具备如下特点。</p>
<p><strong>并行与并发</strong>： <code>G1</code> 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 <code>GC</code> 动作，<code>G1</code> 收集器仍然可以通过并发的方式让 Java 程序继续执行。</p>
<p><strong>分代收集</strong>： 与其他收集器一样，分代概念在 <code>G1</code> 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 <code>GC</code> 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 <code>GC</code> 的旧对象以获取更好的收集效果。</p>
<p><strong>空间整合</strong>： 与 <code>CMS</code> 的 “ 标记—清理 ” 算法不同，<code>G1</code> 从整体来看是基于 “ 标记—整理 ” 算法实现的收集器，从局部（两个 <code>Region</code> 之间）上来看是基于“复制”算法实现的，会将存活较少的Region中的对象移动到另外一个Region中，然后清除整个Region。意味着 <code>G1</code> 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 <code>GC</code> 。</p>
<p><strong>可预测的停顿</strong>： 这是 <code>G1</code> 相对于 <code>CMS</code> 的另一大优势，降低停顿时间是 <code>G1</code> 和 <code>CMS</code> 共同的关注点，但 <code>G1</code> 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</p>
<p>在 <code>G1</code> 之前的其他收集器进行收集的范围都是整个新生代或者老年代，而 <code>G1</code> 不再是这样。使用 <code>G1</code> 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（<code>Region</code>），虽然还保留有新生代和老年代的概念，但<strong>新生代和老年代不再是物理隔离</strong>的了，它们都是一部分 <code>Region</code> （不需要连续）的集合。</p>
<p><code>G1</code> 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。<code>G1</code> 在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 <code>Region</code></strong>（这也就是<code>Garbage-First</code>名称的来由），保证了 <code>G1</code> 收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>在 <code>G1</code> 收集器中，<code>Region</code> 之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用 <code>Remembered Set</code> 来避免全堆扫描的。</p>
<p><code>G1</code> 中每个<code>Region</code> 都有一个与之对应的 <code>Remembered Set</code>，虚拟机发现程序在对 <code>Reference</code> 类型的数据进行写操作时，会产生一个 <code>Write Barrier</code>暂时中断写操作，检查 <code>Reference</code> 引用的对象是否处于不同的 <code>Region</code> 之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过 <code>CardTable</code> 把相关引用信息记录到被引用对象所属的 <code>Region</code> 的 <code>Remembered Set</code> 之中。当进行内存回收时，在 <code>GC</code> 根节点的枚举范围中加入 <code>Remembered Set</code> 即可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计算维护 <code>Remembered Set</code> 的操作，<code>G1</code> 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（<code>Initial Marking</code>）</li>
<li>并发标记（<code>Concurrent Marking</code>）</li>
<li>最终标记（<code>Final Marking</code>）</li>
<li>筛选回收（<code>Live Data Counting and Evacuation</code>）</li>
</ul>
<p><code>G1</code> 的前几个步骤的运作过程和 <code>CMS</code> 有很多相似之处。</p>
<p><strong>初始标记阶段</strong>仅仅只是标记一下 <code>GC Roots</code> 能直接关联到的对象，并且修改 TAMS（<code>Next Top at Mark Start</code>）的值，让下一阶段用户程序并发运行时，能在正确可用的 <code>Region</code> 中创建新对象，这阶段<strong>需要停顿线程</strong>，但耗时很短。</p>
<p><strong>并发标记阶段</strong>是从 <code>GC Root</code> 开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但<strong>可与用户程序并发执行</strong>。</p>
<p>而<strong>最终标记阶段</strong>则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 <code>Remembered Set Logs</code> 里面，最终标记阶段需要把 <code>Remembered Set Logs</code> 的数据合并到 <code>Remembered Set</code> 中，这阶段<strong>需要停顿线程，但是可并行执行</strong>。</p>
<p>最后在筛选回收阶段首先对各个 <code>Region</code> 的回收价值和成本进行排序，根据用户所期望的 <code>GC</code> 停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 <code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。</p>
<p><img src="/images/garbage-collector/collector-9.png" alt="collector-9"></p>
<p><strong>G1的新老年代比例是动态浮动的，5%~60%，当然也可以通过参数设定，但是一般不要手工指定，因为这是G1预测STW停顿时间的基准。</strong></p>
<blockquote>
<p><strong>G1的垃圾回收有三个阶段，第一个是YGC，第二个是MixedGC，第三个才是FGC</strong>，什么时候触发YGC呢？</p>
<p><strong>Eden空间内存不足、多线程并发执行</strong></p>
<p>如果G1产生FGC，你应该做什么？</p>
<p>1.扩内存</p>
<p>2.提高CPU性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大）</p>
<p>3.<strong>降低MixedGC触发的阈值，让MixedGC提早发生（默认是45%）</strong></p>
<p><code>XX:InitiatingHeapOccupacyPercent</code> <strong>*默认值45%</strong>，整个堆内存空间超过这个值时，启动MixedGC</p>
</blockquote>
<h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p><img src="/images/garbage-collector/collector-14.png" alt="collector-14"></p>
<p><img src="/images/garbage-collector/collector-15.png" alt="collector-15"></p>
<blockquote>
<p>产生漏标：</p>
<p>标记进行时增加了一个<strong>黑到白</strong>的引用，并且删除了<strong>灰对白</strong>的引用，这个白的则会漏标，漏标是指本来应该存活的对象被当做垃圾回收了。  </p>
<p>解决方法：使其中一个条件不成立即可</p>
</blockquote>
<p><img src="/images/garbage-collector/collector-16.png" alt="collector-16"></p>
<blockquote>
<p>incremental update是CMS使用的一种策略，而SATB是G1使用的一种策略。</p>
</blockquote>
<blockquote>
<p>为什么G1使用SATB？</p>
<p>当灰色指向白色的引用消失时，如果没有黑色指向白色引用会被push到堆栈中，下次扫描时拿到这个引用，由于有RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet</p>
</blockquote>
<h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><p>阅读 <code>GC</code> 日志是处理 Java 虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。</p>
<p>每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的 <code>GC</code> 日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125 : [GC  [DefNew : 3324K-＞152K（3712K），0.0025925 secs] 3324K-＞152K（11904K），0.0031680 secs]</span><br><span class="line">100.667 : [Full GC  [Tenured : 0 K-＞210K（10240K），0.0149142secs] 4603K-＞210K（19456K），[Perm:2999K-＞2999K（21248K）]，0.0150007 secs] [Times:user&#x3D;0.01 sys&#x3D;0.00，real&#x3D;0.02 secs]</span><br></pre></td></tr></table></figure>

<p>最前面的数字<code>33.125</code>： 和 <code>100.667</code>： 代表了 <code>GC</code> 发生的时间，这个数字的含义是从 Java 虚拟机启动以来经过的秒数。</p>
<p><code>GC</code> 日志开头的 <code>[GC</code> 和 <code>[Full GC</code> 说明了这次垃圾收集的停顿类型，而不是用来区分新生代 GC 还是老年代 GC 的。</p>
<p>如果有 <code>Full</code> ，说明这次 <code>GC</code> 是发生了 <code>Stop-The-World</code>的，例如下面这段新生代收集器 <code>ParNew</code> 的日志也会出现 <code>[Full GC</code>（这一般是因为出现了分配担保失败之类的问题，所以才导致 STW）。如果是调用 <code>System.gc()</code> 方法所触发的收集，那么在这里将显示 <code>[Full GC（System）</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736 : [ParNew : 261599K-＞261599K（261952K），0.0000288 secs]</span><br></pre></td></tr></table></figure>

<p>接下来的 <code>[DefNew</code>、<code>[Tenured</code>、<code>[Perm</code> 表示 <code>GC</code> 发生的区域，这里显示的区域名称与使用的 <code>GC</code> 收集器是密切相关的，例如上面样例所使用的 <code>Serial</code> 收集器中的新生代名为 “<code>Default New Generation</code>“，所以显示的是 <code>[DefNew</code>。 如果是 <code>ParNew</code> 收集器，新生代名称就会变为 <code>[ParNew</code>，意为 “<code>Parallel New Generation</code>“。如果采用 <code>Parallel Scavenge</code> 收集器，那它配套的新生代称为 <code>PSYoungGen</code>，老年代和永久代同理，名称也是由收集器决定的。</p>
<p>后面方括号内部的 <code>3324K-＞152K（3712K</code>含义是 <strong>GC 前该内存区域已使用容量 -＞ GC 后该内存区域已使用容量 （该内存区域总容量）</strong>。而在方括号之外的 <code>3324K-＞152K（11904K）</code> 表示 <strong>GC 前 Java 堆已使用容量 -＞ GC 后 Java 堆已使用容量 （Java 堆总容量）</strong>。</p>
<p>再往后，<code>0.0025925 secs</code> 表示<strong>该内存区域 GC 所占用的时间，单位是秒</strong>。有的收集器会给出更具体的时间数据，如 <code>[Times:user=0.01 sys=0.00，real=0.02 secs]</code> ，这里面的 user、sys 和 real 与 Linux 的 time 命令所输出的时间含义一致，分别代表用户态消耗的 CPU 时间、内核态消耗的 CPU 事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。</p>
<p>CPU 时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘 I/O、等待线程阻塞，而 CPU 时间不包括这些耗时，但当系统有多 CPU 或者多核的话，多线程操作会叠加这些 CPU 时间，所以读者看到 user 或 sys 时间超过 real 时间是完全正常的。</p>
<h3 id="PS日志"><a href="#PS日志" class="headerlink" title="PS日志"></a>PS日志</h3><p><img src="/images/garbage-collector/collector-17.png" alt="collector-17"></p>
<p><img src="/images/garbage-collector/collector-18.png" alt="collector-17"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eden space 5632K, 94% used [0x00000000ff980000,0x00000000ffeb3e28,0x00000000fff00000)</span><br><span class="line">后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br><span class="line"></span><br><span class="line">total &#x3D; eden + 1个survivor</span><br></pre></td></tr></table></figure>



<h3 id="CMS日志"><a href="#CMS日志" class="headerlink" title="CMS日志"></a>CMS日志</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: <span class="number">6144</span>K-&gt;<span class="number">640</span>K(<span class="number">6144</span>K), <span class="number">0</span><span class="variable">.0265885</span> secs] <span class="number">6585</span>K-&gt;<span class="number">2770</span>K(<span class="number">19840</span>K), <span class="number">0</span><span class="variable">.0268035</span> secs] [Times: user=<span class="number">0</span><span class="variable">.02</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.02</span> secs]</span><br><span class="line"><span class="comment">//ParNew：年轻代收集器</span></span><br><span class="line"><span class="comment">//6144-&gt;640：收集前后的对比</span></span><br><span class="line"><span class="comment">//（6144）：整个年轻代容量</span></span><br><span class="line"><span class="comment">//6585 -&gt; 2770：整个堆的情况</span></span><br><span class="line"><span class="comment">//（19840）：整个堆大小</span></span><br><span class="line"></span><br><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-<span class="keyword">initial</span>-mark: <span class="number">8511</span>K(<span class="number">13696</span>K)] <span class="number">9866</span>K(<span class="number">19840</span>K), <span class="number">0</span><span class="variable">.0040321</span> secs] [Times: user=<span class="number">0</span><span class="variable">.01</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs] </span><br><span class="line"><span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line"><span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0</span><span class="variable">.018</span>/<span class="number">0</span><span class="variable">.018</span> secs] [Times: user=<span class="number">0</span><span class="variable">.01</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.02</span> secs] </span><br><span class="line"><span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0</span><span class="variable">.000</span>/<span class="number">0</span><span class="variable">.000</span> secs] [Times: user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs] </span><br><span class="line"><span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: <span class="number">1597</span> K (<span class="number">6144</span> K)][Rescan (parallel) , <span class="number">0</span><span class="variable">.0008396</span> secs][<span class="keyword">weak</span> refs processing, <span class="number">0</span><span class="variable">.0000138</span> secs][<span class="keyword">class</span> unloading, <span class="number">0</span><span class="variable">.0005404</span> secs][scrub symbol <span class="keyword">table</span>, <span class="number">0</span><span class="variable">.0006169</span> secs][scrub <span class="keyword">string</span> <span class="keyword">table</span>, <span class="number">0</span><span class="variable">.0004903</span> secs][<span class="number">1</span> CMS-remark: <span class="number">8511</span>K(<span class="number">13696</span>K)] <span class="number">10108</span>K(<span class="number">19840</span>K), <span class="number">0</span><span class="variable">.0039567</span> secs] [Times: user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs] </span><br><span class="line"><span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line"><span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line"><span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line"><span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line"><span class="comment">//scrub symbol(string) table: </span></span><br><span class="line"><span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line"><span class="comment">//internalized string respectively</span></span><br><span class="line"><span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line"><span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0</span><span class="variable">.005</span>/<span class="number">0</span><span class="variable">.005</span> secs] [Times: user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.01</span> secs] </span><br><span class="line"><span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0</span><span class="variable">.000</span>/<span class="number">0</span><span class="variable">.000</span> secs] [Times: user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs]</span><br><span class="line"><span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></table></figure>

<h3 id="G1日志"><a href="#G1日志" class="headerlink" title="G1日志"></a>G1日志</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (young) (<span class="keyword">initial</span>-mark), <span class="number">0</span><span class="variable">.0015790</span> secs]</span><br><span class="line"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span><br><span class="line"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span><br><span class="line">[Parallel Time: <span class="number">1</span><span class="variable">.5</span> ms, GC Workers: <span class="number">1</span>] <span class="comment">//一个GC线程</span></span><br><span class="line">[GC Worker Start (ms):  <span class="number">92635</span><span class="variable">.7</span>]</span><br><span class="line">[Ext Root Scanning (ms):  <span class="number">1</span><span class="variable">.1</span>]</span><br><span class="line">[Update RS (ms):  <span class="number">0</span><span class="variable">.0</span>]</span><br><span class="line">[Processed Buffers:  <span class="number">1</span>]</span><br><span class="line">[Scan RS (ms):  <span class="number">0</span><span class="variable">.0</span>]</span><br><span class="line">[Code Root Scanning (ms):  <span class="number">0</span><span class="variable">.0</span>]</span><br><span class="line">[Object Copy (ms):  <span class="number">0</span><span class="variable">.1</span>]</span><br><span class="line">[Termination (ms):  <span class="number">0</span><span class="variable">.0</span>]</span><br><span class="line">[Termination Attempts:  <span class="number">1</span>]</span><br><span class="line">[GC Worker Other (ms):  <span class="number">0</span><span class="variable">.0</span>]</span><br><span class="line">[GC Worker Total (ms):  <span class="number">1</span><span class="variable">.2</span>]</span><br><span class="line">[GC Worker End (ms):  <span class="number">92636</span><span class="variable">.9</span>]</span><br><span class="line">[Code Root Fixup: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Code Root Purge: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Clear CT: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Other: <span class="number">0</span><span class="variable">.1</span> ms]</span><br><span class="line">[Choose CSet: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Ref Proc: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Ref Enq: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Redirty Cards: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Humongous Register: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Humongous Reclaim: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Free CSet: <span class="number">0</span><span class="variable">.0</span> ms]</span><br><span class="line">[Eden: <span class="number">0</span><span class="variable">.0B</span>(<span class="number">1024</span><span class="variable">.0K</span>)-&gt;<span class="number">0</span><span class="variable">.0B</span>(<span class="number">1024</span><span class="variable">.0K</span>) Survivors: <span class="number">0</span><span class="variable">.0B</span>-&gt;<span class="number">0</span><span class="variable">.0B</span> Heap: <span class="number">18</span><span class="variable">.8M</span>(<span class="number">20</span><span class="variable">.0M</span>)-&gt;<span class="number">18</span><span class="variable">.8M</span>(<span class="number">20</span><span class="variable">.0M</span>)]</span><br><span class="line">[Times: user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-<span class="keyword">end</span>, <span class="number">0</span><span class="variable">.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法evacuation，进行FGC</span></span><br><span class="line">[Full GC (Allocation Failure)  <span class="number">18</span>M-&gt;<span class="number">18</span>M(<span class="number">20</span>M), <span class="number">0</span><span class="variable">.0719656</span> secs]</span><br><span class="line">[Eden: <span class="number">0</span><span class="variable">.0B</span>(<span class="number">1024</span><span class="variable">.0K</span>)-&gt;<span class="number">0</span><span class="variable">.0B</span>(<span class="number">1024</span><span class="variable">.0K</span>) Survivors: <span class="number">0</span><span class="variable">.0B</span>-&gt;<span class="number">0</span><span class="variable">.0B</span> Heap: <span class="number">18</span><span class="variable">.8M</span>(<span class="number">20</span><span class="variable">.0M</span>)-&gt;<span class="number">18</span><span class="variable">.8M</span>(<span class="number">20</span><span class="variable">.0M</span>)], [Metaspace: <span class="number">3876</span>K-&gt;<span class="number">3876</span>K(<span class="number">1056768</span>K)] [Times: user=<span class="number">0</span><span class="variable">.07</span> sys=<span class="number">0</span><span class="variable">.00</span>, <span class="keyword">real</span>=<span class="number">0</span><span class="variable">.07</span> secs]</span><br></pre></td></tr></table></figure>



<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><p>JDK 1.7 中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，在下图中整理了这些参数供读者实践时参考。<br><img src="/images/garbage-collector/collector-10.png" alt="collector-10"><br><img src="/images/garbage-collector/collector-11.png" alt="collector-11"></p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的<code>Eden</code>区上。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。<br><img src="/images/garbage-collector/collector-12.png" alt="collector-12"></p>
<h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代 <code>Eden</code> 区中分配。当 <code>Eden</code> 区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。</p>
<p>虚拟机提供了<code>-XX:+PrintGCDetails</code>这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">//出现一次Minor GC</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC [DefNew : <span class="number">6651</span>K-＞<span class="number">148</span>K（<span class="number">9216</span>K），<span class="number">0</span><span class="variable">.0070106</span> secs]<span class="number">6651</span>K-＞<span class="number">6292</span>K（<span class="number">19456</span>K），</span><br><span class="line"><span class="number">0</span><span class="variable">.0070426</span> secs][Times:user=<span class="number">0</span><span class="variable">.00</span> sys=<span class="number">0</span><span class="variable">.00</span>，<span class="keyword">real</span>=<span class="number">0</span><span class="variable">.00</span> secs]</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">4326</span>K[<span class="number">0</span>x029d0000，<span class="number">0</span>x033d0000，<span class="number">0</span>x033d0000）</span><br><span class="line">eden space <span class="number">8192</span>K，<span class="number">51</span>%used[<span class="number">0</span>x029d0000，<span class="number">0</span>x02de4828，<span class="number">0</span>x031d0000）</span><br><span class="line">from space <span class="number">1024</span>K，<span class="number">14</span>%used[<span class="number">0</span>x032d0000，<span class="number">0</span>x032f5370，<span class="number">0</span>x033d0000）</span><br><span class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0</span>x031d0000，<span class="number">0</span>x031d0000，<span class="number">0</span>x032d0000）</span><br><span class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">6144</span>K[<span class="number">0</span>x033d0000，<span class="number">0</span>x03dd0000，<span class="number">0</span>x03dd0000）</span><br><span class="line">the space <span class="number">10240</span>K，<span class="number">60</span>%used[<span class="number">0</span>x033d0000，<span class="number">0</span>x039d0030，<span class="number">0</span>x039d0200，<span class="number">0</span>x03dd0000）</span><br><span class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2114</span>K[<span class="number">0</span>x03dd0000，<span class="number">0</span>x049d0000，<span class="number">0</span>x07dd0000）</span><br><span class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0</span>x03dd0000，<span class="number">0</span>x03fe0998，<span class="number">0</span>x03fe0a00，<span class="number">0</span>x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure>

<p>上方代码的 <code>testAllocation()</code> 方法中，尝试分配 3 个 2MB 大小和 1 个 4MB 大小的对象，在运行时通过<code>-Xms20M、-Xmx20M、-Xmn10M</code>这 3 个参数限制了 Java 堆大小为 20MB ，不可扩展，其中 10MB 分配给新生代，剩下的 10MB 分配给老年代。</p>
<p><code>-XX:SurvivorRatio=8</code>决定了新生代中 <code>Eden</code> 区与一个 Survivor 区的空间比例是 8:1，从输出的结果也可以清晰地看到 eden space 8192K、from space 1024K、to space 1024K 的信息，新生代总可用空间为 9216KB（Eden区+1个Survivor区的总容量）。</p>
<p>执行 <code>testAllocation()</code> 中分配 <code>allocation4</code> 对象的语句时会发生一次 <code>Minor GC</code>，这次 <code>GC</code> 的结果是新生代 6651KB 变为 148KB ，而总内存占用量则几乎没有减少（因为 <code>allocation1</code>、<code>allocation2</code>、<code>allocation3</code> 三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。</p>
<p>这次 <code>GC</code> 发生的原因是给 <code>allocation4</code> 分配内存的时候，发现 <code>Eden</code> 已经被占用了 6MB，剩余空间已不足以分配 <code>allocation4</code> 所需的 4MB 内存，因此发生 <code>Minor GC</code>。</p>
<p><code>GC</code> 期间虚拟机又发现已有的 3 个 2MB 大小的对象全部无法放入 <code>Survivor</code> 空间（<code>Survivor</code> 空间只有 1MB 大小），所以只好<strong>通过分配担保机制提前转移到老年代去</strong>。</p>
<p>这次 <code>GC</code> 结束后，4MB 的 <code>allocation4</code> 对象顺利分配在 <code>Eden</code> 中，因此程序执行完的结果是 <code>Eden</code> 占用 4MB（被<code>allocation4</code>占用），<code>Survivor</code> 空闲，老年代被占用 6MB（被<code>allocation1</code>、<code>allocation2</code>、<code>allocation3</code>占用）。通过 <code>GC</code> 日志可以证实这一点。</p>
<p><strong><code>Minor GC</code> 和 <code>Full GC</code> 有什么不一样吗？</strong></p>
<ul>
<li><p>新生代 GC（<code>Minor GC</code>）：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 <code>Minor GC</code> 非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>老年代 GC（<code>Major GC</code>/<code>Full GC</code>）：指发生在老年代的 GC，出现了 <code>Major GC</code>，经常会伴随至少一次的 <code>Minor GC</code>（但非绝对的，在 <code>Parallel Scavenge</code> 收集器的收集策略里就有直接进行 <code>Major GC</code> 的策略选择过程）。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 10 倍以上。</p>
</li>
</ul>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组（ <code>byte[]</code> 数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（特别是短命大对象，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个 <code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 <code>Eden</code> 区及两个 <code>Survivor</code> 区之间发生大量的内存复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">     *-XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation;</span><br><span class="line">        allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];<span class="comment">//直接分配在老年代中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">671</span>K[<span class="number">0</span>x029d0000，<span class="number">0</span>x033d0000，<span class="number">0</span>x033d0000）</span><br><span class="line">eden space <span class="number">8192</span>K，<span class="number">8</span>%used[<span class="number">0</span>x029d0000，<span class="number">0</span>x02a77e98，<span class="number">0</span>x031d0000）</span><br><span class="line">from space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0</span>x031d0000，<span class="number">0</span>x031d0000，<span class="number">0</span>x032d0000）</span><br><span class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0</span>x032d0000，<span class="number">0</span>x032d0000，<span class="number">0</span>x033d0000）</span><br><span class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">4096</span>K[<span class="number">0</span>x033d0000，<span class="number">0</span>x03dd0000，<span class="number">0</span>x03dd0000）</span><br><span class="line">the space <span class="number">10240</span>K，<span class="number">40</span>%used[<span class="number">0</span>x033d0000，<span class="number">0</span>x037d0010，<span class="number">0</span>x037d0200，<span class="number">0</span>x03dd0000）</span><br><span class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2107</span>K[<span class="number">0</span>x03dd0000，<span class="number">0</span>x049d0000，<span class="number">0</span>x07dd0000）</span><br><span class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0</span>x03dd0000，<span class="number">0</span>x03fdefd0，<span class="number">0</span>x03fdf000，<span class="number">0</span>x049d0000）</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure>

<p>执行以上代码中的 <code>testPretenureSizeThreshold()</code> 方法后，我们看到 <code>Eden</code> 空间几乎没有被使用，而老年代的 10MB 空间被使用了 40%，也就是 4MB 的 <code>allocation</code> 对象直接就分配在老年代中，这是因为 <code>PretenureSizeThreshold</code> 参数被设置为 3MB（就是 3145728，这个参数不能像 -Xmx 之类的参数一样直接写 3MB），因此超过 3MB 的对象都会直接在老年代进行分配。</p>
<p>注意 <code>PretenureSizeThreshold</code> 参数只对 <code>Serial</code> 和 <code>ParNew</code> 两款收集器有效，<code>Parallel Scavenge</code> 收集器不认识这个参数，<code>Parallel Scavenge</code> 收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑 <code>ParNew</code> 加 <code>CMS</code> 的收集器组合。</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。</p>
<p>如果对象在 <code>Eden</code> 出生并经过第一次 <code>Minor GC</code> 后仍然存活，并且能被 <code>Survivor</code> 容纳的话，将被移动到 <code>Survivor</code> 空间中，并且对象年龄设为 1 。对象在 <code>Survivor</code> 区中每“熬过”一次 <code>Minor GC</code>，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置，最大15岁，因为对象头只有4bit存储对象年龄。</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄，年龄从小到大进行<strong>累加</strong>，当加入某个年龄段后，累加和超过 <code>Survivor</code> 空间的一半后，这个年龄段以及年龄大于他们的对象都将直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生 <code>Minor GC</code> 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代 ，所有对象总空间，如果这个条件成立，那么 <code>Minor GC</code> 可以确保是安全的。</p>
<p>如果不成立，则虚拟机会查看<code>HandlePromotionFailure</code>设置值是否允许担保失败，如果允许，将继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次<code>Minor GC</code>，如果小于或者<code>HandlePromotionFailure</code>设置不允许，那么将进行<code>Full GC</code>。</p>
<hr>
<blockquote>
<p>“本篇文章主要摘自《深入理解Java虚拟机_JVM高级特性与最佳实践 第2版》”</p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年12月07日 10:41</p>
        <p>原始链接： <a class="post-url" href="/2020/05/21/garbage-collector/" title="&#39;JVM（三） 垃圾收集器&#39;">https://midkuro.gitee.io/2020/05/21/garbage-collector/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/05/21/garbage-collector/&title=《'JVM（三） 垃圾收集器'》 — Kuro's Blog&pic=images/jvm.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/05/21/garbage-collector/&title=《'JVM（三） 垃圾收集器'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/05/21/garbage-collector/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'JVM（三） 垃圾收集器'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/05/21/garbage-collector/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/05/21/garbage-collector/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/05/21/garbage-collector/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/JVM/" class="color4">JVM</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#垃圾收集器与内存分配策略"><span class="post-toc-text">垃圾收集器与内存分配策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#GC回收的区间"><span class="post-toc-text">GC回收的区间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#GC回收的定位"><span class="post-toc-text">GC回收的定位</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#保守式-GC"><span class="post-toc-text">保守式 GC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#准确式-GC"><span class="post-toc-text">准确式 GC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#半保守式-GC"><span class="post-toc-text">半保守式 GC</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾收集器"><span class="post-toc-text">垃圾收集器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Serial收集器"><span class="post-toc-text">Serial收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ParNew收集器"><span class="post-toc-text">ParNew收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Parallel-Scavenge收集器"><span class="post-toc-text">Parallel Scavenge收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Serial-Old-收集器"><span class="post-toc-text">Serial Old 收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Parallel-Old收集器"><span class="post-toc-text">Parallel Old收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CMS收集器"><span class="post-toc-text">CMS收集器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#G1收集器"><span class="post-toc-text">G1收集器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三色标记算法"><span class="post-toc-text">三色标记算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#GC日志"><span class="post-toc-text">GC日志</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#PS日志"><span class="post-toc-text">PS日志</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CMS日志"><span class="post-toc-text">CMS日志</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#G1日志"><span class="post-toc-text">G1日志</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾收集器参数总结"><span class="post-toc-text">垃圾收集器参数总结</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存分配与回收策略"><span class="post-toc-text">内存分配与回收策略</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#对象优先在Eden分配"><span class="post-toc-text">对象优先在Eden分配</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#大对象直接进入老年代"><span class="post-toc-text">大对象直接进入老年代</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#长期存活的对象将进入老年代"><span class="post-toc-text">长期存活的对象将进入老年代</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#动态对象年龄判定"><span class="post-toc-text">动态对象年龄判定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#空间分配担保"><span class="post-toc-text">空间分配担保</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/05/21/thread-safety/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;Thread（一） 线程安全性&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/05/21/garbage-collection/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;JVM（二） 垃圾回收机制&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="garbage-collector" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Dubbo/">Dubbo</a><a class="category-link" href="/categories/Elasticsearch/">Elasticsearch</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/FastDFS/">FastDFS</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kafka/">Kafka</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/MySql/">MySql</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Transaction/">Transaction</a><a class="category-link" href="/categories/Zookeeper/">Zookeeper</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/algorithm/">algorithm</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 10px;">Dubbo</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 13px;">Kafka</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 12px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 10px;">Dubbo</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 13px;">Kafka</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 12px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>