<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;数据结构与算法 训练营三期&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="训练营三期滑动窗口123给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点绳子的边缘点碰到X轴上的点，也算盖住  123456789解法一：假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找每个下标都需要查找一次&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;数据结构与算法 训练营三期&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="训练营三期滑动窗口123给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点绳子的边缘点碰到X轴上的点，也算盖住  123456789解法一：假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找每个下标都需要查找一次&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://midkuro.gitee.io/images/algorithm-all/alg-05.png">
<meta property="article:published_time" content="2020-10-31T15:33:00.000Z">
<meta property="article:modified_time" content="2020-12-26T13:31:09.195Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://midkuro.gitee.io/images/algorithm-all/alg-05.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?code-JRipY21QjX";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-algorithm-trainingcamp3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;数据结构与算法 训练营三期&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/algorithm/">algorithm</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-10-31
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="训练营三期"><a href="#训练营三期" class="headerlink" title="训练营三期"></a>训练营三期</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置</span><br><span class="line">给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点</span><br><span class="line">绳子的边缘点碰到X轴上的点，也算盖住</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解法一：</span><br><span class="line">假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个</span><br><span class="line">等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找</span><br><span class="line">每个下标都需要查找一次&gt;i-k的位置,时间复杂度O(logN)，有N个点，则总体的时间O(N * logN)</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">采用滑动窗口，LR一开始处于-1位置，R向右滑，滑到arr[R + 1] - arr[L] &gt; K时停止，该答案是index &#x3D; L答案</span><br><span class="line">然后L++,再次判断 arr[R + 1] - arr[L] ?&lt; K,若小于，则R++窗口继续滑动，周而复始</span><br><span class="line">时间复杂度O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nearest = nearestIndex(arr, i, arr[i] - L);</span><br><span class="line">        res = Math.max(res, i - nearest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = R;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口滑动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; N) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; N &amp;&amp; arr[right] - arr[left] &lt;= L) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, right - (left++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号四连"><a href="#括号四连" class="headerlink" title="括号四连"></a>括号四连</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">括号有效配对是指：</span><br><span class="line">1）任何一个左括号都能找到和其正确配对的右括号</span><br><span class="line">2）任何一个右括号都能找到和其正确配对的左括号</span><br><span class="line">有效的：    (())  ()()   (()())  等</span><br><span class="line">无效的：     (()   )(     等</span><br><span class="line">问题一：怎么判断一个括号字符串有效？</span><br><span class="line">问题二：如果一个括号字符串无效，返回至少填几个字符能让其整体有效</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题一解法一：</span><br><span class="line">把&#39;(&#39;压栈，遇到&#39;)&#39;则弹出，当还有&#39;)&#39;且栈为空，或者遍历结束时栈不为空，返回false，其余返回true</span><br><span class="line">问题一解法二：</span><br><span class="line">使用一个Count计数，遇到&#39;(&#39;则++，遇到&#39;)&#39;则--，当count &lt; 0 或者遍历结束后count !&#x3D; 0 ,返回false</span><br><span class="line"></span><br><span class="line">问题二思路：</span><br><span class="line">基于问题一解法二的基础知识下，再开一个need计数，当count &lt; 0,则need++,遍历结束后,结果：need + count</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        count += str[i] == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题二解法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">needParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到的是')'</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                need++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">括号有效配对是指：</span><br><span class="line">1）任何一个左括号都能找到和其正确配对的右括号</span><br><span class="line">2）任何一个右括号都能找到和其正确配对的左括号</span><br><span class="line">返回一个括号字符串中，最长的括号有效子串的长度</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">遇到这种子串的题目，优先思考以[i]开头，答案是什么...或者以[i]结尾，答案是什么...</span><br><span class="line">如：   ( ) ( ) ( ( ) ) ( )</span><br><span class="line">index:0 1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">如果 arr[i] &#x3D; &#39;(&#39; 以左括号结尾，无效，res[i] &#x3D; 0,</span><br><span class="line">如果 arr[i] &#x3D; &#39;)&#39;获取res[i - 1] &#x3D; k,判断 arr[i - k - 1] ?&#x3D; &#39;(&#39;，若不是，则res[i]&#x3D;0</span><br><span class="line">若是，则res[i]&#x3D;k + 2 , 则至少确定了以arr[i - k - 1, i]是一个正确配对的答案</span><br><span class="line">若再往前推，arr[i - k - 2] !&#x3D; 0,表示它前面还有能够拼接的正确括号,res[i] +&#x3D; arr[i - k - 2]</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">第i个位置，看i-1的答案和符号，匹配成功后，再往前跳一步看看是否还有正确的答案</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[0] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            pre = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">// 与str[i]配对的左括号的位置 pre</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给一个正确的括号字符：((()))()(())() ,判断该字符中括号最大嵌套了几层？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line">弄个count计数，遇到&#39;(&#39;，count++，遇到&#39;)&#39;，count--，嵌套的层数就是count的最大值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            max = Math.max(max, ++count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。</span><br><span class="line">如样例所示: s &#x3D; RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">以每个index为分界线，左边涂R，右边涂G，分成两个数组，问题转换成左边数组中G出现的次数，右边R出现的次数</span><br><span class="line">可以增加辅助数组X加速：缓存[i,N-1]上，R出现的次数</span><br><span class="line">而辅助数组Y:[0,N-1]上，G出现的次数，这个信息可以从左往右遍历的时候通过一个信息left记录G出现的次数</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">辅助数组X也可以省略掉，先获取数组中R出现的总次数rAll</span><br><span class="line">在从左往右遍历的过程中，i遇到字符&#39;R&#39;，则rAll--，这时候rAll &#x3D; [i + 1, N - 1]区间上R出现的次数</span><br><span class="line">最后每个分界线的答案 &#x3D; rAll + left</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGRGR -&gt; RRRGG</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPaint</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="comment">//数组中R出现的总次数rAll</span></span><br><span class="line">    <span class="keyword">int</span> rAll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        rAll += str[i] == <span class="string">'R'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独先把R的数量赋值给ans，</span></span><br><span class="line">    <span class="comment">//因为边界线可能出现在 index = 0的左边，或者N-1 的右边，也就是全G或者全R的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans = rAll; <span class="comment">// 如果数组所有的范围，都是右侧范围，都变成G</span></span><br><span class="line">    <span class="comment">//[0,i]上，G出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123; <span class="comment">// 0..i 左侧 n-1..N-1</span></span><br><span class="line">        left += str[i] == <span class="string">'G'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        rAll -= str[i] == <span class="string">'R'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        ans = Math.min(ans, left + rAll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0...N-1 左全部 右无</span></span><br><span class="line">    ans = Math.min(ans, left + (str[N - <span class="number">1</span>] == <span class="string">'G'</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度。</span><br><span class="line">例如:</span><br><span class="line">01111</span><br><span class="line">01001</span><br><span class="line">01001</span><br><span class="line">01111</span><br><span class="line">01011 </span><br><span class="line">其中边框全是1的最大正方形的大小为4*4，所以返回4。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">总流程的时间复杂度一定是O(N^3),因为你任意一个正方形的左上角点，就是O(N^2)，然后还要根据边长&#x3D;1&#x3D;2&#x3D;..N一直扩下去，所以是O(N^2 * N) &#x3D; O(N^3)</span><br><span class="line">也就是说大流程是</span><br><span class="line">for() &#123; &#x2F;&#x2F;限定边长</span><br><span class="line">  for() &#123; &#x2F;&#x2F;遍历i</span><br><span class="line">    for()&#123; &#x2F;&#x2F;遍历j</span><br><span class="line">       &#x2F;&#x2F;验证边长是否是1，达到正方形 : 只有这一环节是有优化空间的</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过创建辅助数组，遍历两次数组得到,每个点往右有几个1的二维数组,往下有几个点的二维数组</span><br><span class="line">时间复杂度2 * O(N^2)</span><br><span class="line">而上面验证长方形可以通过这个辅助数组快速验证O(1)</span><br><span class="line">在总次数是O(N^3)面前，有多少个O(N^2)都是被忽略的，所以总代价还是O(N^3)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算right down数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBorderMap</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = m.length;</span><br><span class="line">    <span class="keyword">int</span> c = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m[r - <span class="number">1</span>][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        right[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        down[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[i][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            down[i][c - <span class="number">1</span>] = down[i + <span class="number">1</span>][c - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = c - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[r - <span class="number">1</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[r - <span class="number">1</span>][i] = right[r - <span class="number">1</span>][i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            down[r - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c - <span class="number">2</span>; j != -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i][j] = down[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义边长，三个循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    setBorderMap(m, right, down); <span class="comment">// O(N^2); + </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = Math.min(m.length, m[<span class="number">0</span>].length); size != <span class="number">0</span>; size--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSizeOfBorder(size, right, down)) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSizeOfBorder</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != right.length - size + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != right[<span class="number">0</span>].length - size + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[i][j] &gt;= size &amp;&amp; down[i][j] &gt;= size</span><br><span class="line">                &amp;&amp; right[i + size - <span class="number">1</span>][j] &gt;= size</span><br><span class="line">                &amp;&amp; down[i][j + size - <span class="number">1</span>] &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数M，请构造出一个长度为M的数组arr，要求</span><br><span class="line">对任意的i、j、k三个位置，如果i&lt;j&lt;k，都有arr[i] + arr[k] !&#x3D; 2*arr[j]</span><br><span class="line">返回构造出的arr</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">数组长长度小于3，都达标</span><br><span class="line">把数组划分成左右两部分，挑选三个奇数不满足a + c !&#x3D; 2b，则(2a-1) + (2c-1) !&#x3D; 2b-1，成倍扩张</span><br><span class="line">偶数也是同理， a + c !&#x3D; 2b，则2a + 2c !&#x3D; 4b</span><br><span class="line">将M长度划分成 (M+1)&#x2F;2的两份数组，左边奇数右边偶数，任意三个基数、三个偶数或者基偶结合，都达标</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成长度为size的达标数组</span></span><br><span class="line"><span class="comment">// 达标：对于任意的 i&lt;k&lt;j，满足   [i] + [j]  != [k] * 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeNo(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="comment">// 一半长达标来</span></span><br><span class="line">    <span class="comment">// 7   :   4</span></span><br><span class="line">    <span class="comment">// 8   :   4</span></span><br><span class="line">    <span class="comment">// [4个奇数] [3个偶]</span></span><br><span class="line">    <span class="keyword">int</span> halfSize = (size + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] base = makeNo(halfSize);</span><br><span class="line">    <span class="comment">// base -&gt; 等长奇数达标来</span></span><br><span class="line">    <span class="comment">// base -&gt; 等长偶数达标来</span></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; halfSize;index++) &#123;</span><br><span class="line">        ans[index] = base[index] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;index &lt; size;index++,i++) &#123;</span><br><span class="line">        ans[index] = base[i] * <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树的头节点head，路径的规定有以下三种不同的规定：</span><br><span class="line"></span><br><span class="line">1）路径必须是头节点出发，到叶节点为止，返回最大路径和</span><br><span class="line">2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和</span><br><span class="line">3）路径可以从任何节点出发，到任何节点，返回最大路径和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题1：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDis</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process2(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x为头的整棵树上，最大路径和是多少，返回。</span></span><br><span class="line"><span class="comment">// 路径要求，一定从x出发，到叶节点，算做一个路径</span></span><br><span class="line"><span class="comment">//叶子节点做baseCase，因为null节点返回0可能会干扰答案</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> next = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = process2(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = Math.max(next, process2(x.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.value + next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二问思路：</span><br><span class="line">二叉树的递归套路</span><br><span class="line">1.与X有关</span><br><span class="line">2.与X无关</span><br><span class="line"></span><br><span class="line">与X有关需要左右数提供什么信息，与X无关需要左右树提供什么信息？</span><br><span class="line">有关：以左&#x2F;右树开头的整数最大和   无关：左&#x2F;右树的整树最大和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> allTreeMaxSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fromHeadMaxSum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> all, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">        allTreeMaxSum = all;</span><br><span class="line">        fromHeadMaxSum = from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）X无关的时候， 1， 左树上的整体最大路径和 2， 右树上的整体最大路径和</span></span><br><span class="line"><span class="comment">// 2) X有关的时候 3， x自己 4， x往左走 5，x往右走</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">f2</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = f2(x.left);</span><br><span class="line">    Info rightInfo = f2(x.right);</span><br><span class="line">    <span class="keyword">int</span> p1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = leftInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p2 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = rightInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p3 = x.value;</span><br><span class="line">    <span class="keyword">int</span> p4 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p4 = x.value + leftInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p5 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p5 = x.value + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> allTreeMaxSum = Math.max(Math.max(Math.max(p1, p2), p3), Math.max(p4, p5));</span><br><span class="line">    <span class="keyword">int</span> fromHeadMaxSum = Math.max(Math.max(p3, p4), p5);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(allTreeMaxSum, fromHeadMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三问：</span></span><br><span class="line"><span class="comment">// 1）X无关的时候， 1， 左树上的整体最大路径和 2， 右树上的整体最大路径和</span></span><br><span class="line"><span class="comment">// 2) X有关的时候 3， x自己 4， x往左走 5，x往右走 6, 既往左，又往右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">f3</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = f3(x.left);</span><br><span class="line">    Info rightInfo = f3(x.right);</span><br><span class="line">    <span class="keyword">int</span> p1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = leftInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p2 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = rightInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p3 = x.value;</span><br><span class="line">    <span class="keyword">int</span> p4 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p4 = x.value + leftInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p5 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p5 = x.value + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p6 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p6 = x.value + leftInfo.fromHeadMaxSum + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> allTreeMaxSum = Math.max(Math.max(Math.max(p1, p2), p3), Math.max(Math.max(p4, p5), p6));</span><br><span class="line">    <span class="keyword">int</span> fromHeadMaxSum = Math.max(Math.max(p3, p4), p5);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(allTreeMaxSum, fromHeadMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在行也有序、列也有序的二维数组中，找num，找到返回true，否则false</span><br><span class="line"></span><br><span class="line">思想：</span><br><span class="line">从右上角（或者左下角）开始走，匹配num，往左走遇到对不上了，就往下走，重复之前的操作</span><br><span class="line">如：</span><br><span class="line">1 2 3   13  16  20    </span><br><span class="line">2 3 4   14  17  21</span><br><span class="line">3 4 15  17  18  22</span><br><span class="line"></span><br><span class="line">找到15的位置: 20-&gt;16-&gt;17-&gt;18-&gt;17-&gt;15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == K) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; K) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上</span><br><span class="line">放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。</span><br><span class="line">每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。</span><br><span class="line">请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。</span><br><span class="line">如果不能使每个机器上的物品相同， 返回-1。 </span><br><span class="line">例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品</span><br><span class="line">经过这些轮后: </span><br><span class="line">第一轮:1    0 &lt;- 5 &#x3D;&gt; 1 1 4</span><br><span class="line">第二轮:1 &lt;- 1 &lt;- 4 &#x3D;&gt; 2 1 3</span><br><span class="line">第三轮:2    1 &lt;- 3 &#x3D;&gt; 2 2 2 </span><br><span class="line">移动了3轮，每个机器上的物品相等，所以返回3</span><br><span class="line">例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品，</span><br><span class="line">这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">机器物品数量总和 %N !&#x3D; 0,必定 -1 无解</span><br><span class="line">转换成以某个index做下标，划分成index左边和右边两块区域</span><br><span class="line">Lsum &#x3D; 左边的机器总包裹数 - 左边所需的总包裹数 ?&gt; 0 ，表示左边的机器数量过多，同理右边也是</span><br><span class="line">若左右两边Lsum和Rsum均小于0，则表示index下标的机器必定有多余包裹，则移动次数 &#x3D; abs(Lsum) + abs(Rsum)</span><br><span class="line">其他情况均是max(abs(Lsum), max(Rsum))</span><br><span class="line"></span><br><span class="line">最后演变成以i结尾，求左边的累加和，右边的累加和，做计算</span><br><span class="line">先遍历得到总物品数sum，每次遍历i进行左边累加和计算，右边累加和通过sum - 左边累加和得到</span><br><span class="line">整体时间复杂度O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MinOps</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> avg = sum / size;</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每个位置都求各自的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// i号机器，是中间机器，左(0~i-1) i 右(i+1~N-1)</span></span><br><span class="line">        <span class="comment">// 负 需要输入     正需要输出 </span></span><br><span class="line">        <span class="keyword">int</span> leftRest = leftSum - i * avg; <span class="comment">// a-b</span></span><br><span class="line">        <span class="comment">// 负 需要输入     正需要输出 </span></span><br><span class="line">        <span class="comment">// c - d</span></span><br><span class="line">        <span class="keyword">int</span> rightRest =  (sum - leftSum - arr[i]) -  (size - i - <span class="number">1</span>) * avg; </span><br><span class="line">        <span class="keyword">if</span> (leftRest &lt; <span class="number">0</span> &amp;&amp; rightRest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, Math.abs(leftRest) + Math.abs(rightRest));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.max(ans, Math.max(Math.abs(leftRest), Math.abs(rightRest)));</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。</span><br><span class="line"></span><br><span class="line">但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">找到数组中的最大值Max，然后看0和N-1哪个值比较小，Max - 那个较小的数就是答案</span><br><span class="line">因为Max最终肯定会划分在某个区间上，问题将转换成如何找到另一个不包含Max的区间的最小值</span><br><span class="line">由于区间一定会包含0或者N-1的值，那么就让0或者N-1变成这个区间的最大值，因为必定包含它这个值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxABS3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(arr[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - Math.min(arr[<span class="number">0</span>], arr[arr.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水</span><br><span class="line">比如，arr &#x3D; &#123;3，1，2，5，2，4&#125;，根据值画出的直方图就是容器形状，该容 器可以装下5格水</span><br><span class="line">再比如，arr &#x3D; &#123;4，5，1，3，2&#125;，该容器可以装下2格水</span><br><span class="line">例如：求水从天上落下来根据这些高度，它能盛多少格子水</span><br><span class="line">        |</span><br><span class="line">|水   水 |</span><br><span class="line">|   |   |</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：</span><br><span class="line">就看i位置，求i位置左max和右max，水能盛的高度绝对不会超过min(左max，右max) - arr[i]</span><br><span class="line">而且i位置过高，也无法盛水，所以是 i位置盛水的格子数 ：max(min(左max,右max) - i,0)</span><br><span class="line"></span><br><span class="line">求i左右两边的max：</span><br><span class="line">如[1,3,2,5,5,6,3]</span><br><span class="line">建立辅助数组L只增不降:[1,3,3,5,5,6,6]，这样能求出[0,i]位置上，最左边的max是多少</span><br><span class="line">反之，反过来从N-1开始遍历到0，能求出数组R，在[i,N-1]上的右边Max</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">不使用辅助数组，采用双指针操作</span><br><span class="line">例子：6 3 2 4 2 6 8</span><br><span class="line">已知i &#x3D; 0 和 i &#x3D; N - 1 势必是不能储存水量的，所以最左右两边必然为0</span><br><span class="line">采用双指针法，L &#x3D; 1,R &#x3D; N - 2开始</span><br><span class="line">若L左边的Max &lt; R右边的Max：</span><br><span class="line">  arr[L] &#x3D; 3,左Max &#x3D; 6,右Max &#x3D; 8</span><br><span class="line">  对于L位置来说，它最多储存 6-3 格水，L &#x3D; 1的位置答案 &#x3D; 3，L++</span><br><span class="line">若L左边的Max &gt; R右边的Max：</span><br><span class="line">  对于arr[R]位置来说，它左边有个大于右边Max的值，最多储存右Max - arr[R]格子， R++</span><br><span class="line">若L左边的Max &#x3D; R右边的Max：</span><br><span class="line">  可以直接结算两边的结果，因为都一样，L++,R++</span><br><span class="line"></span><br><span class="line">也就是说，左Max&lt;右Max，则结算R位置的结果，左Max&gt;右Max，则结算L位置的结果，若相等则都结算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">water4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> R = N - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMax = arr[N - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, leftMax - arr[L]);</span><br><span class="line">            leftMax = Math.max(leftMax, arr[L++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, rightMax - arr[R]);</span><br><span class="line">            rightMax = Math.max(rightMax, arr[R--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果给你一个二维数组，每一个值表示这一块地形的高度，</span><br><span class="line">求整块地形能装下多少水，类似于一块盆地，中间凹下去，积水,求积水量</span><br><span class="line">例子：</span><br><span class="line">9 9 9 4 9 9 9</span><br><span class="line">9 1 2 3 2 9 9</span><br><span class="line">9 2 3 5 9 3 9</span><br><span class="line">8 7 9 9 9 9 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">定义一个小根堆，存放arr[i][j]的值，并附带上i,j的位置信息</span><br><span class="line">定义一个boolean[][]数组，进入过小根堆的则标记成true</span><br><span class="line">定义一个Max变量，记录弹出过小根堆的最大值</span><br><span class="line"></span><br><span class="line">先将矩阵最外层一圈添加进小根堆，因为边缘是不会有积水的，并更新boolean[][]数组</span><br><span class="line">然后弹出小根堆的最小值V，从自然智慧来说，是从矩阵边缘最薄弱的地方下手，如上例子：V &#x3D; 4,Max &#x3D; 4</span><br><span class="line">弹出value，查看自身相邻的上下左右位置，添加没有进入过小根堆的点</span><br><span class="line">并结算处于value位置的储存水量：Max - value ，若大于0，则有水，若小于0，则0格水</span><br><span class="line">周而复始，把各个格子的水量累加起来就是总积水量</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line">通过边缘薄弱的地方切入，定义一个Max，其实是基于Max作为最大值，存在Max相连的一片湖</span><br><span class="line">如Max &#x3D; 4，则相连的湖：1,2,3,2,2,3，这些值都是基于Max做最大值来做结算，所以积水量是Max - value</span><br><span class="line">若Max的值发生了变化，则相当于寻找到另外一片湖进行计算</span><br><span class="line">当Max &#x3D; 5，势必来到了另一处薄弱点，但是上述例子中，5附近均没有未结算过的点，所以5的湖积水&#x3D; 0</span><br><span class="line"></span><br><span class="line">那个被4个9包围的3，一定会等到小根堆中的堆顶 &#x3D; 9时，弹出9，Max &#x3D; 9，才能够根据上下左右的原则添加进堆中</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">        row = r;</span><br><span class="line">        col = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightMap == <span class="keyword">null</span> || heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>] == <span class="keyword">null</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = heightMap.length;</span><br><span class="line">    <span class="keyword">int</span> M = heightMap[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// isEnter[i][j] == true  之前进过</span></span><br><span class="line">    <span class="comment">//  isEnter[i][j] == false 之前没进过</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] isEnter = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][M];</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> NodeComparator());</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//添加边缘的四条边的值到小根堆中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; M - <span class="number">1</span>; col++) &#123;</span><br><span class="line">        isEnter[<span class="number">0</span>][col] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[<span class="number">0</span>][col], <span class="number">0</span>, col));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; N - <span class="number">1</span>; row++) &#123;</span><br><span class="line">        isEnter[row][M - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[row][M - <span class="number">1</span>], row, M - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = M - <span class="number">1</span>; col &gt; <span class="number">0</span>; col--) &#123;</span><br><span class="line">        isEnter[N - <span class="number">1</span>][col] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[N - <span class="number">1</span>][col], N - <span class="number">1</span>, col));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = N - <span class="number">1</span>; row &gt; <span class="number">0</span>; row--) &#123;</span><br><span class="line">        isEnter[row][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[row][<span class="number">0</span>], row, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>; <span class="comment">// 每个位置的水量，累加到water上去</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">// 每个node在弹出的时候，如果value更大，更新max，否则max的值维持不变</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        Node cur = heap.poll();</span><br><span class="line">        max = Math.max(max, cur.value);</span><br><span class="line">        <span class="keyword">int</span> r = cur.row;</span><br><span class="line">        <span class="keyword">int</span> c = cur.col;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把四个边添加进堆中</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; !isEnter[r - <span class="number">1</span>][c]) &#123; <span class="comment">// 如果有上面的位置并且上面位置没进过堆</span></span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r - <span class="number">1</span>][c]);</span><br><span class="line">            isEnter[r - <span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r - <span class="number">1</span>][c], r - <span class="number">1</span>, c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; N - <span class="number">1</span> &amp;&amp; !isEnter[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r + <span class="number">1</span>][c]);</span><br><span class="line">            isEnter[r + <span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r + <span class="number">1</span>][c], r + <span class="number">1</span>, c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; !isEnter[r][c - <span class="number">1</span>]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r][c - <span class="number">1</span>]);</span><br><span class="line">            isEnter[r][c - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r][c - <span class="number">1</span>], r, c - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; M - <span class="number">1</span> &amp;&amp; !isEnter[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r][c + <span class="number">1</span>]);</span><br><span class="line">            isEnter[r][c + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r][c + <span class="number">1</span>], r, c + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个有序数组arr，给定一个正数aim</span><br><span class="line">1）返回累加和为aim的，所有不同二元组</span><br><span class="line">2）返回累加和为aim的，所有不同三元组</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题一思想：</span><br><span class="line">双指针，L&#x3D;0，R&#x3D;N-1，一起移动，一直到L&#x3D;&#x3D;R，跳出循环</span><br><span class="line">若arr[L] + arr[R] &gt; aim，则R--</span><br><span class="line">若arr[L] + arr[R] &lt; aim，则L++</span><br><span class="line">若arr[L] + arr[R] &#x3D; aim，若arr[L] !&#x3D; arr[L -1],收集答案，这里主要是为了防止收集重复答案，L++</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUniquePair</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] + arr[right] &lt; k) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] + arr[right] &gt; k) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// L   +   R   =   aim</span></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">0</span> || arr[left - <span class="number">1</span>] != arr[left]) &#123;</span><br><span class="line">                System.out.println(arr[left] + <span class="string">","</span> + arr[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题二思想：</span><br><span class="line">从左往右遍历，固定三元组中的一个值&#x3D;arr[i]，问题就演变成找到i的右边范围内的二元组值等于aim - arr[i]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUniqueTriad</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || arr[i] != arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            printRest(arr, i, i + <span class="number">1</span>, arr.length - <span class="number">1</span>, k - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRest</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> f, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] + arr[r] &lt; k) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] + arr[r] &gt; k) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == f + <span class="number">1</span> || arr[l - <span class="number">1</span>] != arr[l]) &#123;</span><br><span class="line">                System.out.println(arr[f] + <span class="string">","</span> + arr[l] + <span class="string">","</span> + arr[r]);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">长度为N的数组arr，一定可以组成N^2个数值对。</span><br><span class="line">例如arr &#x3D; [3,1,2]，</span><br><span class="line">数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，</span><br><span class="line">也就是任意两个数都有数值对，而且自己和自己也算数值对。</span><br><span class="line">数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为：</span><br><span class="line">(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)</span><br><span class="line"></span><br><span class="line">给定一个数组arr，和整数k，返回第k小的数值对。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">假设数组是有序的,每个index 能产生N个数值对，所以总数值对是N * N</span><br><span class="line">第一个数：通过(K - 1) &#x2F; N 定位，假设它等于F</span><br><span class="line">第二个数：假设小于F的数有A个，先减掉开头小于F的值 K - (A * N) &#x3D; S</span><br><span class="line">        然后假设等于F的有B个，那么以F开头，和i&#x3D;0能匹配出 F * B的结果，同理i&#x3D;1也有F*B个结果...</span><br><span class="line">所以问题又转换以F作为第一个数值的前提下：</span><br><span class="line">每个index 能产生 B个数值对，要找到第S小的数值对，所以第二个数 &#x3D; (S - 1) &#x2F; B</span><br><span class="line"></span><br><span class="line">排序数组O(N*logN)，求第一个数O(1)，求第二个数也是O(1)</span><br><span class="line">所以问题转换成排序上，这种求第K小的数，可以使用bfprt算法中的改写快排方法：O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">每种工作有难度和报酬，规定如下</span><br><span class="line">class Job &#123;</span><br><span class="line">public int money;&#x2F;&#x2F; 该工作的报酬</span><br><span class="line">public int hard; &#x2F;&#x2F; 该工作的难度</span><br><span class="line">&#125;</span><br><span class="line">给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作</span><br><span class="line">选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的岗位</span><br><span class="line">给定一个int类型的数组arr，表示所有人的能力</span><br><span class="line">返回int类型的数组，表示每个人按照标准选工作后所能获得的最高报酬</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">按工作难度从小到大排序,难度一样时钱数由大到小排序，丢弃难度相同报酬低的工作</span><br><span class="line">如果难度递增的时候，报酬没递增，也丢弃</span><br><span class="line">保证了剩下的序列一定是难度上升，报酬也上升的，单调性</span><br><span class="line">把剩下的加入有序表，一个对象有难度, 有钱数，有序表里根据难度排序</span><br><span class="line">接下来一个有能力的人在有序表里查离你的能力小于等于最近的项目，取出该项目, 获得这个钱, 一定是最值得的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">背包容量为w</span><br><span class="line">一共有n袋零食, 第i袋零食体积为v[i] </span><br><span class="line">总体积不超过背包容量的情况下，</span><br><span class="line">一共有多少种零食放法？(总体积为0也算一种放法)。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arr[0...]</span></span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左往右的经典模型</span></span><br><span class="line"><span class="comment">// 还剩的容量是rest，arr[index...]自由选择，</span></span><br><span class="line"><span class="comment">// 返回选择方案</span></span><br><span class="line"><span class="comment">// index ： 0～N</span></span><br><span class="line"><span class="comment">// rest : 0~w</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123; <span class="comment">// 没有容量了</span></span><br><span class="line">        <span class="comment">// -1 无方案的意思</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest&gt;=0,</span></span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 无零食可选</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index号零食，要 or 不要</span></span><br><span class="line">    <span class="comment">// index, rest</span></span><br><span class="line">    <span class="comment">// (index+1, rest)</span></span><br><span class="line">    <span class="comment">// (index+1, rest-arr[i])</span></span><br><span class="line">    <span class="keyword">int</span> next1 = process(arr, index + <span class="number">1</span>, rest); <span class="comment">// 不要</span></span><br><span class="line">    <span class="keyword">int</span> next2 = process(arr, index + <span class="number">1</span>, rest - arr[index]); <span class="comment">// 要</span></span><br><span class="line">    <span class="keyword">return</span> next1 + (next2 == -<span class="number">1</span> ? <span class="number">0</span> : next2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="comment">//i表示index，当前背包背的体积</span></span><br><span class="line"><span class="comment">//i行 j列 = arr[i-1][j] + arr[i][j - arr[i-1]]</span></span><br><span class="line"><span class="comment">//表示自己不背的答案 + 背的答案</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][w + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//j = 0,i = [0...N-1]范围上 背了0个零食的答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i = 0, j = [0..w]背了1号零食的答案</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + ((j - arr[i]) &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - arr[i]] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求二维数组中最后一行的累加答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; j++) &#123;</span><br><span class="line">        ans += dp[N - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间压缩"><a href="#空间压缩" class="headerlink" title="空间压缩"></a>空间压缩</h2><p><img src="/images/algorithm-all/alg-05.png" alt="algorithm"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">黄色：已知的点对应的值</span><br><span class="line">红色：答案所在的点</span><br><span class="line">假设arr[i][j]答案需要依赖 arr[i - 1][j] 和 arr[i][j - 1]</span><br><span class="line">那么根据已知的点，可以求出 arr[0][j]第一排的答案</span><br><span class="line"></span><br><span class="line">空间压缩：</span><br><span class="line">空间压缩是指将二维数组的空间压缩成一维数组的空间</span><br><span class="line">通过计算得到一行或者一列的结果，存放到一位数组中</span><br><span class="line">准备计算下一行或者下一列的结果时，通过值覆盖的方式，将答案填回一维数组</span><br><span class="line"></span><br><span class="line">若有arr[i][j]依赖了arr[i-1][j-1]的结果，可以通过使用一个临时变量存储arr[i-1][j-1]的结果。</span><br><span class="line"></span><br><span class="line">若有arr[i][j]依赖了之前几行的数据，可以申请几个一位数组，交替覆盖。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串str1和str2，求两个字符串的最长公共子串</span><br><span class="line">请注意区分子串和子序列的不同：</span><br><span class="line">子串表示连续的字符串,子序列可以不连续</span><br><span class="line"></span><br><span class="line">动态规划的空间压缩技巧！</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">简历动态规划的二维表</span><br><span class="line">行：[0...M-1] M是str1的长度</span><br><span class="line">列：[0...N-1] N是str2的长度</span><br><span class="line">值：arr[i][j] &#x3D; str1中必须以j位置结尾，且str2中必须以i位置结尾的最长公共子串长度</span><br><span class="line">所以两个最长公共子串就是二维表中的Max值</span><br><span class="line"></span><br><span class="line">arr[i][j] 依赖 str2[j] ?&#x3D; str1[i] 和arr[i-1][j-1]</span><br><span class="line">它只依赖二维表中的一个值，</span><br><span class="line">等同于起点位于右上角，然后一条从左往右的斜线一直在计算[i-1,j-1]、[i,j]、[i+1,j+1]的值</span><br><span class="line">也就是说，可以通过有限几个变量计算结果，而不需要申请二维表</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划 + 空间压缩！！！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lcst2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span> || str1.equals(<span class="string">""</span>) || str2.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>; <span class="comment">// 出发点的行号</span></span><br><span class="line">    <span class="keyword">int</span> col = chs2.length - <span class="number">1</span>; <span class="comment">// 出发点的列号</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//str1的最长子串的结束下标</span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//出发的起点在右上角</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt; chs1.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = row;</span><br><span class="line">        <span class="keyword">int</span> j = col;</span><br><span class="line">        <span class="comment">//缓存arr[i-1][j-1]的答案</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 向右下方移动的这一轮</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; chs1.length &amp;&amp; j &lt; chs2.length) &#123;</span><br><span class="line">            <span class="comment">//若不等，则为0</span></span><br><span class="line">            <span class="keyword">if</span> (chs1[i] != chs2[j]) &#123;</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若相等，则根据上一次求的答案arr[i][j] = arr[i-1][j-1] + 1 </span></span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若有长度超过Max，则更新，并记录str1的最长公共子串末尾下标</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往右下对角线移动</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行号--,一直往左移动，移动到不能往左了，就列号++,往下移动</span></span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公共子串末尾index - max + 1则是公共子串的开头第一个字符！截取返回</span></span><br><span class="line">    <span class="keyword">return</span> str1.substring(end - max + <span class="number">1</span>, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个由字符串组成的数组String[] strs，给定一个正数K</span><br><span class="line">返回词频最大的前K个字符串，假设结果是唯一的</span><br><span class="line">如：[&quot;abc&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;aaaa&quot;,&quot;ab&quot;,&quot;abc&quot;]   K&#x3D;2 -&gt; return &quot;abc&quot; 和 &quot;ab&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">用HashMap&lt;String,Integer&gt;统计每个字符串的词频，然后使用小根堆做资源限制条件</span><br><span class="line">维持小根堆的大小&#x3D;K ，把HashMap的数据添加到小根堆中</span><br><span class="line">堆顶就是门槛，当词频数大于堆顶，则弹出堆顶，并添加新对象，周而复始，小根堆留着的，肯定是词最大K个频数</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">统计词频后，可以用改进的快排，求出第K大的数，时间复杂度O(N)，用小根堆是O(N*logN)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        times = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.times - o2.times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTopKAndRank</span><span class="params">(String[] arr, <span class="keyword">int</span> topK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || topK &lt; <span class="number">1</span> || topK &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(str)) &#123;</span><br><span class="line">            map.put(str, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(str, map.get(str) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> NodeComparator());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(entry.getKey(), entry.getValue());</span><br><span class="line">        <span class="comment">//如果没满，加进去</span></span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; topK) &#123;</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//满了，判断堆顶和cur哪个大</span></span><br><span class="line">            <span class="keyword">if</span> (heap.peek().times &lt; cur.times) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        System.out.println(heap.poll().str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请实现如下结构：</span><br><span class="line">TopRecord&#123;</span><br><span class="line">public TopRecord(int K)  :  构造时事先指定好K的大小，构造后就固定不变了</span><br><span class="line">public  void add(String str)  :   向该结构中加入一个字符串，可以重复加入</span><br><span class="line">public  List&lt;String&gt; top() : 返回之前加入的所有字符串中，词频最大的K个</span><br><span class="line">&#125;</span><br><span class="line">要求： </span><br><span class="line">add方法，复杂度O(log K);</span><br><span class="line">top方法，复杂度O(K)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的堆结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] heap;</span><br><span class="line">    <span class="comment">//小根堆的大小下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="comment">// 字符串对应的词频</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Node&gt; strNodeMap;</span><br><span class="line">    <span class="comment">//小根堆上的节点所在的index位置</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; nodeIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopKRecord</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> Node[K];</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">        strNodeMap = <span class="keyword">new</span> HashMap&lt;String, Node&gt;();</span><br><span class="line">        nodeIndexMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str用户现在给我的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">如果str不在词频统计上，缓存词频统计，和小根堆堆顶比较</span></span><br><span class="line"><span class="comment">如果str在词频统计上，则词频数++，重新和小根堆堆顶比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Node curNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> preIndex = -<span class="number">1</span>; <span class="comment">// str之前在堆上的位置</span></span><br><span class="line">    <span class="comment">// 查词频表，看看有没有关于这个str的记录</span></span><br><span class="line">    <span class="keyword">if</span> (!strNodeMap.containsKey(str)) &#123; <span class="comment">// str之前没进来过</span></span><br><span class="line">        curNode = <span class="keyword">new</span> Node(str, <span class="number">1</span>);</span><br><span class="line">        strNodeMap.put(str, curNode);</span><br><span class="line">        nodeIndexMap.put(curNode, -<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// str之前进来过</span></span><br><span class="line">        curNode = strNodeMap.get(str);</span><br><span class="line">        curNode.times++;</span><br><span class="line">        <span class="comment">//获取字符串的index</span></span><br><span class="line">        preIndex = nodeIndexMap.get(curNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 词频表修改完毕，</span></span><br><span class="line">    <span class="keyword">if</span> (preIndex == -<span class="number">1</span>) &#123; <span class="comment">// 不在堆上</span></span><br><span class="line">        <span class="keyword">if</span> (heapSize == heap.length) &#123; <span class="comment">// 堆满了</span></span><br><span class="line">            <span class="comment">//如果堆顶的词频数比新的词频小</span></span><br><span class="line">            <span class="keyword">if</span> (heap[<span class="number">0</span>].times &lt; curNode.times) &#123;</span><br><span class="line">                <span class="comment">//交换存储的索引位置</span></span><br><span class="line">                nodeIndexMap.put(heap[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">                nodeIndexMap.put(curNode, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//重新设置堆顶heapify下沉</span></span><br><span class="line">                heap[<span class="number">0</span>] = curNode;</span><br><span class="line">                heapify(<span class="number">0</span>, heapSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 堆没有满</span></span><br><span class="line">            nodeIndexMap.put(curNode, heapSize);</span><br><span class="line">            heap[heapSize] = curNode;</span><br><span class="line">            <span class="comment">//尾部插入，heapInsert上浮</span></span><br><span class="line">            heapInsert(heapSize++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// str已经在堆上了</span></span><br><span class="line">        heapify(preIndex, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> smallest = index;</span><br><span class="line">    <span class="comment">//不能越界超过heapSize</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[l].times &lt; heap[index].times) &#123;</span><br><span class="line">            smallest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; heap[r].times &lt; heap[smallest].times) &#123;</span><br><span class="line">            smallest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">            swap(smallest, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = smallest;</span><br><span class="line">        l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    nodeIndexMap.put(heap[index1], index2);</span><br><span class="line">    nodeIndexMap.put(heap[index2], index1);</span><br><span class="line">    Node tmp = heap[index1];</span><br><span class="line">    heap[index1] = heap[index2];</span><br><span class="line">    heap[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串类型的数组arr，譬如:</span><br><span class="line">String[] arr &#x3D; &#123; &quot;b\st&quot;, &quot;d\&quot;, &quot;a\d\e&quot;, &quot;a\b\c&quot; &#125;; </span><br><span class="line">把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样:</span><br><span class="line">a</span><br><span class="line">  b</span><br><span class="line">    c</span><br><span class="line">  d</span><br><span class="line">    e</span><br><span class="line">b</span><br><span class="line">  st</span><br><span class="line">d</span><br><span class="line">同一级的需要按字母顺序排列不能乱。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">把路径变成前缀树形式，并且使用TreeMap排序前缀树，最后深度优先遍历输出，格子的数量：2 * (层数 - 1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上一个节点是通过哪条路，到我的</span></span><br><span class="line">    <span class="keyword">public</span> String path;</span><br><span class="line">    <span class="comment">// key : node下级的路   value：node在key这条路上对应的节点是什么</span></span><br><span class="line">    <span class="keyword">public</span> TreeMap&lt;String, Node&gt; nextMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = p;</span><br><span class="line">        nextMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// folderPaths -&gt;  [   "a\b\c","a\b\s" , "a\d\e" ,"e\f\sty"     ]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] folderPaths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folderPaths == <span class="keyword">null</span> || folderPaths.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据所有字符串，把前缀树建立好，头节点为head</span></span><br><span class="line">    Node head = generateFolderTree(folderPaths);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    printProcess(head, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateFolderTree</span><span class="params">(String[] folderPaths)</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="string">""</span>); <span class="comment">// 系统根目录, 前缀树头节点</span></span><br><span class="line">    <span class="keyword">for</span> (String foldPath : folderPaths) &#123; <span class="comment">// 拿出每一个绝对路径</span></span><br><span class="line">        String[] paths = foldPath.split(<span class="string">"\\\\"</span>); <span class="comment">// java 特性，用一个"\"做分割的意思</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123; <span class="comment">// "a"  , "b"   ,"c"</span></span><br><span class="line">            <span class="keyword">if</span> (!cur.nextMap.containsKey(paths[i])) &#123;</span><br><span class="line">                cur.nextMap.put(paths[i], <span class="keyword">new</span> Node(paths[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nextMap.get(paths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head节点，当前在level层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2 * (level - 1)</span></span><br><span class="line">        System.out.println(get4nSpace(level) + node.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node next : node.nextMap.values()) &#123;</span><br><span class="line">        printProcess(next, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get4nSpace</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += <span class="string">"    "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历 数组，返回后序遍历数组。</span><br><span class="line">比如给定:</span><br><span class="line">int[] pre &#x3D; &#123; 1, 2, 4, 5, 3, 6, 7 &#125;;</span><br><span class="line">int[] in &#x3D; &#123; 4, 2, 5, 1, 6, 3, 7 &#125;; </span><br><span class="line">返回:&#123;4,5,2,6,7,3,1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先序：头左右 </span><br><span class="line">中序：左头右 </span><br><span class="line">后序：左右头</span><br><span class="line"></span><br><span class="line">所以先序的第一个头位置，一定是后序的最后一个头位置</span><br><span class="line">然后去中序列表，寻找头的位置，中序左边的部分是左树L，右边的部分是右树R</span><br><span class="line">以先序的头index + 1则是左树开始的LL</span><br><span class="line">以LL + 中序算出来的左树长度 L ，这部分，就会放在后序的左部分</span><br><span class="line"></span><br><span class="line">递归计算每个树的位置放到后序数组中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] preInToPos2(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in) &#123;</span><br><span class="line">    <span class="comment">//若两段长度不同，则直接范围</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = pre.length;</span><br><span class="line">    <span class="comment">//先缓存中序中，每个数值对应的i位置，方便计算</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        inMap.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    process2(pre, <span class="number">0</span>, N - <span class="number">1</span>, in, <span class="number">0</span>, N - <span class="number">1</span>, pos, <span class="number">0</span>, N - <span class="number">1</span>, inMap);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">L1..R1 是pre数组范围</span></span><br><span class="line"><span class="comment">L2..R2 是in 数组范围</span></span><br><span class="line"><span class="comment">L3..R3 是pos数组范围</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2, <span class="keyword">int</span>[] pos, <span class="keyword">int</span> L3, <span class="keyword">int</span> R3,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HashMap&lt;Integer, Integer&gt; inMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个数，则直接设置</span></span><br><span class="line">    <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">        pos[L3] = pre[L1];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将先序的头L1位置 放到后序的末尾R3位置</span></span><br><span class="line">    pos[R3] = pre[L1];</span><br><span class="line">    <span class="comment">//查询头L1在中序中的index，将左右树根据这个中心头节点，划分成左右两块不同的区域</span></span><br><span class="line">    <span class="keyword">int</span> mid = inMap.get(pre[L1]);</span><br><span class="line">    <span class="comment">//该头节点的左树的长度等于 index - L2</span></span><br><span class="line">    <span class="keyword">int</span> leftSize = mid - L2;</span><br><span class="line">    <span class="comment">//递归计算左区域的结果</span></span><br><span class="line">    process2(pre, L1 + <span class="number">1</span>, L1 + leftSize, in, L2, mid - <span class="number">1</span>, pos, L3, L3 + leftSize - <span class="number">1</span>, inMap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归计算右区域的结果</span></span><br><span class="line">    process2(pre, L1 + leftSize + <span class="number">1</span>, R1, in, mid + <span class="number">1</span>, R2, pos, L3 + leftSize, R3 - <span class="number">1</span>, inMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最长递增子序列问题的O(N*logN)的解法</span><br><span class="line">最长递增子序列：&#123;3,1,4,2,3&#125; --&gt; &#123;1,2,3&#125;严格递增，不能相等</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">O(N^2) 解法：</span><br><span class="line">动态规划，一维数组dp，以每个i位置为下标，value存储以i位置结尾的最长递增子序列长度</span><br><span class="line">通过查看i位置左边比他小的值，取其中递增子序列的max最大值 + 1</span><br><span class="line"></span><br><span class="line">O(N * logN) 解法：</span><br><span class="line">增加一个ends数组，end[i]&#x3D;V，其中V表示arr数组中，最长递增子序列 &#x3D; i + 1 时的序列结尾的最小值</span><br><span class="line">当计算以i结尾的最长子序列长度时，通过二分找ends数组中，大于等于arr[i]的最左位置</span><br><span class="line">若无结果，则将arr[i]插入到ends中</span><br><span class="line">若有结果，假设其下标在ends数组中是k,则将ends[k]的值更新成arr[i]</span><br><span class="line">那么，dp[i]的值就是k + 1,有k + 1个最长子序列</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">     &#123;3,1,4,2,3,7...&#125; --&gt; &#123;1,2,3,7...&#125;</span><br><span class="line">dp:  &#123;1&#125; -&gt; &#123;1,1&#125; -&gt;&#123;1,1,2&#125; -&gt; &#123;1,1,2,2&#125; -&gt; &#123;1,1,2,2,3&#125; -&gt; ...</span><br><span class="line">ends:&#123;3&#125; -&gt; &#123;1&#125;   -&gt;&#123;1,4&#125;   -&gt; &#123;1,2&#125;     -&gt; &#123;1,2,3&#125;     -&gt; ...</span><br><span class="line"></span><br><span class="line">假设遍历了5次，i从0开始，这时候i &#x3D; 4，</span><br><span class="line">根据例子可以看到，ends[2] &#x3D; 3 &#x3D; arr[4], 最长递增子序列 dp[4] &#x3D; 2(ends的index) + 1 &#x3D; 3</span><br><span class="line">也就是代表着 从下标[0..4]内，在最长递增子序列的长度都 &#x3D; 3时的min(arr[i]) &#x3D; 3</span><br><span class="line">如&#123;1,2,3&#125;和&#123;1,2,7&#125;,长度为3的最长递增子序列的最小结尾 &#x3D; 3</span><br><span class="line"></span><br><span class="line">ends数组可以保证有序，因为当最长子序列长度相同时，min(arr[i])一定是相同的，只有长度增加时，它的值才会变化，而且当长度上升时，其对应的值必定 &gt; min(arr[i])</span><br><span class="line"></span><br><span class="line">遍历arr数组，时间复杂度O(N)， 遍历过程中计算dp数组采用了ends数组，ends长度为N</span><br><span class="line">ends数组中通过二分查找大于arr[i]中的最左位置 O(logN)</span><br><span class="line">所以整体的时间复杂度是O(N * logN)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N * logN)</span></span><br><span class="line"><span class="comment">//构建dp数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getdp2(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    ends[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">// 0....right   right往右无效</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//二分，找ends数组中，大于等于arr[i]的最左的位置</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若有效区没找到，需要扩充有效区，则l = right+1  right需要扩容更新值</span></span><br><span class="line">        <span class="comment">//若有效区找到了，则l &lt; right， right需要原值 </span></span><br><span class="line">        <span class="comment">//取两者的max</span></span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        <span class="comment">//更新ends的值，把大于等于arr[i]的最左的位置更新成arr[i]</span></span><br><span class="line">        ends[l] = arr[i];</span><br><span class="line">        <span class="comment">//赋值dp值</span></span><br><span class="line">        dp[i] = l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个信封都有长和宽两个维度的数据，A信封如果想套在B信封里面，A信封必须在长和宽上都小于B信封才行。</span><br><span class="line">如果给你一批信封，返回最大的嵌套层数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先排序第一维数据(长度)由小到大，如果第一维一样, 第二维数据(宽度)由大到小</span><br><span class="line">第二维度数据单独拎出来, 它的最长递增子序列就是套的层数</span><br><span class="line">因为长度已经先排好序了，若宽度也按照递增子序列递增，那么保证了长也递增，宽也递增，那么答案就出来了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Envelope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Envelope</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">        l = weight;</span><br><span class="line">        h = hight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvelopeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Envelope</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Envelope o1, Envelope o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Envelope[] getSortedEnvelopes(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    Envelope[] res = <span class="keyword">new</span> Envelope[matrix.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        res[i] = <span class="keyword">new</span> Envelope(matrix[i][<span class="number">0</span>], matrix[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(res, <span class="keyword">new</span> EnvelopeComparator());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    Envelope[] envelopes = getSortedEnvelopes(matrix);</span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">    ends[<span class="number">0</span>] = envelopes[<span class="number">0</span>].h;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[i].h &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        ends[l] = envelopes[i].h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年12月26日 21:31</p>
        <p>原始链接： <a class="post-url" href="/2020/10/31/algorithm-trainingcamp3/" title="&#39;数据结构与算法 训练营三期&#39;">https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&title=《'数据结构与算法 训练营三期'》 — Kuro's Blog&pic=images/algorithm.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&title=《'数据结构与算法 训练营三期'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'数据结构与算法 训练营三期'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/algorithm/" class="color5">algorithm</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#训练营三期"><span class="post-toc-text">训练营三期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#滑动窗口"><span class="post-toc-text">滑动窗口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#括号四连"><span class="post-toc-text">括号四连</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#辅助数组"><span class="post-toc-text">辅助数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单调性"><span class="post-toc-text">单调性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#空间压缩"><span class="post-toc-text">空间压缩</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/11/09/mybatis-config/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;Mybatis的介绍和基本使用&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/10/30/algorithm-trainingcamp2/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;数据结构与算法 训练营二期&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="algorithm-trainingcamp3" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Elasticsearch/">Elasticsearch</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/MYSQL/">MYSQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/algorithm/">algorithm</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16.36px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 11.82px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19.09px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 12.73px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17.27px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 10.91px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 12.73px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 10.91px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 13.64px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 11.82px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 11.82px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 12.73px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10.91px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15.45px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 11.82px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 14.55px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.64px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18.18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 12.73px;">Thread</a> <a href="/tags/algorithm/" style="font-size: 12.73px;">algorithm</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16.36px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 11.82px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19.09px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 12.73px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17.27px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 10.91px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 12.73px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 10.91px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 13.64px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 11.82px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 11.82px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 12.73px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10.91px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15.45px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 11.82px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 14.55px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.64px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18.18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 12.73px;">Thread</a> <a href="/tags/algorithm/" style="font-size: 12.73px;">algorithm</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>