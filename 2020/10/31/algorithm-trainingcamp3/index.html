<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;数据结构与算法 训练营三期&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="训练营三期滑动窗口123给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点绳子的边缘点碰到X轴上的点，也算盖住  123456789解法一：假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找每个下标都需要查找一次&amp;gt">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;数据结构与算法 训练营三期&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="训练营三期滑动窗口123给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点绳子的边缘点碰到X轴上的点，也算盖住  123456789解法一：假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找每个下标都需要查找一次&amp;gt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://midkuro.gitee.io/images/algorithm-all/alg-05.png">
<meta property="article:published_time" content="2020-10-31T15:33:00.000Z">
<meta property="article:modified_time" content="2021-02-03T09:23:52.231Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://midkuro.gitee.io/images/algorithm-all/alg-05.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?code-JRipY21QjX";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-algorithm-trainingcamp3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;数据结构与算法 训练营三期&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/algorithm/">algorithm</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-10-31
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="训练营三期"><a href="#训练营三期" class="headerlink" title="训练营三期"></a>训练营三期</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置</span><br><span class="line">给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点</span><br><span class="line">绳子的边缘点碰到X轴上的点，也算盖住</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解法一：</span><br><span class="line">假设以i为结尾，K的绳子盖住的点范围是：[i-k,i]，查询落在这个范围上的点有多少个</span><br><span class="line">等同于查询[0..i-1]的范围上，有多少个数大于i-k，使用二分查找</span><br><span class="line">每个下标都需要查找一次&gt;i-k的位置,时间复杂度O(logN)，有N个点，则总体的时间O(N * logN)</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">采用滑动窗口，LR一开始处于-1位置，R向右滑，滑到arr[R + 1] - arr[L] &gt; K时停止，该答案是index &#x3D; L答案</span><br><span class="line">然后L++,再次判断 arr[R + 1] - arr[L] ?&lt; K,若小于，则R++窗口继续滑动，周而复始</span><br><span class="line">时间复杂度O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nearest = nearestIndex(arr, i, arr[i] - L);</span><br><span class="line">        res = Math.max(res, i - nearest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = R;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口滑动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoint2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; N) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; N &amp;&amp; arr[right] - arr[left] &lt;= L) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, right - (left++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号四连"><a href="#括号四连" class="headerlink" title="括号四连"></a>括号四连</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">括号有效配对是指：</span><br><span class="line">1）任何一个左括号都能找到和其正确配对的右括号</span><br><span class="line">2）任何一个右括号都能找到和其正确配对的左括号</span><br><span class="line">有效的：    (())  ()()   (()())  等</span><br><span class="line">无效的：     (()   )(     等</span><br><span class="line">问题一：怎么判断一个括号字符串有效？</span><br><span class="line">问题二：如果一个括号字符串无效，返回至少填几个字符能让其整体有效</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题一解法一：</span><br><span class="line">把&#39;(&#39;压栈，遇到&#39;)&#39;则弹出，当还有&#39;)&#39;且栈为空，或者遍历结束时栈不为空，返回false，其余返回true</span><br><span class="line">问题一解法二：</span><br><span class="line">使用一个Count计数，遇到&#39;(&#39;则++，遇到&#39;)&#39;则--，当count &lt; 0 或者遍历结束后count !&#x3D; 0 ,返回false</span><br><span class="line"></span><br><span class="line">问题二思路：</span><br><span class="line">基于问题一解法二的基础知识下，再开一个need计数，当count &lt; 0,则need++,遍历结束后,结果：need + count</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        count += str[i] == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题二解法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">needParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 遇到的是')'</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                need++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">括号有效配对是指：</span><br><span class="line">1）任何一个左括号都能找到和其正确配对的右括号</span><br><span class="line">2）任何一个右括号都能找到和其正确配对的左括号</span><br><span class="line">返回一个括号字符串中，最长的括号有效子串的长度</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">遇到这种子串的题目，优先思考以[i]开头，答案是什么...或者以[i]结尾，答案是什么...</span><br><span class="line">如：   ( ) ( ) ( ( ) ) ( )</span><br><span class="line">index:0 1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">如果 arr[i] &#x3D; &#39;(&#39; 以左括号结尾，无效，res[i] &#x3D; 0,</span><br><span class="line">如果 arr[i] &#x3D; &#39;)&#39;获取res[i - 1] &#x3D; k,判断 arr[i - k - 1] ?&#x3D; &#39;(&#39;，若不是，则res[i]&#x3D;0</span><br><span class="line">若是，则res[i]&#x3D;k + 2 , 则至少确定了以arr[i - k - 1, i]是一个正确配对的答案</span><br><span class="line">若再往前推，arr[i - k - 2] !&#x3D; 0,表示它前面还有能够拼接的正确括号,res[i] +&#x3D; arr[i - k - 2]</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">第i个位置，看i-1的答案和符号，匹配成功后，再往前跳一步看看是否还有正确的答案</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[0] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            pre = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>; <span class="comment">// 与str[i]配对的左括号的位置 pre</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span> &amp;&amp; str[pre] == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + (pre &gt; <span class="number">0</span> ? dp[pre - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给一个正确的括号字符：((()))()(())() ,判断该字符中括号最大嵌套了几层？</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line">弄个count计数，遇到&#39;(&#39;，count++，遇到&#39;)&#39;，count--，嵌套的层数就是count的最大值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(str)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">            max = Math.max(max, ++count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="辅助数组"><a href="#辅助数组" class="headerlink" title="辅助数组"></a>辅助数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。</span><br><span class="line">现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将 会被覆盖。</span><br><span class="line">目标是在完成染色之后,每个红色R都比每个绿色G距离最左侧近。 返回最少需要涂染几个正方形。</span><br><span class="line">如样例所示: s &#x3D; RGRGR 我们涂染之后变成RRRGG满足要求了,涂染的个数为2,没有比这个更好的涂染方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">以每个index为分界线，左边涂R，右边涂G，分成两个数组，问题转换成左边数组中G出现的次数，右边R出现的次数</span><br><span class="line">可以增加辅助数组X加速：缓存[i,N-1]上，R出现的次数</span><br><span class="line">而辅助数组Y:[0,N-1]上，G出现的次数，这个信息可以从左往右遍历的时候通过一个信息left记录G出现的次数</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">辅助数组X也可以省略掉，先获取数组中R出现的总次数rAll</span><br><span class="line">在从左往右遍历的过程中，i遇到字符&#39;R&#39;，则rAll--，这时候rAll &#x3D; [i + 1, N - 1]区间上R出现的次数</span><br><span class="line">最后每个分界线的答案 &#x3D; rAll + left</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGRGR -&gt; RRRGG</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPaint</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="comment">//数组中R出现的总次数rAll</span></span><br><span class="line">    <span class="keyword">int</span> rAll = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        rAll += str[i] == <span class="string">'R'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单独先把R的数量赋值给ans，</span></span><br><span class="line">    <span class="comment">//因为边界线可能出现在 index = 0的左边，或者N-1 的右边，也就是全G或者全R的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans = rAll; <span class="comment">// 如果数组所有的范围，都是右侧范围，都变成G</span></span><br><span class="line">    <span class="comment">//[0,i]上，G出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123; <span class="comment">// 0..i 左侧 n-1..N-1</span></span><br><span class="line">        left += str[i] == <span class="string">'G'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        rAll -= str[i] == <span class="string">'R'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        ans = Math.min(ans, left + rAll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0...N-1 左全部 右无</span></span><br><span class="line">    ans = Math.min(ans, left + (str[N - <span class="number">1</span>] == <span class="string">'G'</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度。</span><br><span class="line">例如:</span><br><span class="line">01111</span><br><span class="line">01001</span><br><span class="line">01001</span><br><span class="line">01111</span><br><span class="line">01011 </span><br><span class="line">其中边框全是1的最大正方形的大小为4*4，所以返回4。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">总流程的时间复杂度一定是O(N^3),因为你任意一个正方形的左上角点，就是O(N^2)，然后还要根据边长&#x3D;1&#x3D;2&#x3D;..N一直扩下去，所以是O(N^2 * N) &#x3D; O(N^3)</span><br><span class="line">也就是说大流程是</span><br><span class="line">for() &#123; &#x2F;&#x2F;限定边长</span><br><span class="line">  for() &#123; &#x2F;&#x2F;遍历i</span><br><span class="line">    for()&#123; &#x2F;&#x2F;遍历j</span><br><span class="line">       &#x2F;&#x2F;验证边长是否是1，达到正方形 : 只有这一环节是有优化空间的</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过创建辅助数组，遍历两次数组得到,每个点往右有几个1的二维数组,往下有几个点的二维数组</span><br><span class="line">时间复杂度2 * O(N^2)</span><br><span class="line">而上面验证长方形可以通过这个辅助数组快速验证O(1)</span><br><span class="line">在总次数是O(N^3)面前，有多少个O(N^2)都是被忽略的，所以总代价还是O(N^3)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算right down数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBorderMap</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = m.length;</span><br><span class="line">    <span class="keyword">int</span> c = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m[r - <span class="number">1</span>][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        right[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        down[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[i][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            down[i][c - <span class="number">1</span>] = down[i + <span class="number">1</span>][c - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = c - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[r - <span class="number">1</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[r - <span class="number">1</span>][i] = right[r - <span class="number">1</span>][i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            down[r - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c - <span class="number">2</span>; j != -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i][j] = down[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义边长，三个循环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    setBorderMap(m, right, down); <span class="comment">// O(N^2); + </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = Math.min(m.length, m[<span class="number">0</span>].length); size != <span class="number">0</span>; size--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSizeOfBorder(size, right, down)) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSizeOfBorder</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != right.length - size + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != right[<span class="number">0</span>].length - size + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[i][j] &gt;= size &amp;&amp; down[i][j] &gt;= size</span><br><span class="line">                &amp;&amp; right[i + size - <span class="number">1</span>][j] &gt;= size</span><br><span class="line">                &amp;&amp; down[i][j + size - <span class="number">1</span>] &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数M，请构造出一个长度为M的数组arr，要求</span><br><span class="line">对任意的i、j、k三个位置，如果i&lt;j&lt;k，都有arr[i] + arr[k] !&#x3D; 2*arr[j]</span><br><span class="line">返回构造出的arr</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">数组长长度小于3，都达标</span><br><span class="line">把数组划分成左右两部分，挑选三个奇数不满足a + c !&#x3D; 2b，则(2a-1) + (2c-1) !&#x3D; 2b-1，成倍扩张</span><br><span class="line">偶数也是同理， a + c !&#x3D; 2b，则2a + 2c !&#x3D; 4b</span><br><span class="line">将M长度划分成 (M+1)&#x2F;2的两份数组，左边奇数右边偶数，任意三个基数、三个偶数或者基偶结合，都达标</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成长度为size的达标数组</span></span><br><span class="line"><span class="comment">// 达标：对于任意的 i&lt;k&lt;j，满足   [i] + [j]  != [k] * 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeNo(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// size</span></span><br><span class="line">    <span class="comment">// 一半长达标来</span></span><br><span class="line">    <span class="comment">// 7   :   4</span></span><br><span class="line">    <span class="comment">// 8   :   4</span></span><br><span class="line">    <span class="comment">// [4个奇数] [3个偶]</span></span><br><span class="line">    <span class="keyword">int</span> halfSize = (size + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] base = makeNo(halfSize);</span><br><span class="line">    <span class="comment">// base -&gt; 等长奇数达标来</span></span><br><span class="line">    <span class="comment">// base -&gt; 等长偶数达标来</span></span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; halfSize;index++) &#123;</span><br><span class="line">        ans[index] = base[index] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;index &lt; size;index++,i++) &#123;</span><br><span class="line">        ans[index] = base[i] * <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树的头节点head，路径的规定有以下三种不同的规定：</span><br><span class="line"></span><br><span class="line">1）路径必须是头节点出发，到叶节点为止，返回最大路径和</span><br><span class="line">2）路径可以从任何节点出发，但必须往下走到达任何节点，返回最大路径和</span><br><span class="line">3）路径可以从任何节点出发，到任何节点，返回最大路径和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题1：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDis</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process2(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x为头的整棵树上，最大路径和是多少，返回。</span></span><br><span class="line"><span class="comment">// 路径要求，一定从x出发，到叶节点，算做一个路径</span></span><br><span class="line"><span class="comment">//叶子节点做baseCase，因为null节点返回0可能会干扰答案</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> next = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = process2(x.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = Math.max(next, process2(x.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.value + next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二问思路：</span><br><span class="line">二叉树的递归套路</span><br><span class="line">1.与X有关</span><br><span class="line">2.与X无关</span><br><span class="line"></span><br><span class="line">与X有关需要左右数提供什么信息，与X无关需要左右树提供什么信息？</span><br><span class="line">有关：以左&#x2F;右树开头的整数最大和   无关：左&#x2F;右树的整树最大和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> allTreeMaxSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fromHeadMaxSum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> all, <span class="keyword">int</span> from)</span> </span>&#123;</span><br><span class="line">        allTreeMaxSum = all;</span><br><span class="line">        fromHeadMaxSum = from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）X无关的时候， 1， 左树上的整体最大路径和 2， 右树上的整体最大路径和</span></span><br><span class="line"><span class="comment">// 2) X有关的时候 3， x自己 4， x往左走 5，x往右走</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">f2</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = f2(x.left);</span><br><span class="line">    Info rightInfo = f2(x.right);</span><br><span class="line">    <span class="keyword">int</span> p1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = leftInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p2 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = rightInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p3 = x.value;</span><br><span class="line">    <span class="keyword">int</span> p4 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p4 = x.value + leftInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p5 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p5 = x.value + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> allTreeMaxSum = Math.max(Math.max(Math.max(p1, p2), p3), Math.max(p4, p5));</span><br><span class="line">    <span class="keyword">int</span> fromHeadMaxSum = Math.max(Math.max(p3, p4), p5);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(allTreeMaxSum, fromHeadMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三问：</span></span><br><span class="line"><span class="comment">// 1）X无关的时候， 1， 左树上的整体最大路径和 2， 右树上的整体最大路径和</span></span><br><span class="line"><span class="comment">// 2) X有关的时候 3， x自己 4， x往左走 5，x往右走 6, 既往左，又往右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">f3</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = f3(x.left);</span><br><span class="line">    Info rightInfo = f3(x.right);</span><br><span class="line">    <span class="keyword">int</span> p1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = leftInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p2 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p2 = rightInfo.allTreeMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p3 = x.value;</span><br><span class="line">    <span class="keyword">int</span> p4 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p4 = x.value + leftInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p5 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p5 = x.value + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p6 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p6 = x.value + leftInfo.fromHeadMaxSum + rightInfo.fromHeadMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> allTreeMaxSum = Math.max(Math.max(Math.max(p1, p2), p3), Math.max(Math.max(p4, p5), p6));</span><br><span class="line">    <span class="keyword">int</span> fromHeadMaxSum = Math.max(Math.max(p3, p4), p5);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(allTreeMaxSum, fromHeadMaxSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在行也有序、列也有序的二维数组中，找num，找到返回true，否则false</span><br><span class="line"></span><br><span class="line">思想：</span><br><span class="line">从右上角（或者左下角）开始走，匹配num，往左走遇到对不上了，就往下走，重复之前的操作</span><br><span class="line">如：</span><br><span class="line">1 2 3   13  16  20    </span><br><span class="line">2 3 4   14  17  21</span><br><span class="line">3 4 15  17  18  22</span><br><span class="line"></span><br><span class="line">找到15的位置: 20-&gt;16-&gt;17-&gt;18-&gt;17-&gt;15</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContains</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == K) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; K) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有n个打包机器从左到右一字排开，上方有一个自动装置会抓取一批放物品到每个打包机上</span><br><span class="line">放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。</span><br><span class="line">每个物品重量太大、 每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。</span><br><span class="line">请计算在搬动最 小轮数的前提下，使每个机器上的物品数量相等。</span><br><span class="line">如果不能使每个机器上的物品相同， 返回-1。 </span><br><span class="line">例如[1,0,5]表示有3个机器，每个机器上分别有1、0、5个物品</span><br><span class="line">经过这些轮后: </span><br><span class="line">第一轮:1    0 &lt;- 5 &#x3D;&gt; 1 1 4</span><br><span class="line">第二轮:1 &lt;- 1 &lt;- 4 &#x3D;&gt; 2 1 3</span><br><span class="line">第三轮:2    1 &lt;- 3 &#x3D;&gt; 2 2 2 </span><br><span class="line">移动了3轮，每个机器上的物品相等，所以返回3</span><br><span class="line">例如[2,2,3]表示有3个机器，每个机器上分别有2、2、3个物品，</span><br><span class="line">这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">机器物品数量总和 %N !&#x3D; 0,必定 -1 无解</span><br><span class="line">转换成以某个index做下标，划分成index左边和右边两块区域</span><br><span class="line">Lsum &#x3D; 左边的机器总包裹数 - 左边所需的总包裹数 ?&gt; 0 ，表示左边的机器数量过多，同理右边也是</span><br><span class="line">若左右两边Lsum和Rsum均小于0，则表示index下标的机器必定有多余包裹，则移动次数 &#x3D; abs(Lsum) + abs(Rsum)</span><br><span class="line">其他情况均是max(abs(Lsum), abs(Rsum))</span><br><span class="line"></span><br><span class="line">最后演变成以i结尾，求左边的累加和，右边的累加和，做计算</span><br><span class="line">先遍历得到总物品数sum，每次遍历i进行左边累加和计算，右边累加和通过sum - 左边累加和得到</span><br><span class="line">整体时间复杂度O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MinOps</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> avg = sum / size;</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每个位置都求各自的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// i号机器，是中间机器，左(0~i-1) i 右(i+1~N-1)</span></span><br><span class="line">        <span class="comment">// 负 需要输入     正需要输出 </span></span><br><span class="line">        <span class="keyword">int</span> leftRest = leftSum - i * avg; <span class="comment">// a-b</span></span><br><span class="line">        <span class="comment">// 负 需要输入     正需要输出 </span></span><br><span class="line">        <span class="comment">// c - d</span></span><br><span class="line">        <span class="keyword">int</span> rightRest =  (sum - leftSum - arr[i]) -  (size - i - <span class="number">1</span>) * avg; </span><br><span class="line">        <span class="keyword">if</span> (leftRest &lt; <span class="number">0</span> &amp;&amp; rightRest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, Math.abs(leftRest) + Math.abs(rightRest));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = Math.max(ans, Math.max(Math.abs(leftRest), Math.abs(rightRest)));</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的 作为右部分。</span><br><span class="line"></span><br><span class="line">但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的， 左部分最大值减去右部分最大值的绝对值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">找到数组中的最大值Max，然后看0和N-1哪个值比较小，Max - 那个较小的数就是答案</span><br><span class="line">因为Max最终肯定会划分在某个区间上，问题将转换成如何找到另一个不包含Max的区间内的最大值（但实际上需要尽量让这个值越小越好）</span><br><span class="line">由于区间一定会包含0或者N-1的值，那么就让0或者N-1变成这个区间的最大值，因为必定包含它这个值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxABS3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(arr[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - Math.min(arr[<span class="number">0</span>], arr[arr.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器， 请返回容器能装多少水</span><br><span class="line">比如，arr &#x3D; &#123;3，1，2，5，2，4&#125;，根据值画出的直方图就是容器形状，该容 器可以装下5格水</span><br><span class="line">再比如，arr &#x3D; &#123;4，5，1，3，2&#125;，该容器可以装下2格水</span><br><span class="line">例如：求水从天上落下来根据这些高度，它能盛多少格子水</span><br><span class="line">        |</span><br><span class="line">|水   水 |</span><br><span class="line">|   |   |</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：</span><br><span class="line">就看i位置，求i位置左max和右max，水能盛的高度绝对不会超过min(左max，右max) - arr[i]</span><br><span class="line">而且i位置过高，也无法盛水，所以是 i位置盛水的格子数 ：max(min(左max,右max) - i,0)</span><br><span class="line"></span><br><span class="line">求i左右两边的max：</span><br><span class="line">如[1,3,2,5,5,6,3]</span><br><span class="line">建立辅助数组L只增不降:[1,3,3,5,5,6,6]，这样能求出[0,i]位置上，最左边的max是多少</span><br><span class="line">反之，反过来从N-1开始遍历到0，能求出数组R，在[i,N-1]上的右边Max</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">不使用辅助数组，采用双指针操作</span><br><span class="line">例子：6 3 2 4 2 6 8</span><br><span class="line">已知i &#x3D; 0 和 i &#x3D; N - 1 势必是不能储存水量的，所以最左右两边必然为0</span><br><span class="line">采用双指针法，L &#x3D; 1,R &#x3D; N - 2开始</span><br><span class="line">若L左边的Max &lt; R右边的Max：</span><br><span class="line">  arr[L] &#x3D; 3,左Max &#x3D; 6,右Max &#x3D; 8</span><br><span class="line">  对于L位置来说，它最多储存 6-3 格水，L &#x3D; 1的位置答案 &#x3D; 3，L++</span><br><span class="line">若L左边的Max &gt; R右边的Max：</span><br><span class="line">  对于arr[R]位置来说，它左边有个大于右边Max的值，最多储存右Max - arr[R]格子， R++</span><br><span class="line">若L左边的Max &#x3D; R右边的Max：</span><br><span class="line">  可以直接结算两边的结果，因为都一样，L++,R++</span><br><span class="line"></span><br><span class="line">也就是说，左Max&lt;右Max，则结算R位置的结果，左Max&gt;右Max，则结算L位置的结果，若相等则都结算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">water4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> R = N - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> rightMax = arr[N - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt;= rightMax) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, leftMax - arr[L]);</span><br><span class="line">            leftMax = Math.max(leftMax, arr[L++]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, rightMax - arr[R]);</span><br><span class="line">            rightMax = Math.max(rightMax, arr[R--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果给你一个二维数组，每一个值表示这一块地形的高度，</span><br><span class="line">求整块地形能装下多少水，类似于一块盆地，中间凹下去，积水,求积水量</span><br><span class="line">例子：</span><br><span class="line">9 9 9 4 9 9 9</span><br><span class="line">9 1 2 3 2 9 9</span><br><span class="line">9 2 3 5 9 3 9</span><br><span class="line">8 7 9 9 9 9 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">定义一个小根堆，存放arr[i][j]的值，并附带上i,j的位置信息</span><br><span class="line">定义一个boolean[][]数组，进入过小根堆的则标记成true</span><br><span class="line">定义一个Max变量，记录弹出过小根堆的最大值</span><br><span class="line"></span><br><span class="line">先将矩阵最外层一圈添加进小根堆，因为边缘是不会有积水的，并更新boolean[][]数组</span><br><span class="line">然后弹出小根堆的最小值V，从自然智慧来说，是从矩阵边缘最薄弱的地方下手，如上例子：V &#x3D; 4,Max &#x3D; 4</span><br><span class="line">弹出value，查看自身相邻的上下左右位置，添加没有进入过小根堆的点</span><br><span class="line">并结算处于value位置的储存水量：Max - value ，若大于0，则有水，若小于0，则0格水</span><br><span class="line">周而复始，把各个格子的水量累加起来就是总积水量</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line">通过边缘薄弱的地方切入，定义一个Max，其实是基于Max作为最大值，存在Max相连的一片湖</span><br><span class="line">如Max &#x3D; 4，则相连的湖：1,2,3,2,2,3，这些值都是基于Max做最大值来做结算，所以积水量是Max - value</span><br><span class="line">若Max的值发生了变化，则相当于寻找到另外一片湖进行计算</span><br><span class="line">当Max &#x3D; 5，势必来到了另一处薄弱点，但是上述例子中，5附近均没有未结算过的点，所以5的湖积水&#x3D; 0</span><br><span class="line"></span><br><span class="line">那个被4个9包围的3，一定会等到小根堆中的堆顶 &#x3D; 9时，弹出9，Max &#x3D; 9，才能够根据上下左右的原则添加进堆中</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">        row = r;</span><br><span class="line">        col = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.value - o2.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">trapRainWater</span><span class="params">(<span class="keyword">int</span>[][] heightMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightMap == <span class="keyword">null</span> || heightMap.length == <span class="number">0</span> || heightMap[<span class="number">0</span>] == <span class="keyword">null</span> || heightMap[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = heightMap.length;</span><br><span class="line">    <span class="keyword">int</span> M = heightMap[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// isEnter[i][j] == true  之前进过</span></span><br><span class="line">    <span class="comment">//  isEnter[i][j] == false 之前没进过</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] isEnter = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][M];</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> NodeComparator());</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//添加边缘的四条边的值到小根堆中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; M - <span class="number">1</span>; col++) &#123;</span><br><span class="line">        isEnter[<span class="number">0</span>][col] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[<span class="number">0</span>][col], <span class="number">0</span>, col));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; N - <span class="number">1</span>; row++) &#123;</span><br><span class="line">        isEnter[row][M - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[row][M - <span class="number">1</span>], row, M - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = M - <span class="number">1</span>; col &gt; <span class="number">0</span>; col--) &#123;</span><br><span class="line">        isEnter[N - <span class="number">1</span>][col] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[N - <span class="number">1</span>][col], N - <span class="number">1</span>, col));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = N - <span class="number">1</span>; row &gt; <span class="number">0</span>; row--) &#123;</span><br><span class="line">        isEnter[row][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        heap.add(<span class="keyword">new</span> Node(heightMap[row][<span class="number">0</span>], row, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>; <span class="comment">// 每个位置的水量，累加到water上去</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">// 每个node在弹出的时候，如果value更大，更新max，否则max的值维持不变</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        Node cur = heap.poll();</span><br><span class="line">        max = Math.max(max, cur.value);</span><br><span class="line">        <span class="keyword">int</span> r = cur.row;</span><br><span class="line">        <span class="keyword">int</span> c = cur.col;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把四个边添加进堆中</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; !isEnter[r - <span class="number">1</span>][c]) &#123; <span class="comment">// 如果有上面的位置并且上面位置没进过堆</span></span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r - <span class="number">1</span>][c]);</span><br><span class="line">            isEnter[r - <span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r - <span class="number">1</span>][c], r - <span class="number">1</span>, c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; N - <span class="number">1</span> &amp;&amp; !isEnter[r + <span class="number">1</span>][c]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r + <span class="number">1</span>][c]);</span><br><span class="line">            isEnter[r + <span class="number">1</span>][c] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r + <span class="number">1</span>][c], r + <span class="number">1</span>, c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span> &amp;&amp; !isEnter[r][c - <span class="number">1</span>]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r][c - <span class="number">1</span>]);</span><br><span class="line">            isEnter[r][c - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r][c - <span class="number">1</span>], r, c - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; M - <span class="number">1</span> &amp;&amp; !isEnter[r][c + <span class="number">1</span>]) &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, max - heightMap[r][c + <span class="number">1</span>]);</span><br><span class="line">            isEnter[r][c + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Node(heightMap[r][c + <span class="number">1</span>], r, c + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个有序数组arr，给定一个正数aim</span><br><span class="line">1）返回累加和为aim的，所有不同二元组</span><br><span class="line">2）返回累加和为aim的，所有不同三元组</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">问题一思想：</span><br><span class="line">双指针，L&#x3D;0，R&#x3D;N-1，一起移动，一直到L&#x3D;&#x3D;R，跳出循环</span><br><span class="line">若arr[L] + arr[R] &gt; aim，则R--</span><br><span class="line">若arr[L] + arr[R] &lt; aim，则L++</span><br><span class="line">若arr[L] + arr[R] &#x3D; aim，若arr[L] !&#x3D; arr[L -1],收集答案，这里主要是为了防止收集重复答案，L++</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUniquePair</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[left] + arr[right] &lt; k) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left] + arr[right] &gt; k) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// L   +   R   =   aim</span></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="number">0</span> || arr[left - <span class="number">1</span>] != arr[left]) &#123;</span><br><span class="line">                System.out.println(arr[left] + <span class="string">","</span> + arr[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题二思想：</span><br><span class="line">从左往右遍历，固定三元组中的一个值&#x3D;arr[i]，问题就演变成找到i的右边范围内的二元组值等于aim - arr[i]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUniqueTriad</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || arr[i] != arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            printRest(arr, i, i + <span class="number">1</span>, arr.length - <span class="number">1</span>, k - arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRest</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> f, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] + arr[r] &lt; k) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] + arr[r] &gt; k) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == f + <span class="number">1</span> || arr[l - <span class="number">1</span>] != arr[l]) &#123;</span><br><span class="line">                System.out.println(arr[f] + <span class="string">","</span> + arr[l] + <span class="string">","</span> + arr[r]);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">长度为N的数组arr，一定可以组成N^2个数值对。</span><br><span class="line">例如arr &#x3D; [3,1,2]，</span><br><span class="line">数值对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)，</span><br><span class="line">也就是任意两个数都有数值对，而且自己和自己也算数值对。</span><br><span class="line">数值对怎么排序？规定，第一维数据从小到大，第一维数据一样的，第二维数组也从小到大。所以上面的数值对排序的结果为：</span><br><span class="line">(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)</span><br><span class="line"></span><br><span class="line">给定一个数组arr，和整数k，返回第k小的数值对。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">假设数组是有序的,每个index 能产生N个数值对，所以总数值对是N * N</span><br><span class="line">第一个数：通过(K - 1) &#x2F; N 定位，假设它等于F</span><br><span class="line">第二个数：假设小于F的数有A个，先减掉开头小于F的值 K - (A * N) &#x3D; S</span><br><span class="line">        然后假设等于F的有B个，那么以F开头，和i&#x3D;0能匹配出 F * B的结果，同理i&#x3D;1也有F*B个结果...</span><br><span class="line">所以问题又转换以F作为第一个数值的前提下：</span><br><span class="line">每个index 能产生 B个数值对，要找到第S小的数值对，所以第二个数 &#x3D; (S - 1) &#x2F; B</span><br><span class="line"></span><br><span class="line">排序数组O(N*logN)，求第一个数O(1)，求第二个数也是O(1)</span><br><span class="line">所以问题转换成排序上，这种求第K小的数，可以使用bfprt算法中的改写快排方法：O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">每种工作有难度和报酬，规定如下</span><br><span class="line">class Job &#123;</span><br><span class="line">public int money;&#x2F;&#x2F; 该工作的报酬</span><br><span class="line">public int hard; &#x2F;&#x2F; 该工作的难度</span><br><span class="line">&#125;</span><br><span class="line">给定一个Job类型的数组jobarr，表示所有岗位，每个岗位都可以提供任意份工作</span><br><span class="line">选工作的标准是在难度不超过自身能力值的情况下，选择报酬最高的岗位</span><br><span class="line">给定一个int类型的数组arr，表示所有人的能力</span><br><span class="line">返回int类型的数组，表示每个人按照标准选工作后所能获得的最高报酬</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">按工作难度从小到大排序,难度一样时钱数由大到小排序，丢弃难度相同报酬低的工作</span><br><span class="line">如果难度递增的时候，报酬没递增，也丢弃</span><br><span class="line">保证了剩下的序列一定是难度上升，报酬也上升的，单调性</span><br><span class="line">把剩下的加入有序表，一个对象有难度, 有钱数，有序表里根据难度排序</span><br><span class="line">接下来一个有能力的人在有序表里查离你的能力小于等于最近的项目，取出该项目, 获得这个钱, 一定是最值得的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">背包容量为w</span><br><span class="line">一共有n袋零食, 第i袋零食体积为v[i] </span><br><span class="line">总体积不超过背包容量的情况下，</span><br><span class="line">一共有多少种零食放法？(总体积为0也算一种放法)。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arr[0...]</span></span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从左往右的经典模型</span></span><br><span class="line"><span class="comment">// 还剩的容量是rest，arr[index...]自由选择，</span></span><br><span class="line"><span class="comment">// 返回选择方案</span></span><br><span class="line"><span class="comment">// index ： 0～N</span></span><br><span class="line"><span class="comment">// rest : 0~w</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123; <span class="comment">// 没有容量了</span></span><br><span class="line">        <span class="comment">// -1 无方案的意思</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest&gt;=0,</span></span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 无零食可选</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// index号零食，要 or 不要</span></span><br><span class="line">    <span class="comment">// index, rest</span></span><br><span class="line">    <span class="comment">// (index+1, rest)</span></span><br><span class="line">    <span class="comment">// (index+1, rest-arr[i])</span></span><br><span class="line">    <span class="keyword">int</span> next1 = process(arr, index + <span class="number">1</span>, rest); <span class="comment">// 不要</span></span><br><span class="line">    <span class="keyword">int</span> next2 = process(arr, index + <span class="number">1</span>, rest - arr[index]); <span class="comment">// 要</span></span><br><span class="line">    <span class="keyword">return</span> next1 + (next2 == -<span class="number">1</span> ? <span class="number">0</span> : next2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="comment">//i表示index，当前背包背的体积</span></span><br><span class="line"><span class="comment">//i行 j列 = arr[i-1][j] + arr[i][j - arr[i-1]]</span></span><br><span class="line"><span class="comment">//表示自己不背的答案 + 背的答案</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][w + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//j = 0,i = [0...N-1]范围上 背了0个零食的答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i = 0, j = [0..w]背了1号零食的答案</span></span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + ((j - arr[i]) &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - arr[i]] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//求二维数组中最后一行的累加答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; j++) &#123;</span><br><span class="line">        ans += dp[N - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空间压缩"><a href="#空间压缩" class="headerlink" title="空间压缩"></a>空间压缩</h2><p><img src="/images/algorithm-all/alg-05.png" alt="algorithm"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">黄色：已知的点对应的值</span><br><span class="line">红色：答案所在的点</span><br><span class="line">假设arr[i][j]答案需要依赖 arr[i - 1][j] 和 arr[i][j - 1]</span><br><span class="line">那么根据已知的点，可以求出 arr[0][j]第一排的答案</span><br><span class="line"></span><br><span class="line">空间压缩：</span><br><span class="line">空间压缩是指将二维数组的空间压缩成一维数组的空间</span><br><span class="line">通过计算得到一行或者一列的结果，存放到一位数组中</span><br><span class="line">准备计算下一行或者下一列的结果时，通过值覆盖的方式，将答案填回一维数组</span><br><span class="line"></span><br><span class="line">若有arr[i][j]依赖了arr[i-1][j-1]的结果，可以通过使用一个临时变量存储arr[i-1][j-1]的结果。</span><br><span class="line"></span><br><span class="line">若有arr[i][j]依赖了之前几行的数据，可以申请几个一位数组，交替覆盖。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串str1和str2，求两个字符串的最长公共子串</span><br><span class="line">请注意区分子串和子序列的不同：</span><br><span class="line">子串表示连续的字符串,子序列可以不连续</span><br><span class="line"></span><br><span class="line">动态规划的空间压缩技巧！</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">简历动态规划的二维表</span><br><span class="line">行：[0...M-1] M是str1的长度</span><br><span class="line">列：[0...N-1] N是str2的长度</span><br><span class="line">值：arr[i][j] &#x3D; str1中必须以j位置结尾，且str2中必须以i位置结尾的最长公共子串长度</span><br><span class="line">所以两个最长公共子串就是二维表中的Max值</span><br><span class="line"></span><br><span class="line">arr[i][j] 依赖 str2[j] ?&#x3D; str1[i] 和arr[i-1][j-1]</span><br><span class="line">它只依赖二维表中的一个值，</span><br><span class="line">等同于起点位于右上角，然后一条从左往右的斜线一直在计算[i-1,j-1]、[i,j]、[i+1,j+1]的值</span><br><span class="line">也就是说，可以通过有限几个变量计算结果，而不需要申请二维表</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划 + 空间压缩！！！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lcst2</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span> || str1.equals(<span class="string">""</span>) || str2.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>; <span class="comment">// 出发点的行号</span></span><br><span class="line">    <span class="keyword">int</span> col = chs2.length - <span class="number">1</span>; <span class="comment">// 出发点的列号</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//str1的最长子串的结束下标</span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//出发的起点在右上角</span></span><br><span class="line">    <span class="keyword">while</span> (row &lt; chs1.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = row;</span><br><span class="line">        <span class="keyword">int</span> j = col;</span><br><span class="line">        <span class="comment">//缓存arr[i-1][j-1]的答案</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 向右下方移动的这一轮</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; chs1.length &amp;&amp; j &lt; chs2.length) &#123;</span><br><span class="line">            <span class="comment">//若不等，则为0</span></span><br><span class="line">            <span class="keyword">if</span> (chs1[i] != chs2[j]) &#123;</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若相等，则根据上一次求的答案arr[i][j] = arr[i-1][j-1] + 1 </span></span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若有长度超过Max，则更新，并记录str1的最长公共子串末尾下标</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//往右下对角线移动</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//行号--,一直往左移动，移动到不能往左了，就列号++,往下移动</span></span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//公共子串末尾index - max + 1则是公共子串的开头第一个字符！截取返回</span></span><br><span class="line">    <span class="keyword">return</span> str1.substring(end - max + <span class="number">1</span>, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个由字符串组成的数组String[] strs，给定一个正数K</span><br><span class="line">返回词频最大的前K个字符串，假设结果是唯一的</span><br><span class="line">如：[&quot;abc&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;aaaa&quot;,&quot;ab&quot;,&quot;abc&quot;]   K&#x3D;2 -&gt; return &quot;abc&quot; 和 &quot;ab&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">用HashMap&lt;String,Integer&gt;统计每个字符串的词频，然后使用小根堆做资源限制条件</span><br><span class="line">维持小根堆的大小&#x3D;K ，把HashMap的数据添加到小根堆中</span><br><span class="line">堆顶就是门槛，当词频数大于堆顶，则弹出堆顶，并添加新对象，周而复始，小根堆留着的，肯定是词最大K个频数</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">统计词频后，可以用改进的快排，求出第K大的数，时间复杂度O(N)，用小根堆是O(N*logN)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        times = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.times - o2.times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTopKAndRank</span><span class="params">(String[] arr, <span class="keyword">int</span> topK)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || topK &lt; <span class="number">1</span> || topK &gt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(str)) &#123;</span><br><span class="line">            map.put(str, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(str, map.get(str) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> NodeComparator());</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(entry.getKey(), entry.getValue());</span><br><span class="line">        <span class="comment">//如果没满，加进去</span></span><br><span class="line">        <span class="keyword">if</span> (heap.size() &lt; topK) &#123;</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//满了，判断堆顶和cur哪个大</span></span><br><span class="line">            <span class="keyword">if</span> (heap.peek().times &lt; cur.times) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        System.out.println(heap.poll().str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请实现如下结构：</span><br><span class="line">TopRecord&#123;</span><br><span class="line">public TopRecord(int K)  :  构造时事先指定好K的大小，构造后就固定不变了</span><br><span class="line">public  void add(String str)  :   向该结构中加入一个字符串，可以重复加入</span><br><span class="line">public  List&lt;String&gt; top() : 返回之前加入的所有字符串中，词频最大的K个</span><br><span class="line">&#125;</span><br><span class="line">要求： </span><br><span class="line">add方法，复杂度O(log K);</span><br><span class="line">top方法，复杂度O(K)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的堆结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] heap;</span><br><span class="line">    <span class="comment">//小根堆的大小下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="comment">// 字符串对应的词频</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Node&gt; strNodeMap;</span><br><span class="line">    <span class="comment">//小根堆上的节点所在的index位置</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; nodeIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopKRecord</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> Node[K];</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">        strNodeMap = <span class="keyword">new</span> HashMap&lt;String, Node&gt;();</span><br><span class="line">        nodeIndexMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str用户现在给我的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">如果str不在词频统计上，缓存词频统计，和小根堆堆顶比较</span></span><br><span class="line"><span class="comment">如果str在词频统计上，则词频数++，重新和小根堆堆顶比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Node curNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> preIndex = -<span class="number">1</span>; <span class="comment">// str之前在堆上的位置</span></span><br><span class="line">    <span class="comment">// 查词频表，看看有没有关于这个str的记录</span></span><br><span class="line">    <span class="keyword">if</span> (!strNodeMap.containsKey(str)) &#123; <span class="comment">// str之前没进来过</span></span><br><span class="line">        curNode = <span class="keyword">new</span> Node(str, <span class="number">1</span>);</span><br><span class="line">        strNodeMap.put(str, curNode);</span><br><span class="line">        nodeIndexMap.put(curNode, -<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// str之前进来过</span></span><br><span class="line">        curNode = strNodeMap.get(str);</span><br><span class="line">        curNode.times++;</span><br><span class="line">        <span class="comment">//获取字符串的index</span></span><br><span class="line">        preIndex = nodeIndexMap.get(curNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 词频表修改完毕，</span></span><br><span class="line">    <span class="keyword">if</span> (preIndex == -<span class="number">1</span>) &#123; <span class="comment">// 不在堆上</span></span><br><span class="line">        <span class="keyword">if</span> (heapSize == heap.length) &#123; <span class="comment">// 堆满了</span></span><br><span class="line">            <span class="comment">//如果堆顶的词频数比新的词频小</span></span><br><span class="line">            <span class="keyword">if</span> (heap[<span class="number">0</span>].times &lt; curNode.times) &#123;</span><br><span class="line">                <span class="comment">//交换存储的索引位置</span></span><br><span class="line">                nodeIndexMap.put(heap[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">                nodeIndexMap.put(curNode, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//重新设置堆顶heapify下沉</span></span><br><span class="line">                heap[<span class="number">0</span>] = curNode;</span><br><span class="line">                heapify(<span class="number">0</span>, heapSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 堆没有满</span></span><br><span class="line">            nodeIndexMap.put(curNode, heapSize);</span><br><span class="line">            heap[heapSize] = curNode;</span><br><span class="line">            <span class="comment">//尾部插入，heapInsert上浮</span></span><br><span class="line">            heapInsert(heapSize++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// str已经在堆上了</span></span><br><span class="line">        heapify(preIndex, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> smallest = index;</span><br><span class="line">    <span class="comment">//不能越界超过heapSize</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; heapSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap[l].times &lt; heap[index].times) &#123;</span><br><span class="line">            smallest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; heap[r].times &lt; heap[smallest].times) &#123;</span><br><span class="line">            smallest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">            swap(smallest, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = smallest;</span><br><span class="line">        l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    nodeIndexMap.put(heap[index1], index2);</span><br><span class="line">    nodeIndexMap.put(heap[index2], index1);</span><br><span class="line">    Node tmp = heap[index1];</span><br><span class="line">    heap[index1] = heap[index2];</span><br><span class="line">    heap[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串类型的数组arr，譬如:</span><br><span class="line">String[] arr &#x3D; &#123; &quot;b\st&quot;, &quot;d\&quot;, &quot;a\d\e&quot;, &quot;a\b\c&quot; &#125;; </span><br><span class="line">把这些路径中蕴含的目录结构给打印出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样:</span><br><span class="line">a</span><br><span class="line">  b</span><br><span class="line">    c</span><br><span class="line">  d</span><br><span class="line">    e</span><br><span class="line">b</span><br><span class="line">  st</span><br><span class="line">d</span><br><span class="line">同一级的需要按字母顺序排列不能乱。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">把路径变成前缀树形式，并且使用TreeMap排序前缀树，最后深度优先遍历输出，格子的数量：2 * (层数 - 1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上一个节点是通过哪条路，到我的</span></span><br><span class="line">    <span class="keyword">public</span> String path;</span><br><span class="line">    <span class="comment">// key : node下级的路   value：node在key这条路上对应的节点是什么</span></span><br><span class="line">    <span class="keyword">public</span> TreeMap&lt;String, Node&gt; nextMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = p;</span><br><span class="line">        nextMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// folderPaths -&gt;  [   "a\b\c","a\b\s" , "a\d\e" ,"e\f\sty"     ]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] folderPaths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folderPaths == <span class="keyword">null</span> || folderPaths.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据所有字符串，把前缀树建立好，头节点为head</span></span><br><span class="line">    Node head = generateFolderTree(folderPaths);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    printProcess(head, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateFolderTree</span><span class="params">(String[] folderPaths)</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="string">""</span>); <span class="comment">// 系统根目录, 前缀树头节点</span></span><br><span class="line">    <span class="keyword">for</span> (String foldPath : folderPaths) &#123; <span class="comment">// 拿出每一个绝对路径</span></span><br><span class="line">        String[] paths = foldPath.split(<span class="string">"\\\\"</span>); <span class="comment">// java 特性，用一个"\"做分割的意思</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.length; i++) &#123; <span class="comment">// "a"  , "b"   ,"c"</span></span><br><span class="line">            <span class="keyword">if</span> (!cur.nextMap.containsKey(paths[i])) &#123;</span><br><span class="line">                cur.nextMap.put(paths[i], <span class="keyword">new</span> Node(paths[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nextMap.get(paths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head节点，当前在level层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2 * (level - 1)</span></span><br><span class="line">        System.out.println(get4nSpace(level) + node.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node next : node.nextMap.values()) &#123;</span><br><span class="line">        printProcess(next, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get4nSpace</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += <span class="string">"    "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历 数组，返回后序遍历数组。</span><br><span class="line">比如给定:</span><br><span class="line">int[] pre &#x3D; &#123; 1, 2, 4, 5, 3, 6, 7 &#125;;</span><br><span class="line">int[] in &#x3D; &#123; 4, 2, 5, 1, 6, 3, 7 &#125;; </span><br><span class="line">返回:&#123;4,5,2,6,7,3,1&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先序：头左右 </span><br><span class="line">中序：左头右 </span><br><span class="line">后序：左右头</span><br><span class="line"></span><br><span class="line">所以先序的第一个头位置，一定是后序的最后一个头位置</span><br><span class="line">然后去中序列表，寻找头的位置，中序左边的部分是左树L，右边的部分是右树R</span><br><span class="line">以先序的头index + 1则是左树开始的LL</span><br><span class="line">以LL + 中序算出来的左树长度 L ，这部分，就会放在后序的左部分</span><br><span class="line"></span><br><span class="line">递归计算每个树的位置放到后序数组中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] preInToPos2(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in) &#123;</span><br><span class="line">    <span class="comment">//若两段长度不同，则直接范围</span></span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = pre.length;</span><br><span class="line">    <span class="comment">//先缓存中序中，每个数值对应的i位置，方便计算</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        inMap.put(in[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    process2(pre, <span class="number">0</span>, N - <span class="number">1</span>, in, <span class="number">0</span>, N - <span class="number">1</span>, pos, <span class="number">0</span>, N - <span class="number">1</span>, inMap);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">L1..R1 是pre数组范围</span></span><br><span class="line"><span class="comment">L2..R2 是in 数组范围</span></span><br><span class="line"><span class="comment">L3..R3 是pos数组范围</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2, <span class="keyword">int</span>[] pos, <span class="keyword">int</span> L3, <span class="keyword">int</span> R3,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HashMap&lt;Integer, Integer&gt; inMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一个数，则直接设置</span></span><br><span class="line">    <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">        pos[L3] = pre[L1];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将先序的头L1位置 放到后序的末尾R3位置</span></span><br><span class="line">    pos[R3] = pre[L1];</span><br><span class="line">    <span class="comment">//查询头L1在中序中的index，将左右树根据这个中心头节点，划分成左右两块不同的区域</span></span><br><span class="line">    <span class="keyword">int</span> mid = inMap.get(pre[L1]);</span><br><span class="line">    <span class="comment">//该头节点的左树的长度等于 index - L2</span></span><br><span class="line">    <span class="keyword">int</span> leftSize = mid - L2;</span><br><span class="line">    <span class="comment">//递归计算左区域的结果</span></span><br><span class="line">    process2(pre, L1 + <span class="number">1</span>, L1 + leftSize, in, L2, mid - <span class="number">1</span>, pos, L3, L3 + leftSize - <span class="number">1</span>, inMap);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归计算右区域的结果</span></span><br><span class="line">    process2(pre, L1 + leftSize + <span class="number">1</span>, R1, in, mid + <span class="number">1</span>, R2, pos, L3 + leftSize, R3 - <span class="number">1</span>, inMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最长递增子序列问题的O(N*logN)的解法</span><br><span class="line">最长递增子序列：&#123;3,1,4,2,3&#125; --&gt; &#123;1,2,3&#125;严格递增，不能相等</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">O(N^2) 解法：</span><br><span class="line">动态规划，一维数组dp，以每个i位置为下标，value存储以i位置结尾的最长递增子序列长度</span><br><span class="line">通过查看i位置左边比他小的值，取其中递增子序列的max最大值 + 1</span><br><span class="line"></span><br><span class="line">O(N * logN) 解法：</span><br><span class="line">增加一个ends数组，end[i]&#x3D;V，其中V表示arr数组中，最长递增子序列 &#x3D; i + 1 时的序列结尾的最小值</span><br><span class="line">当计算以i结尾的最长子序列长度时，通过二分找ends数组中，大于等于arr[i]的最左位置</span><br><span class="line">若无结果，则将arr[i]插入到ends中</span><br><span class="line">若有结果，假设其下标在ends数组中是k,则将ends[k]的值更新成arr[i]</span><br><span class="line">那么，dp[i]的值就是k + 1,有k + 1个最长子序列</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">     &#123;3,1,4,2,3,7...&#125; --&gt; &#123;1,2,3,7...&#125;</span><br><span class="line">dp:  &#123;1&#125; -&gt; &#123;1,1&#125; -&gt;&#123;1,1,2&#125; -&gt; &#123;1,1,2,2&#125; -&gt; &#123;1,1,2,2,3&#125; -&gt; ...</span><br><span class="line">ends:&#123;3&#125; -&gt; &#123;1&#125;   -&gt;&#123;1,4&#125;   -&gt; &#123;1,2&#125;     -&gt; &#123;1,2,3&#125;     -&gt; ...</span><br><span class="line"></span><br><span class="line">假设遍历了5次，i从0开始，这时候i &#x3D; 4，</span><br><span class="line">根据例子可以看到，ends[2] &#x3D; 3 &#x3D; arr[4], 最长递增子序列 dp[4] &#x3D; 2(ends的index) + 1 &#x3D; 3</span><br><span class="line">也就是代表着 从下标[0..4]内，在最长递增子序列的长度都 &#x3D; 3时的min(arr[i]) &#x3D; 3</span><br><span class="line">如&#123;1,2,3&#125;和&#123;1,2,7&#125;,长度为3的最长递增子序列的最小结尾 &#x3D; 3</span><br><span class="line"></span><br><span class="line">ends数组可以保证有序，因为当最长子序列长度相同时，min(arr[i])一定是相同的，只有长度增加时，它的值才会变化，而且当长度上升时，其对应的值必定 &gt; min(arr[i])</span><br><span class="line"></span><br><span class="line">遍历arr数组，时间复杂度O(N)， 遍历过程中计算dp数组采用了ends数组，ends长度为N</span><br><span class="line">ends数组中通过二分查找大于arr[i]中的最左位置 O(logN)</span><br><span class="line">所以整体的时间复杂度是O(N * logN)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N * logN)</span></span><br><span class="line"><span class="comment">//构建dp数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getdp2(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    ends[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">// 0....right   right往右无效</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//二分，找ends数组中，大于等于arr[i]的最左的位置</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若有效区没找到，需要扩充有效区，则l = right+1  right需要扩容更新值</span></span><br><span class="line">        <span class="comment">//若有效区找到了，则l &lt; right， right需要原值 </span></span><br><span class="line">        <span class="comment">//取两者的max</span></span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        <span class="comment">//更新ends的值，把大于等于arr[i]的最左的位置更新成arr[i]</span></span><br><span class="line">        ends[l] = arr[i];</span><br><span class="line">        <span class="comment">//赋值dp值</span></span><br><span class="line">        dp[i] = l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个信封都有长和宽两个维度的数据，A信封如果想套在B信封里面，A信封必须在长和宽上都小于B信封才行。</span><br><span class="line">如果给你一批信封，返回最大的嵌套层数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">先排序第一维数据(长度)由小到大，如果第一维一样, 第二维数据(宽度)由大到小</span><br><span class="line">第二维度数据单独拎出来, 它的最长递增子序列就是套的层数</span><br><span class="line">因为长度已经先排好序了，若宽度也按照递增子序列递增，那么保证了长也递增，宽也递增，那么答案就出来了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Envelope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Envelope</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> hight)</span> </span>&#123;</span><br><span class="line">        l = weight;</span><br><span class="line">        h = hight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvelopeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Envelope</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Envelope o1, Envelope o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.l != o2.l ? o1.l - o2.l : o2.h - o1.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Envelope[] getSortedEnvelopes(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    Envelope[] res = <span class="keyword">new</span> Envelope[matrix.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        res[i] = <span class="keyword">new</span> Envelope(matrix[i][<span class="number">0</span>], matrix[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(res, <span class="keyword">new</span> EnvelopeComparator());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    Envelope[] envelopes = getSortedEnvelopes(matrix);</span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length];</span><br><span class="line">    ends[<span class="number">0</span>] = envelopes[<span class="number">0</span>].h;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[i].h &gt; ends[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = Math.max(right, l);</span><br><span class="line">        ends[l] = envelopes[i].h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，返回子数组的最大累加和。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">定义一个cur和一个max的变量</span><br><span class="line">cur进行数据的累加，并赋值给max，若下次累加大于max，则更新max的值</span><br><span class="line">若累加的值小于0，则放弃之前的累加和，从0开始重新计算，重置成0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        cur += arr[i];</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">        <span class="comment">//累加和小于0，则重置成0</span></span><br><span class="line">        cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整型矩阵，返回子矩阵的最大累加和。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">求[0~0]...[0~1]...[0~N-1]行的最大累加和</span><br><span class="line">再求[1~1]..[1~2]...[1~N-1]行的最大累加和</span><br><span class="line">以此类推，最终最大的累加和答案就出来了</span><br><span class="line">而求[0~0]行的最大累加和，等于求一维数组的最大累加和</span><br><span class="line">而求[0~1]行的最大累加和，通过将[0~0]行的数组,按照相同列，进行累加，累加到[0~1]行中，最后还是一维数组</span><br><span class="line">这就是数组压缩技巧</span><br><span class="line"></span><br><span class="line">时间复杂度O(N^2 * M)</span><br><span class="line">N是行，M是列，挑选小的值做行，常数项优化</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历数组的每行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m.length; i++) &#123; <span class="comment">// 开始的行号i</span></span><br><span class="line">        <span class="comment">//累加每行</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">int</span>[m[<span class="number">0</span>].length]; </span><br><span class="line">        <span class="comment">//遍历数组的每列 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j != m.length; j++) &#123; <span class="comment">// 结束的行号j，i~j行是我讨论的范围</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//计算一维数组累加和</span></span><br><span class="line">            cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k != s.length; k++) &#123;</span><br><span class="line">                s[k] += m[j][k];</span><br><span class="line">                cur += s[k];</span><br><span class="line">                max = Math.max(max, cur);</span><br><span class="line">                cur = cur &lt; <span class="number">0</span> ? <span class="number">0</span> : cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是right的话。</span><br><span class="line">给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。</span><br><span class="line">链表中的顺序以中序遍历排列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整棵树，串成双向链表，返回头、尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node start;</span><br><span class="line">    <span class="keyword">public</span> Node end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(Node start, Node end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以x为头的整棵搜索二叉树，请全部以有序双向链表的方式，连好</span></span><br><span class="line"><span class="comment">// 并且返回，整个有序双向链表的头节点和尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);	</span><br><span class="line">    <span class="keyword">if</span> (leftInfo.end != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftInfo.end.right = X;</span><br><span class="line">    &#125;</span><br><span class="line">    X.left = leftInfo.end;</span><br><span class="line">    X.right = rightInfo.start;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo.start != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rightInfo.start.left = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(</span><br><span class="line">        <span class="comment">// 整棵树的头，</span></span><br><span class="line">        leftInfo.start != <span class="keyword">null</span> ? leftInfo.start : X</span><br><span class="line">        ,</span><br><span class="line">        <span class="comment">// 整棵树的尾</span></span><br><span class="line">        rightInfo.end != <span class="keyword">null</span> ? rightInfo.end : X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。</span><br><span class="line">【举例】</span><br><span class="line">str1&#x3D;&quot;abc&quot;，str2&#x3D;&quot;adc&quot;，ic&#x3D;5，dc&#x3D;3，rc&#x3D;2 从&quot;abc&quot;编辑成&quot;adc&quot;，把&#39;b&#39;替换成&#39;d&#39;是代价最小的，所以返回2 </span><br><span class="line">str1&#x3D;&quot;abc&quot;，str2&#x3D;&quot;adc&quot;，ic&#x3D;5，dc&#x3D;3，rc&#x3D;100 从&quot;abc&quot;编辑成&quot;adc&quot;，先删除&#39;b&#39;，然后插入&#39;d&#39;是代价最小的，所以返回8</span><br><span class="line">str1&#x3D;&quot;abc&quot;，str2&#x3D;&quot;abc&quot;，ic&#x3D;5，dc&#x3D;3，rc&#x3D;2 不用编辑了，本来就是一样的字符串，所以返回0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">二维表的范围尝试模型的动态规划问题，一个字符串做行，一个字符串做列的二维数组dp</span><br><span class="line">dp[i][j]的含义是 str1拿出前缀为i的长度和str2前缀为j的长度的最小编辑代价</span><br><span class="line"></span><br><span class="line">dp[0][0] &#x3D; 0</span><br><span class="line">dp数组的第0行：以str1拿出0个字符，变成[0...N-1]的代价，则是dp[0][j] &#x3D; j * rc,字符长度多少，就多少个插入代价</span><br><span class="line">dp数组的第0列：以str1拿出[0...N-1]个字符，变成0个字符的代价，则是dp[i][0] &#x3D; i * dc，字符长度多少，多少个删除代价</span><br><span class="line"></span><br><span class="line">四种情况：</span><br><span class="line">一：dp[i][j] &#x3D; dp[i-1][j-1] + rc 如果str1[i] !&#x3D; str2[j]，直接将i字符替换成j字符，一个替换字符的代价</span><br><span class="line">二：dp[i][j] &#x3D; dp[i-1][j-1] + 0 如果str1[i] &#x3D;&#x3D; str2[j]，替换代价 &#x3D; 0</span><br><span class="line">三：将str1部分前缀变成str2，然后删除str1后缀中的多余的字符</span><br><span class="line">四：将str1整体字符变成str2的前缀字符，然后添加str2未匹配的后缀字符</span><br><span class="line"></span><br><span class="line">分大类:</span><br><span class="line">保留str1的i字符：</span><br><span class="line">  i位置作为j位置的字符 ：str1[i] ?&#x3D; str[j]</span><br><span class="line">     &#x3D;&#x3D; : 0个代价</span><br><span class="line">     !&#x3D; : 一个替换代价</span><br><span class="line">  i位置不作为j位置的字符：作为str2的前缀字符,然后添加j字符</span><br><span class="line">不保留str1的i字符：</span><br><span class="line">  删除i字符，将[0,i-1]字符变成str2</span><br><span class="line">  </span><br><span class="line">时间复杂度O(N * M)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCost1</span><span class="params">(String s1, String s2, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="comment">//N M 是dp中的字符串长度映射的index，而不是下标对下标</span></span><br><span class="line">    <span class="keyword">int</span> N = str1.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> M = str2.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][M];</span><br><span class="line">    <span class="comment">// dp[0][0]  = 0 ，字符串长度为0时，成倍的新增和删除的代价</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dc * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = ic * j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="comment">//如果末位字符相同，则0个替换代价，否则添加一个替换代价</span></span><br><span class="line">            <span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//情况一：如果末位字符相同,等于大家都少选一个长度的代价</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况二：增加一个替换代价</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况三：保留i字符，str1变换成str2的j-1个长度，再插入一个j字符的代价</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + ic);</span><br><span class="line">            <span class="comment">//情况四：不保留i字符，str1变换成str2的j个长度，再来个删除i字符的代价</span></span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + dc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？</span><br><span class="line">比如 s1 &#x3D; &quot;abcde&quot;，s2 &#x3D; &quot;axbc&quot;</span><br><span class="line">返回1。s2删掉&#39;x&#39;就是s1的子串了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：</span><br><span class="line">如果S2很短，则可以计算S2的所有子序列（2^M数量），M是S2的长度，然后用KMP判断哪个最长子序列是否是S1的子串</span><br><span class="line">那么S2最少需要删除 M - 最长子序列长度, 时间复杂度O(N * 2^M)</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">若S2很长，则S1求所有子串O(N^2)，求S1所有子串和S2的编辑距离，S1子串通过插入行为转换成S2</span><br><span class="line">时间复杂度是O(N^3 * M)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法一：</span></span><br><span class="line"><span class="comment">// 因为题目原本的样本数据中，有特别说明s2的长度很小。所以这么做也没有太大问题，也几乎不会超时。</span></span><br><span class="line"><span class="comment">// 但是如果某一次考试给定的s2长度远大于s1，这么做就不合适了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCost1</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; s2Subs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//得到S2的所有子序列</span></span><br><span class="line">    process(s2.toCharArray(), <span class="number">0</span>, <span class="string">""</span>, s2Subs);</span><br><span class="line">    <span class="comment">//按照长度排序，优先遍历长度长的</span></span><br><span class="line">    s2Subs.sort(<span class="keyword">new</span> LenComp());</span><br><span class="line">    <span class="keyword">for</span> (String str : s2Subs) &#123;</span><br><span class="line">        <span class="comment">//若匹配，则返回答案</span></span><br><span class="line">        <span class="keyword">if</span> (s1.indexOf(str) != -<span class="number">1</span>) &#123; <span class="comment">// indexOf底层和KMP算法代价几乎一样，也可以用KMP代替</span></span><br><span class="line">            <span class="keyword">return</span> s2.length() - str.length();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若所有子序列都不匹配，则等于S2全部都要删掉</span></span><br><span class="line">    <span class="keyword">return</span> s2.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str2, <span class="keyword">int</span> index, String path, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == str2.length) &#123;</span><br><span class="line">        list.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(str2, index + <span class="number">1</span>, path, list);</span><br><span class="line">    process(str2, index + <span class="number">1</span>, path + str2[index], list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LenComp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.length() - o1.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="comment">// 枚举所有s1的子串</span></span><br><span class="line"><span class="comment">// 然后考察每个子串和s2的编辑距离(假设编辑距离只有删除动作且删除一个字符的代价为1)</span></span><br><span class="line"><span class="comment">// 如果s1的长度较小，s2长度较大，这个方法比较合适</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCost2</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="comment">//枚举所有s1的子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; s1.length(); start++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s1.length(); end++) &#123;</span><br><span class="line">            <span class="comment">// str1[start....end]</span></span><br><span class="line">            <span class="comment">//假设只有插入行为，求子串和Str2的编辑距离</span></span><br><span class="line">            ans = Math.min(ans, distance(str2, s1.substring(start, end).toCharArray()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? s2.length() : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求str2到s1sub的编辑距离</span></span><br><span class="line"><span class="comment">// 假设编辑距离只有删除动作且删除一个字符的代价为1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">char</span>[] str2, <span class="keyword">char</span>[] s1sub)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = str2.length;</span><br><span class="line">    <span class="keyword">int</span> col = s1sub.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="comment">// dp[i][j]的含义：</span></span><br><span class="line">    <span class="comment">// str2[0..i]仅通过删除行为变成s1sub[0..j]的最小代价</span></span><br><span class="line">    <span class="comment">// 可能性一：</span></span><br><span class="line">    <span class="comment">// str2[0..i]变的过程中，不保留最后一个字符(str2[i])，</span></span><br><span class="line">    <span class="comment">// 那么就是通过str2[0..i-1]变成s1sub[0..j]之后，再最后删掉str2[i]即可 -&gt; dp[i][j] = dp[i-1][j] + 1</span></span><br><span class="line">    <span class="comment">// 可能性二：</span></span><br><span class="line">    <span class="comment">// str2[0..i]变的过程中，想保留最后一个字符(str2[i])，然后变成s1sub[0..j]，</span></span><br><span class="line">    <span class="comment">// 这要求str2[i] == s1sub[j]才有这种可能, 然后str2[0..i-1]变成s1sub[0..j-1]即可</span></span><br><span class="line">    <span class="comment">// 也就是str2[i] == s1sub[j] 的条件下，dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单个字符相等，则不需要删除，所以删除次数=0次</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = str2[<span class="number">0</span>] == s1sub[<span class="number">0</span>] ? <span class="number">0</span> : Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">//str2只有一个字符的时候，不管怎么删，都无法变成长度大于1的S1的子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没相同字符，无穷大，有相同字符的话，删除的数量一定是 length - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] != Integer.MAX_VALUE || str2[i] == s1sub[<span class="number">0</span>]) ? i : Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//利用[0,i-1]转换成[0,j]，删除i字符</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果i字符=j字符，删其他字符</span></span><br><span class="line">            <span class="keyword">if</span> (str2[i] == s1sub[j] &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解法二的优化</span><br><span class="line">优化点：计算子串长度[0,1]之后，基于[0,1]的结果dp表结果，补多一行变成[0,2]的dp结果</span><br><span class="line">前缀index相同时，可以共用同一张dp表，前缀index不同，无法共用</span><br><span class="line">但是可以共用dp数组，以j &#x3D; 0做起始列，计算整个dp数组，下次以j &#x3D; 1做起始列，覆盖整个dp数组</span><br><span class="line">最终会优化成O(N^2 * M)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCost3</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> M = str2.length;</span><br><span class="line">    <span class="keyword">int</span> N = str1.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">    <span class="comment">//M可以认为是正无穷，无效解</span></span><br><span class="line">    <span class="keyword">int</span> ans = M;</span><br><span class="line">    <span class="comment">//start : dp数组以哪一列做起始列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; N; start++) &#123; <span class="comment">// 开始的列数</span></span><br><span class="line">         <span class="comment">//单个字符相等，则不需要删除，所以删除次数=0次,否则正无穷</span></span><br><span class="line">        dp[<span class="number">0</span>][start] = str2[<span class="number">0</span>] == str1[start] ? <span class="number">0</span> : M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; M; row++) &#123;</span><br><span class="line">             <span class="comment">//没相同字符，无穷大，有相同字符的话，删除的数量一定是 row</span></span><br><span class="line">            dp[row][start] = (str2[row] == str1[start] || dp[row - <span class="number">1</span>][start] != M) ? row : M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先取起始列的最后的值做答案</span></span><br><span class="line">        ans = Math.min(ans, dp[M - <span class="number">1</span>][start]);</span><br><span class="line">        <span class="comment">// 以上已经把start列，填好</span></span><br><span class="line">        <span class="comment">// 以下要把dp[...][start+1....N-1]的信息填好</span></span><br><span class="line">        <span class="comment">//小加速：end - start 表示以start 开始，向右推了j列，当j+1 &gt; M，则S2无法通过删除变成S1的子串</span></span><br><span class="line">        <span class="comment">//比如Str2长度只有10，怎么可能删除出长度12的字符呢？</span></span><br><span class="line">        <span class="comment">//所以end -start + 1 &lt;= M --&gt; end - start &lt; M 作为for循环的加速条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt; N &amp;&amp; end - start &lt; M; end++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> first = end - start;</span><br><span class="line">            <span class="comment">//这里first是表示以start做起始列时， i == j，表示str2的字符串和s1子串长度相等时的情况</span></span><br><span class="line">            <span class="comment">//先把等长的结果先填写，等长结果直接看最后一个字符，要么0，要么M</span></span><br><span class="line">            dp[first][end] = (str2[first] == str1[end] &amp;&amp; dp[first - <span class="number">1</span>][end - <span class="number">1</span>] == <span class="number">0</span>) ? <span class="number">0</span> : M;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//因为first长度&gt;=当前dp的end - start列长度才有效，所以dp右上半空间不考虑</span></span><br><span class="line">            <span class="comment">//现在是end - start列固定了，所以直接计算 frist + 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = first + <span class="number">1</span>; row &lt; M; row++) &#123;</span><br><span class="line">                dp[row][end] = M;</span><br><span class="line">                <span class="keyword">if</span> (dp[row - <span class="number">1</span>][end] != M) &#123;</span><br><span class="line">                    dp[row][end] = dp[row - <span class="number">1</span>][end] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[row - <span class="number">1</span>][end - <span class="number">1</span>] != M &amp;&amp; str2[row] == str1[end]) &#123;</span><br><span class="line">                    dp[row][end] = Math.min(dp[row][end], dp[row - <span class="number">1</span>][end - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans, dp[M - <span class="number">1</span>][end]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求完全二叉树节点的个数,要求时间复杂度低于O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思想：</span><br><span class="line">求以左树和右树的作为头节点的深度，进行比较</span><br><span class="line">若左树深度A &#x3D; 右树深度B，则左树一定是满二叉树，那么左树 + 头节点 &#x3D; [2^A -1] + 1，右树递归去</span><br><span class="line">若左树深度A &#x3D; 右树深度B + 1，则右树一定是满二叉树，那么右树 + 头节点 &#x3D; [2^B -1] + 1，左树递归去</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请保证head为头的树，是完全二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs(head, <span class="number">1</span>, mostLeftLevel(head, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// node在第level层，h是总的深度（h永远不变，全局变量</span></span><br><span class="line"><span class="comment">// 以node为头的完全二叉树，节点个数是多少</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(Node node, <span class="keyword">int</span> Level, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//basecase，最深层，一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (Level == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右树和左树的层数相同，左树满二叉树计算</span></span><br><span class="line">    <span class="keyword">if</span> (mostLeftLevel(node.right, Level + <span class="number">1</span>) == h) &#123;</span><br><span class="line">        <span class="comment">//左树满，计算层数</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - Level)) + bs(node.right, Level + <span class="number">1</span>, h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//右树满，但是层数比左树小一层，所以减1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; (h - Level - <span class="number">1</span>)) + bs(node.left, Level + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果node在第level层，</span></span><br><span class="line"><span class="comment">// 求以node为头的子树，最大深度是多少</span></span><br><span class="line"><span class="comment">// node为头的子树，一定是完全二叉树</span></span><br><span class="line"><span class="comment">//Node node 以这个node节点总共有几层</span></span><br><span class="line"><span class="comment">//int level 这个node处于第几层，接着往下加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftLevel</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        level++;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(Least Recently Used)LRU内存替换算法的实现:</span><br><span class="line">假设一个HashMap最多存储3条记录，弄个时间戳，不管是get、put都更新时间戳，当要新增或者删除时，都优先移除时间戳最早的数据。</span><br><span class="line"></span><br><span class="line">经典的只有put, get, 要求时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">使用双向链表:</span><br><span class="line">越靠近尾部就是最近操作的key,越靠近头部就是最早操作的key</span><br><span class="line">把一个节点拿出,或者放到最后都是O(1), 因为直接用Hash表操作</span><br><span class="line"></span><br><span class="line">为什么不能使用单链表：</span><br><span class="line">因为当要更新链表中间的节点到链表末尾时，无法找到它的parent对象指向它的next指针</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; pre;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="comment">// 从head到tail所有节点都是串好的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeDoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeDoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个新的节点加入，放到尾巴上去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// newNode != null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123; <span class="comment">// 双向链表中一个节点也没有</span></span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 双向链表中之前有节点，tail（非null）</span></span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            newNode.pre = tail;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 潜台词 ： 双向链表上一定有这个node</span></span><br><span class="line">    <span class="comment">// node分离出，但是node前后环境重新连接</span></span><br><span class="line">    <span class="comment">// node放到尾巴上去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveNodeToTail</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果刚好是尾巴，什么都不用干</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果刚好是头指针，不用动pre的指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == node) &#123; <span class="comment">// 当前node是老头部</span></span><br><span class="line">            <span class="keyword">this</span>.head = node.next;</span><br><span class="line">            <span class="keyword">this</span>.head.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前node是中间的一个节点</span></span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把节点放到尾巴去</span></span><br><span class="line">        node.pre = <span class="keyword">this</span>.tail;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">        <span class="keyword">this</span>.tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">removeHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K, V&gt; res = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail) &#123; <span class="comment">// 链表中只有一个节点的时候</span></span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = res.next;</span><br><span class="line">            res.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.head.pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Node&lt;K, V&gt;&gt; keyNodeMap;</span><br><span class="line">    <span class="keyword">private</span> NodeDoubleLinkedList&lt;K, V&gt; nodeList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//初始化时定义好LRU的空间大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCache</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cap &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"should be more than 0."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        keyNodeMap = <span class="keyword">new</span> HashMap&lt;K, Node&lt;K, V&gt;&gt;();</span><br><span class="line">        nodeList = <span class="keyword">new</span> NodeDoubleLinkedList&lt;K, V&gt;();</span><br><span class="line">        capacity = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;K, V&gt; res = keyNodeMap.get(key);</span><br><span class="line">            nodeList.moveNodeToTail(res);</span><br><span class="line">            <span class="keyword">return</span> res.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = keyNodeMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            nodeList.moveNodeToTail(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这是一个新加的记录，有可能出现替换</span></span><br><span class="line">             <span class="keyword">if</span> (keyNodeMap.size() == capacity) &#123;</span><br><span class="line">                removeMostUnusedCache();</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">            keyNodeMap.put(key, newNode);</span><br><span class="line">            nodeList.addNode(newNode);</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMostUnusedCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; removeNode = nodeList.removeHead();</span><br><span class="line">        keyNodeMap.remove(removeNode.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串，记为start和to，再给定一个字符串列表list，list中一定包含to list中没有重复字符串，所有的字符串都是小写的。</span><br><span class="line">规定: start每次只能改变一个字符，最终的目标是彻底变成to，但是每次变成的新字符串必须在list 中存在。</span><br><span class="line">请返回所有最短的变换路径。</span><br><span class="line">【举例】 </span><br><span class="line">start=<span class="string">"abc"</span>,end=<span class="string">"cab"</span>,list=&#123;<span class="string">"cab"</span>,<span class="string">"acc"</span>,<span class="string">"cbc"</span>,<span class="string">"ccc"</span>,<span class="string">"cac"</span>,<span class="string">"cbb"</span>,<span class="string">"aab"</span>,<span class="string">"abb"</span>&#125;</span><br><span class="line">转换路径的方法有很多种，但所有最短的转换路径如下: </span><br><span class="line">abc -&gt; abb -&gt; aab -&gt; cab</span><br><span class="line">abc -&gt; abb -&gt; cbb -&gt; cab</span><br><span class="line">abc -&gt; cbc -&gt; cac -&gt; cab</span><br><span class="line">abc -&gt; cbc -&gt; cbb -&gt; cab</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">把List集合做成一张图，能够通过改变有一个字符变成新字符，则表示两个字符之间有边</span><br><span class="line"></span><br><span class="line">如果有N个字符串, 每个字符串平均长度K, 怎么构建这张邻居表?</span><br><span class="line"> 0位置的字符串查跟1, 2, 3, ..., N-1之间有没有路径</span><br><span class="line"> 1位置的字符串查跟2, 3, 4, ..., N-1之间有没有路径</span><br><span class="line"> 2位置的字符串查跟3, 4, 5, ..., N-1之间有没有路径</span><br><span class="line">复杂度: O(N^2)  两个字符串, 想知道他们之间有没有路径, 还得遍历一个O(K)才知道</span><br><span class="line">生成所有邻居表复杂度: O(N^2*K)</span><br><span class="line"></span><br><span class="line">如果字符串长度是K, 而每一个字符都是小写字母的话,这个过程是可以加速的 先把List作成hash表</span><br><span class="line">把【abc】所有变化的可能性都列出来, 查每一个字符串在set里有没有,如果有就是你的邻居, 没有就忽略</span><br><span class="line">可能性数量：25 * K</span><br><span class="line">在hash表查的复杂度O(1): 是在每个单样本大小可以忽略的情况下，字符串在哈希表怎么查?</span><br><span class="line">需要遍历你所有字符, 求出一个哈希值再去找，所以, 这里要认为复杂度是O(K)，每一个查询代价O(k)</span><br><span class="line">所以这个方法的复杂度是 O(K^2) 就能找到所有邻居</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; findMinPaths(</span><br><span class="line">    String start, </span><br><span class="line">    String end,</span><br><span class="line">    List&lt;String&gt; list) &#123;</span><br><span class="line">    list.add(start);</span><br><span class="line">    <span class="comment">//获取list中所有字符的枚举的邻居</span></span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts = getNexts(list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求所有字符串到start的最短距离是多少 宽度优先遍历</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; distances = getDistances(start, nexts);</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;String&gt; pathList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getShortestPaths(start, end, nexts, distances, pathList, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回words中的所有字符对应的邻居表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt; getNexts(List&lt;String&gt; words) &#123;</span><br><span class="line">    Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(words); <span class="comment">// List 所有东西放入 set</span></span><br><span class="line">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">        nexts.put(words.get(i), getNext(words.get(i), dict));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nexts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">getNext</span><span class="params">(String word, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">    <span class="comment">//枚举所有字符 不包括 word 和dict中的字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> cur = <span class="string">'a'</span>; cur &lt;= <span class="string">'z'</span>; cur++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs[i] != cur) &#123;</span><br><span class="line">                <span class="keyword">char</span> tmp = chs[i];</span><br><span class="line">                chs[i] = cur;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的宽度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title">getDistances</span><span class="params">(String start,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; distances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distances.put(start, <span class="number">0</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    queue.add(start);</span><br><span class="line">    <span class="comment">//去重遍历过的节点</span></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    set.add(start);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (String next : nexts.get(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                <span class="comment">//记录节点到start之间的层数</span></span><br><span class="line">                distances.put(next, distances.get(cur) + <span class="number">1</span>);</span><br><span class="line">                queue.add(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distances;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在来到了什么：cur</span></span><br><span class="line"><span class="comment">// 目的地：to</span></span><br><span class="line"><span class="comment">// 邻居表：nexts</span></span><br><span class="line"><span class="comment">// 最短距离表：distances</span></span><br><span class="line"><span class="comment">// 沿途走过的路径：path上&#123;....&#125;</span></span><br><span class="line"><span class="comment">// 答案往res里放，收集所有的最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getShortestPaths</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String cur, String to,</span></span></span><br><span class="line"><span class="function"><span class="params">    HashMap&lt;String, ArrayList&lt;String&gt;&gt; nexts,</span></span></span><br><span class="line"><span class="function"><span class="params">    HashMap&lt;String, Integer&gt; distances,</span></span></span><br><span class="line"><span class="function"><span class="params">    LinkedList&lt;String&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;List&lt;String&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//路径中先添加起始点cur</span></span><br><span class="line">    path.add(cur);</span><br><span class="line">    <span class="keyword">if</span> (to.equals(cur)) &#123;</span><br><span class="line">        <span class="comment">//找到目标str了，生成新list添加进去</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;String&gt;(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取起始点的邻居表</span></span><br><span class="line">        <span class="keyword">for</span> (String next : nexts.get(cur)) &#123;</span><br><span class="line">            <span class="comment">//要求起始点cur到出发到next的距离是严格递增的，不能往回走，往回走则表示它肯定不是最短的</span></span><br><span class="line">            <span class="comment">//等同于过滤掉了较长的回环路径</span></span><br><span class="line">            <span class="keyword">if</span> (distances.get(next) == distances.get(cur) + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//符合要求的邻居，递归去吧</span></span><br><span class="line">                getShortestPaths(next, to, nexts, distances, path, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深度优先遍历擦出轨迹，还原现场</span></span><br><span class="line">    path.pollLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个数组的异或和是指数组中所有的数异或在一起的结果</span><br><span class="line">给定一个数组arr，求最大子数组异或和。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解法一：O(N^2)</span><br><span class="line">生成eor[0..i]的异或和数组 &#x3D; eor[0..2] ^ eor[3..i]  </span><br><span class="line">所以eor[3..i] &#x3D; eor[0..2] ^ eor[0..i] ，因为 同样的数字异或之后等于0，所以eor[0..2]被消除了</span><br><span class="line">通过这样求出了所有以i结尾的数组的最大异或和</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxXorSubarray1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备一个前缀异或和数组eor</span></span><br><span class="line">    <span class="comment">// eor[i] = arr[0...i]的异或结果</span></span><br><span class="line">    <span class="keyword">int</span>[] eor = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    eor[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 生成eor数组，eor[i]代表arr[0..i]的异或和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor[i] = eor[i - <span class="number">1</span>] ^ arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">//求以j结尾的异或和数组的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 依次尝试arr[0..j]、arr[1..j]..arr[i..j]..arr[j..j]</span></span><br><span class="line">        <span class="comment">//求 eor[i,j] = eor[0,j] ^ eor[0,i-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123; </span><br><span class="line">            max = Math.max(max, i == <span class="number">0</span> ? eor[j] : eor[j] ^ eor[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">解法二：O(N)</span><br><span class="line">假设eor[0..i]的异或和 &#x3D; 0110，由于异或和的不确定性，所以无法很快筛选出以i结尾时，它的最大异或和是什么?</span><br><span class="line">将eor[0..i-1]的结果都添加到前缀树中，根据前缀树筛选出一个和eor[0..i]异或之后，最大的值</span><br><span class="line">前缀树中默认需要添加0000的前缀分支</span><br><span class="line"></span><br><span class="line">假设eor[0..1] &#x3D; 1010 eor[0..2] &#x3D; 0101 eor[0..i] &#x3D; 0110</span><br><span class="line">【0110】根据前缀树中，挑选出它最期望遇到的能让他变得更大的值，照顾高位先变1</span><br><span class="line">在不考虑符号位的情况下，它希望第一位是1,第二位和第三位是0，第四位是1，才能达到1111的最大值</span><br><span class="line">所以前缀树优先找第一位是【1】，第二、三位是【0】的异或和</span><br><span class="line">由于前缀树中没有[1001]开头的路径，所以选择最匹配的则是[1010]，这个[1010]对应的是eor[0..1]</span><br><span class="line"></span><br><span class="line">那么以i位置的最大异或和肯定是 eor[0..i] ^ eor[0..1] &#x3D; eor[2..i]</span><br><span class="line"></span><br><span class="line">在考虑符号位的情况下，若最高位是0，它最期望遇到的最高位也是0</span><br><span class="line">若有负数，则同理，最高位期待和自己相同的符号位</span><br><span class="line">若最高位符号位是1，也是优先照顾高位先变成1，因为负数是 整数 取反码 加一</span><br><span class="line"></span><br><span class="line">所以最终的贪心策略：</span><br><span class="line">1.期望遇到相同的符号位</span><br><span class="line">2.优先让高位（非符号位）变成1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxXorSubarray2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>; <span class="comment">// 0..i 异或和</span></span><br><span class="line">    <span class="comment">// 前缀树 -&gt; numTrie</span></span><br><span class="line">    NumTrie numTrie = <span class="keyword">new</span> NumTrie();</span><br><span class="line">    numTrie.add(<span class="number">0</span>); <span class="comment">// 一个数也没有的时候，异或和是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor ^= arr[i]; <span class="comment">// eor -&gt; 0..i异或和</span></span><br><span class="line">        <span class="comment">// X, 0~0 , 0~1, .., 0~i-1</span></span><br><span class="line">        max = Math.max(max, numTrie.maxXor(eor));</span><br><span class="line">        numTrie.add(eor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀树的节点类型，每个节点向下只可能有走向0或1的路</span></span><br><span class="line"><span class="comment">// node.nexts[0] == null 0方向没路</span></span><br><span class="line"><span class="comment">// node.nexts[0] != null 0方向有路</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node[] nexts = <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于本题，定制前缀树的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NumTrie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">public</span> Node head = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把某个数字newNum加入到这棵前缀树里</span></span><br><span class="line">    <span class="comment">// num是一个32位的整数，所以加入的过程一共走32步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> move = <span class="number">31</span>; move &gt;= <span class="number">0</span>; move--) &#123;</span><br><span class="line">            <span class="comment">// 从高位到低位，取出每一位的状态，如果当前状态是0，</span></span><br><span class="line">            <span class="comment">// path(int) = 0</span></span><br><span class="line">            <span class="comment">// ，如果当前状态是1</span></span><br><span class="line">            <span class="comment">// path(int) = 1</span></span><br><span class="line">            <span class="keyword">int</span> path = ((newNum &gt;&gt; move) &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 无路新建、有路复用</span></span><br><span class="line">            cur.nexts[path] = cur.nexts[path] == <span class="keyword">null</span> ? <span class="keyword">new</span> Node() : cur.nexts[path];</span><br><span class="line">            cur = cur.nexts[path];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该结构之前收集了一票数字，并且建好了前缀树</span></span><br><span class="line">    <span class="comment">// sum,和 谁 ^ 最大的结果（把结果返回）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxXor</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> move = <span class="number">31</span>; move &gt;= <span class="number">0</span>; move--) &#123;</span><br><span class="line">            <span class="comment">//move位置上是1还是0</span></span><br><span class="line">            <span class="keyword">int</span> path = (sum &gt;&gt; move) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 期待的路</span></span><br><span class="line">            <span class="comment">//若move == 31，则表示符号位，我期待和path相同的值</span></span><br><span class="line">            <span class="comment">//若不是，则我期待和他相反的值，因为 0 ^ 1 = 1</span></span><br><span class="line">            <span class="keyword">int</span> best = move == <span class="number">31</span> ? path : (path ^ <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 前缀树中实际走的路,</span></span><br><span class="line">            best = cur.nexts[best] != <span class="keyword">null</span> ? best : (best ^ <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// (path ^ best) 当前位位异或完的结果，赋值到res的第move位中</span></span><br><span class="line">            res |= (path ^ best) &lt;&lt; move;</span><br><span class="line">            cur = cur.nexts[best];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组arr，哪一种划分下一个数组异或和为零的部分最多，返回最多能划分出几块异或和为零的部分</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">思路：假设答案法</span><br><span class="line">一个数组arr:</span><br><span class="line">0~0范围上最多能划分出几个异或和子数组</span><br><span class="line">0~1范围上最多能划分出几个异或和子数组</span><br><span class="line">0~2范围上最多能划分出几个异或和子数组</span><br><span class="line">...</span><br><span class="line">0~N-1范围上最多能划分出几个异或和子数组</span><br><span class="line"></span><br><span class="line">假设0..i上的一种切法, 假设这种切法下, 异或和为零的子数组部分最多</span><br><span class="line">按照结尾来划分可能性</span><br><span class="line">i位置的数一定是最后一个部分的最后一个数</span><br><span class="line"></span><br><span class="line">可能性一：</span><br><span class="line">i位置的数所在最后一个部分不是异或和为零  -&gt; dp[0..i] &#x3D; dp[0..i - 1]</span><br><span class="line"></span><br><span class="line">可能性二：</span><br><span class="line">i位置的数所在最后一个部分是异或和为零</span><br><span class="line">假设以j开头, [j..i] 中间 不可能存在一个k, 让k...i异或和为零,j一定是i的左边离i最近的一个开头</span><br><span class="line">那么dp[0..i] &#x3D; dp[0..j] + 1</span><br><span class="line"></span><br><span class="line">如果0~i的整体异或和是 1000, 怎么找这个j?</span><br><span class="line">计算某个区间[0..i]上,最晚出现异或和 &#x3D; 1000 的位置k，那么 j &#x3D; k + 1， eor[j..i] &#x3D; 0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostEOR</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">// dp[i] = 0</span></span><br><span class="line">    <span class="comment">//用来缓存每个异或和的结果对应出现的最晚位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//最左边的边界值，整体异或和 = 0时的判断</span></span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum ^= arr[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(sum)) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = map.get(sum);</span><br><span class="line">            <span class="comment">//若整体异或和=0，且边界在最左边，则dp[i]=1</span></span><br><span class="line">            dp[i] = pre == -<span class="number">1</span> ? <span class="number">1</span> : (dp[pre] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储最晚出现异或和的位置，若出现0，会把最左边-1的边界给更新</span></span><br><span class="line">        map.put(sum, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个只由 0(假)、1(真)、&amp;(逻辑与)、|(逻辑或)和^(异或)五种字符组成 的字符串express</span><br><span class="line">再给定一个布尔值 desired。返回express能有多少种组合 方式，可以达到desired的结果。</span><br><span class="line">【举例】</span><br><span class="line">express&#x3D;&quot;1^0|0|1&quot;，desired&#x3D;false</span><br><span class="line">只有 1^((0|0)|1)和 1^(0|(0|1))的组合可以得到 false，返回 2。 express&#x3D;&quot;1&quot;，desired&#x3D;false</span><br><span class="line">无组合则可以得到false，返回0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">思路：假设答案法</span><br><span class="line">根据题意：</span><br><span class="line">偶数位置必须是数字，奇数位置必须是运算符号，长度必须为奇数</span><br><span class="line"></span><br><span class="line">分解：假设每一个符号都是最后结合</span><br><span class="line">假设必须以i位置的&amp; 做最后一步二元结合的符号的情况下, 答案是几种?</span><br><span class="line">1.期望True:</span><br><span class="line">  [L..i-1]是T，结果A种，[i+1..R]是T，结果B种 数量：A*B种</span><br><span class="line">2.期望False:</span><br><span class="line">  [L..i-1]是T，结果A种，[L..i-1]是F，结果B种</span><br><span class="line">  [i+1..R]是T，结果C种，[i+1..R]是F，结果D种</span><br><span class="line">  数量： A*D + B*C + B*D</span><br><span class="line">【|】和【^】符号同理推算</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num1</span><span class="params">(String express, <span class="keyword">boolean</span> desired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (express == <span class="keyword">null</span> || express.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] exp = express.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(exp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(exp, desired, <span class="number">0</span>, exp.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exp[L..R] 返回期待为desired的方法数</span></span><br><span class="line"><span class="comment">// 潜台词：L R 必须是偶数位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>[] exp, <span class="keyword">boolean</span> desired, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">if</span> (exp[L] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// '0'</span></span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// L..R</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (desired) &#123; <span class="comment">// 期待为true</span></span><br><span class="line">        <span class="comment">// i位置尝试L..R范围上的每一个逻辑符号，都是最后结合的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// exp[i] 一定压中逻辑符号</span></span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 期待为false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                    res += f(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += f(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * f(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验是否有效字符串，判断奇数是否是符号位，偶数是否是数字，长度是否是奇数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[] exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((exp.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exp[i] != <span class="string">'1'</span>) &amp;&amp; (exp[i] != <span class="string">'0'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((exp[i] != <span class="string">'&amp;'</span>) &amp;&amp; (exp[i] != <span class="string">'|'</span>) &amp;&amp; (exp[i] != <span class="string">'^'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dpLive</span><span class="params">(String express, <span class="keyword">boolean</span> desired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = express.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="keyword">int</span>[][] tMap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">int</span>[][] fMap = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        tMap[i][i] = str[i] == <span class="string">'1'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        fMap[i][i] = str[i] == <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = N - <span class="number">3</span>; row &gt;= <span class="number">0</span>; row -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">2</span>; col &lt; N; col += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// row..col tMap fMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt; col; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                        tMap[row][col] += tMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                        tMap[row][col] += tMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        tMap[row][col] += fMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        tMap[row][col] += tMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                        tMap[row][col] += tMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        tMap[row][col] += fMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">                        fMap[row][col] += fMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        fMap[row][col] += tMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        fMap[row][col] += fMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">                        fMap[row][col] += fMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line">                        fMap[row][col] += tMap[row][i - <span class="number">1</span>] * tMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        fMap[row][col] += fMap[row][i - <span class="number">1</span>] * fMap[i + <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desired ? tMap[<span class="number">0</span>][N-<span class="number">1</span>]  : fMap[<span class="number">0</span>][N-<span class="number">1</span>];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给出一组正整数arr，你从第0个数向最后一个数，</span><br><span class="line">每个数的值表示你从这个位置可以向右跳跃的最大长度</span><br><span class="line">计算如何以最少的跳跃次数跳到最后一个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划 从左往右模型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 跳了多少步</span></span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>; <span class="comment">// step步内，最右的边界</span></span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;<span class="comment">// step+1步内，最右的边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//如果当前i超过了cur的边界，则增加一步，并且把下一步的边界赋值到cur上</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; i) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//step步内能到达的点，它下一跳，能跳到多远：i + arr[i]</span></span><br><span class="line">        next = Math.max(next, i + arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个字符串至少切几刀,能让切出来的部分全是回文串</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思路:</span><br><span class="line">[0..0]..[0..1]...[0..N-1]</span><br><span class="line">[1..1]..[1..2]...[1..N-1]</span><br><span class="line">以每个i做切割,时间复杂度O(N^2),再加上需要再遍历一遍判断区间内的字符串是否是回文O(N)</span><br><span class="line">所以总复杂度O(N^3)</span><br><span class="line"></span><br><span class="line">可以通过先做dp表，标记所有[L..R]上的字符是否是回文，阶数减一阶</span><br><span class="line">是回文的条件：arr[L] &#x3D;&#x3D; arr[R] &amp;&amp; [L+1][R-1]是回文(查dp表)</span><br><span class="line">dp表优先填写对角线</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minParts</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] isP = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">    <span class="comment">//一个字符，必定回文</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        isP[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填写第二条对角线，L和R都是一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        isP[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从第三条对小件开始填起</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = N - <span class="number">3</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">2</span>; col &lt; N; col++) &#123;</span><br><span class="line">            isP[row][col] = str[row] == str[col] &amp;&amp; isP[row + <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//end..N-1需要用到N的值，补个长度0</span></span><br><span class="line">    dp[N] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = i; end &lt; N; end++) &#123;</span><br><span class="line">            <span class="comment">// i..end</span></span><br><span class="line">            <span class="keyword">if</span> (isP[i][end]) &#123;</span><br><span class="line">                <span class="comment">//若是回文，他的回文等于end + 1的回文数 + 1</span></span><br><span class="line">                dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[end + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定两个有序数组arr1和arr2，再给定一个正数K</span><br><span class="line"></span><br><span class="line">求两个数累加和最大的前K个，两个数必须分别来自arr1和arr2</span><br><span class="line">如arr1&#x3D;&#123;3,5,7,9&#125; arr2&#x3D;&#123;2,4,8,10&#125; K &#x3D; 3</span><br><span class="line">结果:&#123;9+10,9+8,7+8&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">arr1和arr2建立一张二维表，用来存储arr1和arr2对应下标数值的和</span><br><span class="line">那么右下角[N-1][M-1]&#x3D;arr1[N-1] + arr2[M-1]必然是最大的，因为有序</span><br><span class="line">然后准备个大根堆，将右下角的点先写入大根堆中</span><br><span class="line">然后依次弹出大根堆的堆顶做答案，并写入该点左边和上边的两个点</span><br><span class="line">假设大根堆弹出的点位置是[i][j]，将[i-1][j]和[i][j-1]放入大根堆中</span><br><span class="line"></span><br><span class="line">需要注意：要保证同一个点的数据不能重复进入大根堆中</span><br><span class="line">时间复杂度O(N * logK)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放入大根堆中的结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index1;<span class="comment">// arr1中的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index2;<span class="comment">// arr2中的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sum;<span class="comment">// arr1[index1] + arr2[index2]的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        index1 = i1;</span><br><span class="line">        index2 = i2;</span><br><span class="line">        sum = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成大根堆的比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxHeapComp</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.sum - o1.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] topKSum(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2, <span class="keyword">int</span> topK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> || arr2 == <span class="keyword">null</span> || topK &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// topK过滤，最多只能提供N * M 个</span></span><br><span class="line">    topK = Math.min(topK, arr1.length * arr2.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[topK];</span><br><span class="line">    <span class="keyword">int</span> resIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Node&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxHeapComp());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set[i][j] == false, arr1[i]  arr2[j] 之前，没进过</span></span><br><span class="line">    <span class="comment">// set[i][j] == true;  arr1[i]  arr2[j] 之前，进过</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] set = <span class="keyword">new</span> <span class="keyword">boolean</span>[arr1.length][arr2.length];</span><br><span class="line">    <span class="keyword">int</span> i1 = arr1.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = arr2.length - <span class="number">1</span>;</span><br><span class="line">    maxHeap.add(<span class="keyword">new</span> Node(i1, i2, arr1[i1] + arr2[i2]));</span><br><span class="line">    set[i1][i2] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (resIndex != topK) &#123;</span><br><span class="line">        Node curNode = maxHeap.poll();</span><br><span class="line">        <span class="comment">//收集答案</span></span><br><span class="line">        res[resIndex++] = curNode.sum;</span><br><span class="line">        i1 = curNode.index1;</span><br><span class="line">        i2 = curNode.index2;</span><br><span class="line">        <span class="keyword">if</span> (i1 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !set[i1 - <span class="number">1</span>][i2]) &#123;</span><br><span class="line">            set[i1 - <span class="number">1</span>][i2] = <span class="keyword">true</span>;</span><br><span class="line">            maxHeap.add(<span class="keyword">new</span> Node(i1 - <span class="number">1</span>, i2, arr1[i1 - <span class="number">1</span>] + arr2[i2]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i2 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !set[i1][i2 - <span class="number">1</span>]) &#123;</span><br><span class="line">            set[i1][i2 - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            maxHeap.add(<span class="keyword">new</span> Node(i1, i2 - <span class="number">1</span>, arr1[i1] + arr2[i2 - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个正数数组arr，返回该数组能不能分成<span class="number">4</span>个部分，并且每个部分的累加和相等，切分位置的数不要。</span><br><span class="line">例如:</span><br><span class="line">arr=[<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>] 返回<span class="keyword">true</span></span><br><span class="line">三个切割点下标为<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>. 切出的四个子数组为[<span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]，</span><br><span class="line">累加和都是<span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">根据题意，arr.length &gt; 7，且第一个切割点 1 &lt; i &lt; length - 6，否则无法满足</span><br><span class="line">先建立hash表,Key是0..i的累加和sum，Value是对应的index</span><br><span class="line">i &#x3D; 1 开始枚举每个下标做切割点</span><br><span class="line">尝试hash.get(sum[0..i-1]) &#x3D; V的情况下，是否存在第二个切割点：j &#x3D; hash.get(sum[2V + arr[i]])</span><br><span class="line">以此类推，第三个切割点k &#x3D; 3V + arr[i] + arr[j]...</span><br><span class="line"></span><br><span class="line">时间复杂度：O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canSplits2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key 某一个累加和， value出现的位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> sum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        map.put(sum, i);</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lsum = arr[<span class="number">0</span>]; <span class="comment">// 第一刀左侧的累加和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">1</span>; s1 &lt; arr.length - <span class="number">5</span>; s1++) &#123; <span class="comment">// s1是第一刀的位置</span></span><br><span class="line">        <span class="keyword">int</span> checkSum = lsum * <span class="number">2</span> + arr[s1]; <span class="comment">// 100 x 100   100*2 + x</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(checkSum)) &#123;</span><br><span class="line">            <span class="keyword">int</span> s2 = map.get(checkSum); <span class="comment">// j -&gt; y</span></span><br><span class="line">            checkSum += lsum + arr[s2];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(checkSum)) &#123; <span class="comment">// 100 * 3 + x + y</span></span><br><span class="line">                <span class="keyword">int</span> s3 = map.get(checkSum); <span class="comment">// k -&gt; z</span></span><br><span class="line">                <span class="keyword">if</span> (checkSum + arr[s3] + lsum == sum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lsum += arr[s1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定三个字符串str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符</span><br><span class="line">而且在aim中属于str1的字符之间保持原来在str1中的顺序，</span><br><span class="line">属于str2的字符之间保持原来在str2中的顺序</span><br><span class="line">那么称aim是str1和str2的交错组成。实现一个函数，判断aim是 否是str1和str2交错组成</span><br><span class="line">【举例】 str1&#x3D;&quot;AB&quot;，str2&#x3D;&quot;12&quot;。</span><br><span class="line">那么&quot;AB12&quot;、&quot;A1B2&quot;、&quot;A12B&quot;、&quot;1A2B&quot;和&quot;1AB2&quot;等都是 str1 和 str2 的 交错组成</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">动态规划二维表dp[N+1][M+1]，value存储布尔值</span><br><span class="line">dp[i][j]含义：</span><br><span class="line">  str1拿出前缀i长度, 对应下标 [0..i-1] </span><br><span class="line">  str2拿出前缀j长度, 对应下标 [0..j-1]</span><br><span class="line">  能否交错组成str3的前缀[i+j]长度</span><br><span class="line"></span><br><span class="line">先填第一行第一列：拿str1和str2去和str3做比较，前缀相等则True，若出现一个Flase，后面全是False</span><br><span class="line">然后一行一行得填写，最后取出答案dp[N][M]</span><br><span class="line"></span><br><span class="line">可能性：</span><br><span class="line">1.str3[i+j-1] &#x3D;&#x3D; str1[i] &amp;&amp; dp[i][j] &#x3D; dp[i-1][j] --&gt;True</span><br><span class="line">2.str3[i+j-1] &#x3D;&#x3D; str1[j] &amp;&amp; dp[i][j] &#x3D; dp[i][j-1] --&gt;True</span><br><span class="line">3.否则False</span><br><span class="line"></span><br><span class="line">该题的动态规划依赖了[i,j]的左边的值和上边的值，可以进行动态规划空间压缩技巧，使用一个一维数组</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCross1</span><span class="params">(String s1, String s2, String ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || ai == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] str2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] aim = ai.toCharArray();</span><br><span class="line">    <span class="comment">//长度不等直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (aim.length != str1.length + str2.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[str1.length + <span class="number">1</span>][str2.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//填写第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1[i - <span class="number">1</span>] != aim[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填写第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= str2.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str2[j - <span class="number">1</span>] != aim[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp规划</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= str2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (	</span><br><span class="line">                (str1[i - <span class="number">1</span>] == aim[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j])</span><br><span class="line">                || </span><br><span class="line">                (str2[j - <span class="number">1</span>] == aim[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>])	</span><br><span class="line">            ) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;					</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[str1.length][str2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序数组arr，如果只能再一个子数组上排序</span><br><span class="line"></span><br><span class="line">返回如果让arr整体有序，需要排序的最短子数组长度</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">从左往右遍历，记录更新i左边的最大值。若i &lt; max，记录最靠近右边 &lt; max 的i位置 -&gt; 确定了[i+1..N]无需调整</span><br><span class="line">从右往左遍历，记录更新j右边的最小值。若j &gt; max，记录最靠近坐边 &gt; max 的j位置 -&gt; 确定了[0..j-1]无需调整</span><br><span class="line">区间[j,i]就是需要排序的数组</span><br><span class="line"></span><br><span class="line">时间复杂度O(N)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinLength</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> noMinIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; min) &#123;</span><br><span class="line">            noMinIndex = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (noMinIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> noMaxIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; max) &#123;</span><br><span class="line">            noMaxIndex = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> noMaxIndex - noMinIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个正数数组 arr，其中所有的值都为整数，以下是最小不可组成和的概念:</span><br><span class="line">把 arr 每个子集内的所有元素加起来会出现很多值，其中最小的记为 min，最大的记为max 在区间[min,max]上</span><br><span class="line">如果有数不可以被arr某一个子集相加得到，那么其中最小的那个数是arr 的最小不可组成和 在区间[min,max]上</span><br><span class="line">如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最 小不可组成和</span><br><span class="line">请写函数返回正数数组 arr 的最小不可组成和。</span><br><span class="line"></span><br><span class="line">【举例】</span><br><span class="line">arr&#x3D;[3,2,5]。子集&#123;2&#125;相加产生 2 为 min，子集&#123;3,2,5&#125;相加产生 10 为 max。</span><br><span class="line">在区间[2,10] 上，4、 6 和 9 不能被任何子集相加得到，其中 4 是 arr 的最小不可组成和。 </span><br><span class="line">arr&#x3D;[1,2,4]。子集&#123;1&#125;相加产生 1 为 min，子集&#123;1,2,4&#125;相加产生 7 为 max。</span><br><span class="line">在区间[1,7]上， 任何 数都可以被子集相加得到，所以 8 是 arr 的最小不可组成和。</span><br><span class="line"></span><br><span class="line">【进阶】</span><br><span class="line">如果已知正数数组 arr 中肯定有 1 这个数，是否能更快地得到最小不可组成和?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">问题一：</span><br><span class="line">经典的背包问题</span><br><span class="line">arr数组的index做样本的行，sum[0..N-1]做样本的列，dp[i][j]&#x3D;True&#x2F;False</span><br><span class="line">等同于背包问题的w[]做行，bag做列</span><br><span class="line">最后结果 &#x3D; dp[N-1][0..sum]中为False的数据</span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line">先让arr有序，1一定是落在第一个位置，定义一个range变量</span><br><span class="line">若arr[i] &lt;&#x3D; range + 1 ，则 range +&#x3D; arr[i] 表示从[min...range]范围内都能够通过累加得到</span><br><span class="line">若arr[i] &gt; range + 1，表示往后的arr[i]肯定都是更大的，所以最小不可组成和 &#x3D; range + 1</span><br><span class="line">若遍历完集合都达标，则最小不可组成和 &#x3D; range + 1，因为此时的range达到了所有数组的累加和大小max</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知arr中肯定有1这个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unformedSum3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr); <span class="comment">// O (N * logN)</span></span><br><span class="line">    <span class="keyword">int</span> range = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; range + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            range += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> range + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个有序的正数数组arr和一个正数aim，如果可以自由选择arr中的数字，想累加得 到 1~aim 范围上所有的数，返回arr最少还缺几个数。</span><br><span class="line">【举例】</span><br><span class="line">arr &#x3D; &#123;1,2,3,7&#125;， aim &#x3D; 15</span><br><span class="line">想累加得到 1~15 范围上所有的数，arr 还缺 14 这个数，所以返回1 </span><br><span class="line">arr &#x3D; &#123;1,5,7&#125;， aim &#x3D; 15</span><br><span class="line">想累加得到 1~15 范围上所有的数，arr 还缺 2 和 4，所以返回2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">借用上题的思路，arr[i] &gt; range时，缺啥补啥，比如补range + 1的值，然后range +&#x3D; range + 1</span><br><span class="line">再次比较arr[i]..周而复始</span><br><span class="line">若arr遍历完了，range还没达到aim，接着扩补数字接着扩</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr请保证有序，且正数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> patches = <span class="number">0</span>; <span class="comment">// 缺多少个数字</span></span><br><span class="line">    <span class="keyword">long</span> range = <span class="number">0</span>; <span class="comment">// 已经完成了1 ~ range的目标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 1~range</span></span><br><span class="line">        <span class="comment">// 1 ~ arr[i]-1</span></span><br><span class="line">        <span class="keyword">while</span> (arr[i] &gt; range + <span class="number">1</span>) &#123; <span class="comment">// arr[i] 1 ~ arr[i]-1</span></span><br><span class="line">            range += range + <span class="number">1</span>; <span class="comment">// range + 1 是缺的数字</span></span><br><span class="line">            patches++;</span><br><span class="line">            <span class="keyword">if</span> (range &gt;= aim) &#123;</span><br><span class="line">                <span class="keyword">return</span> patches;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        range += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (range &gt;= aim) &#123;</span><br><span class="line">            <span class="keyword">return</span> patches;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (aim &gt;= range + <span class="number">1</span>) &#123;</span><br><span class="line">        range += range + <span class="number">1</span>;</span><br><span class="line">        patches++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> patches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在一个字符串中找到没有重复字符子串中最长的长度。</span><br><span class="line">例如:</span><br><span class="line">abcabcbb没有重复字符的最长子串是abc，长度为3 </span><br><span class="line">bbbbb，答案是b，长度为1</span><br><span class="line">pwwkew，答案是wke，长度是3</span><br><span class="line">要求:答案必须是子串，&quot;pwke&quot; 是一个子字符序列但不是一个子字符串。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">遇到子串、子序列，优先想到的是以i开头....以i结尾...的dp表</span><br><span class="line">建个map缓存 arr[i]上一次出现的位置</span><br><span class="line">dp[i]表示以i结尾，最长无重复字符子串的长度</span><br><span class="line">dp[i] &#x3D; Math.min(arr[i]上一次出现的位置, i - dp[i-1])</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxUnique</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        pre = Math.max(indexMap.getOrDefault(chars[i], -<span class="number">1</span>), pre);</span><br><span class="line">        max = Math.max(max, i - pre);</span><br><span class="line">        indexMap.put(chars[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个数组中，如果两个数的公共因子有大于1的，则认为这两个数之间有通路</span><br><span class="line">返回数组中，有多少个独立的域</span><br><span class="line">如：[10,5,7,4]， 有两个独立的域</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">解法一：</span><br><span class="line">每个数都是并查集的集合，判断每个数下标开始到数组结束，两两是否有公共因子，有则合并，时间复杂度O(N^2)</span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">假设arr里的数值范围不是很大，算出每个数的[质数因子,index]，相同的质数因子通过并查集合并。</span><br><span class="line">假设一个数V，判断一个数是否是质数，时间复杂度O(V)，得到V的质数因子O(根号V)，所以整体复杂度O(N * V)</span><br><span class="line"></span><br><span class="line">所以解法一和解法二的权衡在于N和V哪个大</span><br><span class="line"></span><br><span class="line">解法三：</span><br><span class="line">将一个数拆成多对，比如100，根号100 &#x3D; 10，从1开始试到10就停。</span><br><span class="line">[2,50]、[4,25]、[5,20]、[10、10]，并查集中有相同因子，则合并。</span><br><span class="line">获得键值对的代价是O(根号V)，所以总代价是O(N * 根号V)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求两个数的最大公约数，辗转相除法，背！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? m : gcd(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：</span></span><br><span class="line"><span class="comment">// arr中没有小于1的数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    UnionFindSet1 set = <span class="keyword">new</span> UnionFindSet1(arr.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gcd(arr[i], arr[j]) != <span class="number">1</span>) &#123;</span><br><span class="line">                set.union(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.maxSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestComponentSize2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    UnionFindSet2 unionFind = <span class="keyword">new</span> UnionFindSet2(arr.length);</span><br><span class="line">    <span class="comment">// key 是某一个因子，</span></span><br><span class="line">    <span class="comment">// value 是包含key因子的，其中一个数的位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; fatorsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = arr[i];</span><br><span class="line">        <span class="keyword">int</span> limit = (<span class="keyword">int</span>) Math.sqrt(num); <span class="comment">// 1 ~ 根号num</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= limit; j++) &#123; <span class="comment">// j是现在试的因子</span></span><br><span class="line">            <span class="keyword">if</span> (num % j == <span class="number">0</span>) &#123; <span class="comment">// num含有j的因子</span></span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">1</span>) &#123; <span class="comment">// 这个因子不是1</span></span><br><span class="line">                    <span class="comment">// j</span></span><br><span class="line">                    <span class="keyword">if</span> (!fatorsMap.containsKey(j)) &#123; <span class="comment">// 当前数是含有j因子的第一个数</span></span><br><span class="line">                        fatorsMap.put(j, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        unionFind.union(fatorsMap.get(j), i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> other = num / j; <span class="comment">// other * j == num</span></span><br><span class="line">                <span class="keyword">if</span> (other != <span class="number">1</span>) &#123; <span class="comment">// num含有other的因子</span></span><br><span class="line">                    <span class="keyword">if</span> (!fatorsMap.containsKey(other)) &#123;</span><br><span class="line">                        fatorsMap.put(other, i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        unionFind.union(fatorsMap.get(other), i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unionFind.maxSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并让 最终结果字符串的字典序最小</span><br><span class="line">【举例】</span><br><span class="line">str &#x3D; &quot;acbc&quot;，删掉第一个&#39;c&#39;，得到&quot;abc&quot;，是所有结果字符串中字典序最小的。</span><br><span class="line">str &#x3D; &quot;dbcacbca&quot;，删掉第一个&#39;b&#39;、第一个&#39;c&#39;、第二个&#39;c&#39;、第二个&#39;a&#39;，得到&quot;dabc&quot;， 是所有结 果字符串中字典序最小的。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">贪心思路：</span><br><span class="line">统计词频，然后从左往右依次遍历字符，遍历到的词，词频--</span><br><span class="line">假设遍历到i位置时，某个字母词频为0，这时候停下来，第一个字符在[0..i]位置上挑</span><br><span class="line">挑[0,i]位置上，字典序最小，且index最小的字母，假设字母 &#x3D; &#39;a&#39;,index &#x3D; k</span><br><span class="line">那么大于k的位置的&#39;a&#39;全部删掉，在[k+1,N-1]的范围上接着周二复始跳第二个字母</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">str &#x3D; &quot;daccbdbaccdbba&quot;</span><br><span class="line">次数统计：</span><br><span class="line">a : 3	b : 4	c : 4	d : 3</span><br><span class="line">遍历到&quot;daccbdbacc&quot; 时停，因为这时候后面 &#39;c&#39; 词频 &#x3D; 0，在里面中挑出 最小字母&#39;a&#39;，index &#x3D; 1</span><br><span class="line">重新计算 str &#x3D; “ccbdbccdbb” 周而复始，挑第二个字母</span><br><span class="line"></span><br><span class="line">假设有K种字符，str长度是N，要挑K次，所以时间复杂度O(N * K)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在str中，每种字符都要保留一个，让最后的结果，字典序最小 ，并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">remove</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//统计词频</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>;i&lt; str.length();i++) &#123;</span><br><span class="line">        map[str.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minACSIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length();i++) &#123;</span><br><span class="line">        <span class="comment">//减少到0 break</span></span><br><span class="line">        <span class="keyword">if</span>(--map[str.charAt(i)] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//顺便计算最小的字母是什么，若重复，存储的是第一个index</span></span><br><span class="line">            minACSIndex = str.charAt(minACSIndex) &gt; str.charAt(i) ? i : minACSIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(str.charAt(minACSIndex)) + </span><br><span class="line">        remove (   </span><br><span class="line">        str</span><br><span class="line">        .substring(minACSIndex+<span class="number">1</span>)</span><br><span class="line">        .replaceAll(String.valueOf(str.charAt(minACSIndex)), <span class="string">""</span>)   </span><br><span class="line">    )</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定两个数组arrx和arry，长度都为N。代表二维平面上有N个点，第i个点的x 坐标和y坐标分别为arrx[i]和arry[i]，返回求一条直线最多能穿过多少个点?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">以每个点(x,y)为必须经过的点，计算：</span><br><span class="line">1.和(x,y)重合的点数量</span><br><span class="line">2.相同 x坐标的点的数量</span><br><span class="line">3.相同 y坐标的点的数量</span><br><span class="line">4.相同斜率的点的数量</span><br><span class="line">这个点经过的最多的点 &#x3D; Max(2,3,4)情况 + 1情况</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (points.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> points.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key：分子  value：分母表  表示斜率</span></span><br><span class="line">    Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Map&lt;Integer, Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">        <span class="keyword">int</span> samePosition = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sameX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sameY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = points[j].x - points[i].x;</span><br><span class="line">            <span class="keyword">int</span> y = points[j].y - points[i].y;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                samePosition++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                sameX++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">                sameY++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> gcd = gcd(x, y);</span><br><span class="line">                x /= gcd;</span><br><span class="line">                y /= gcd;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(x)) &#123;</span><br><span class="line">                    map.put(x, <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!map.get(x).containsKey(y)) &#123;</span><br><span class="line">                    map.get(x).put(y, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(x).put(y, map.get(x).get(y) + <span class="number">1</span>);</span><br><span class="line">                line = Math.max(line, map.get(x).get(y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Math.max(result, Math.max(Math.max(sameX, sameY), line) + samePosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证初始调用的时候，a和b不等于0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] d，d[i]：i号怪兽的能力</span><br><span class="line">int[] p，p[i]：i号怪兽要求的钱</span><br><span class="line">开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。</span><br><span class="line">如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。</span><br><span class="line">返回通过所有的怪兽，需要花的最小钱数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int[] d d[i]：i号怪兽的武力</span></span><br><span class="line"><span class="comment">// int[] p p[i]：i号怪兽要求的钱</span></span><br><span class="line"><span class="comment">// hp 当前你所具有的能力</span></span><br><span class="line"><span class="comment">// index 来到了第index个怪兽的面前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前，你的能力是hp，你来到了index号怪兽的面前，如果要通过后续所有的怪兽，</span></span><br><span class="line"><span class="comment">// 请返回需要花的最少钱数</span></span><br><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p, <span class="keyword">int</span> hp, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == d.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hp &lt; d[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> p[index] + process(d, p, hp + d[index], index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 可以贿赂，也可以不贿赂</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(p[index] + process(d, p, hp + d[index], index + <span class="number">1</span>), process(d, p, hp, index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(d, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上面解法暴力递归能改动态规划，以index为行，hp为列的二维数组，value存储花费的钱数，但是如果hp很大，这个dp表会很大</span><br><span class="line">可以用花费的钱数当列，dp[i][j] 表示[0..i]范围上，花了j块钱，当前的最大能力值</span><br><span class="line"></span><br><span class="line">可能性一：</span><br><span class="line">dp[i-1][j]能力大于i号怪兽，可以不花钱 也就是 dp[i-1][j] &gt; d[i]  --&gt; dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">可能性二：</span><br><span class="line">dp[i][j]，也就是严格花j块钱，当前i的怪兽需要花k块钱，那么，dp[i][j] &#x3D; d[i] + dp[i-1][j-k]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : p) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]含义：</span></span><br><span class="line">    <span class="comment">// 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？</span></span><br><span class="line">    <span class="comment">// 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[d.length][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的</span></span><br><span class="line">    dp[<span class="number">0</span>][p[<span class="number">0</span>]] = d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; d.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="comment">// 可能性一，为当前怪兽花钱</span></span><br><span class="line">            <span class="comment">// 存在条件：</span></span><br><span class="line">            <span class="comment">// j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= p[i] &amp;&amp; dp[i - <span class="number">1</span>][j - p[i]] != -<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - p[i]] + d[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可能性二，不为当前怪兽花钱</span></span><br><span class="line">            <span class="comment">// 存在条件：</span></span><br><span class="line">            <span class="comment">// 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= d[i]) &#123;</span><br><span class="line">                <span class="comment">// 两种可能性中，选武力值最大的</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp表最后一行上，dp[N-1][j]代表：</span></span><br><span class="line">    <span class="comment">// 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？</span></span><br><span class="line">    <span class="comment">// 那么最后一行上，最左侧的不为-1的列数(j)，就是答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[d.length - <span class="number">1</span>][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            ans = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，如果可以在字符串任意位置添加字符，最少添加几个能让字符串整体都是回文串。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">L做行，R做列的二维db表,dp[i][j]表示，str(i..j)位置上的字符串最少要多少个字符才是回文串</span><br><span class="line">L &gt; R的下半部分区域无效，对角线L &#x3D;&#x3D; R，必然都是 0 个字符</span><br><span class="line">第二条对角线 [0,1]..[1,2]，0位置字符等于1位置字符则 dp[0][1] &#x3D; 0,若不等，则补一个字符dp[0][1] &#x3D; 1...第二条对角线以此类推，要么0要么1</span><br><span class="line"></span><br><span class="line">dp[i][j]</span><br><span class="line">三种情况：</span><br><span class="line">dp[i][j] &#x3D; dp[i][j-1] + 1 &#x2F;&#x2F;j位置不动，搞定i..j-1位置，再补1个</span><br><span class="line">dp[i][j] &#x3D; dp[i+1][j] + 1 &#x2F;&#x2F;i位置不动，搞定i+1..j位置，再补1个</span><br><span class="line">dp[i][j] &#x3D; dp[i+1][j-1] &#x2F;&#x2F;只有刚好i位置字符 &#x3D; j位置的字符，才有这种情况</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPalindrome1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chas = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = getDP(chas);</span><br><span class="line">    <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[chas.length + dp[<span class="number">0</span>][chas.length - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = chas.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> resl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resr = res.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chas[i] == chas[j]) &#123;</span><br><span class="line">            res[resl++] = chas[i++];</span><br><span class="line">            res[resr--] = chas[j--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>] &lt; dp[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">            res[resl++] = chas[j];</span><br><span class="line">            res[resr--] = chas[j--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[resl++] = chas[i];</span><br><span class="line">            res[resr--] = chas[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDP(<span class="keyword">char</span>[] str) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str.length][str.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str.length; j++) &#123;</span><br><span class="line">        dp[j - <span class="number">1</span>][j] = str[j - <span class="number">1</span>] == str[j] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">2</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == str[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一种消息接收并打印的结构设计</span><br><span class="line">已知一个消息流会不断地吐出整数 1~N，但不一定按照顺序吐出。如果上次打印的数为 i， 那么当 i+1 出现时，请打印 i+1 及其之后接收过的并且连续的所有数，直到 1~N 全部接收 并打印完，请设计这种接收并打印的结构。</span><br><span class="line">初始时默认i&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String info;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        info = str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBox</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头尾链表</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; headMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; tailMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitPoint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageBox</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        headMap = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">        tailMap = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">        waitPoint = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息的编号，info消息的内容, 消息一定从1开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> num, String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(info);</span><br><span class="line">        <span class="comment">// num~num</span></span><br><span class="line">        headMap.put(num, cur);</span><br><span class="line">        tailMap.put(num, cur);</span><br><span class="line">        <span class="comment">// 建立了num~num这个连续区间的头和尾</span></span><br><span class="line">        <span class="comment">// 查询有没有某个连续区间以num-1结尾</span></span><br><span class="line">        <span class="keyword">if</span> (tailMap.containsKey(num - <span class="number">1</span>)) &#123;</span><br><span class="line">            tailMap.get(num - <span class="number">1</span>).next = cur;</span><br><span class="line">            tailMap.remove(num - <span class="number">1</span>);</span><br><span class="line">            headMap.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询有没有某个连续区间以num+1开头的</span></span><br><span class="line">        <span class="keyword">if</span> (headMap.containsKey(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            cur.next = headMap.get(num + <span class="number">1</span>);</span><br><span class="line">            tailMap.remove(num);</span><br><span class="line">            headMap.remove(num + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == waitPoint) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = headMap.get(waitPoint);</span><br><span class="line">        headMap.remove(waitPoint);</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(node.info + <span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">            waitPoint++;</span><br><span class="line">        &#125;</span><br><span class="line">        tailMap.remove(waitPoint-<span class="number">1</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现有n1+n2种面值的硬币，其中前n1种为普通币，可以取任意枚，后n2种为纪念币， 每种最多只能取一枚，每种硬币有一个面值，问能用多少种方法拼出m的面值?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">以普通币做行，面值做列，dp1[i][j]存储有多少种方法</span><br><span class="line">以纪念币做行，面值做列，dp2[i][j]存储有多少种方法</span><br><span class="line">最后结果：两个动态规划表的最后一行结果乘积</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">moneyWays</span><span class="params">(<span class="keyword">int</span>[] arbitrary, <span class="keyword">int</span>[] onlyone, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((arbitrary == <span class="keyword">null</span> || arbitrary.length == <span class="number">0</span>) &amp;&amp; (onlyone == <span class="keyword">null</span> || onlyone.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> money == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任意张 的数组， 一张的数组，不可能都没有</span></span><br><span class="line">    <span class="keyword">int</span>[][] dparb = getDpArb(arbitrary, money);</span><br><span class="line">    <span class="keyword">int</span>[][] dpone = getDpOne(onlyone, money);</span><br><span class="line">    <span class="keyword">if</span> (dparb == <span class="keyword">null</span>) &#123; <span class="comment">// 任意张的数组没有，一张的数组有</span></span><br><span class="line">        <span class="keyword">return</span> dpone[dpone.length - <span class="number">1</span>][money];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dpone == <span class="keyword">null</span>) &#123; <span class="comment">// 任意张的数组有，一张的数组没有</span></span><br><span class="line">        <span class="keyword">return</span> dparb[dparb.length - <span class="number">1</span>][money];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= money; i++) &#123;</span><br><span class="line">        res += dparb[dparb.length - <span class="number">1</span>][i] * dpone[dpone.length - <span class="number">1</span>][money - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDpArb(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> money) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][money + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// dp[i][j] 0..i券 自由选择张数， 搞定j元， 有多少方法？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0] 5元 0元 5元 10元 15元 20元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; arr[<span class="number">0</span>] * j &lt;= money; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>] * j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0行 0列 填完了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= money; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] += j - arr[i] &gt;= <span class="number">0</span> ? dp[i][j - arr[i]] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getDpOne(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> money) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][money + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &lt;= money) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= money; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i][j] += j - arr[i] &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - arr[i]] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个正数N，表示你在纸上写下1~N所有的数字</span><br><span class="line"></span><br><span class="line">返回在书写的过程中，一共写下了多少个1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">假设N的高位数是1的情况,假设N &#x3D; 13625， 将函数拆成:</span><br><span class="line">f(13625) &#x3D; (3626..13625)非递归的1次数 + f(3625)</span><br><span class="line">f(3625) &#x3D; (626..3625)非递归的1次数 + f(625)...依次递归下去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">求(3626..13625)非递归的1次数，13625的长度是k&#x3D;5:</span><br><span class="line">高位是1 ： N % 10^(k-1) + 1 （这是高位1固定的情况下，能得到的1）</span><br><span class="line">个十百千： (k-1) * 10^(k-2) (K-1表示个十百千，四种变化，后面10^3，表示固定某个1之后，其他三个位置的变化可能性)</span><br><span class="line">上面两种可能性相加，就是(3626..13625)范围上，1出现的次数</span><br><span class="line"></span><br><span class="line">假设N的高位不是1的情况，假设N &#x3D; 3625</span><br><span class="line">千位是1：必定是1000~1999，所以是10^(k-1)</span><br><span class="line">个十百：分段[626~1625]、[1626~2625]、[2626~3625]，个十百三个位置定一个是1，其他位置变化</span><br><span class="line">       所以是 千位数的值 * (K-1) * 10^(K-2)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num -&gt; 13625</span></span><br><span class="line">    <span class="comment">// len = 5位数</span></span><br><span class="line">    <span class="keyword">int</span> len = getLenOfNum(num);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// num 13625</span></span><br><span class="line">    <span class="comment">// tmp1 10000</span></span><br><span class="line">    <span class="comment">// num 7872328738273</span></span><br><span class="line">    <span class="comment">// tmp1 1000000000000</span></span><br><span class="line">    <span class="keyword">int</span> tmp1 = powerBaseOf10(len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// num最高位 num / tmp1</span></span><br><span class="line">    <span class="keyword">int</span> first = num / tmp1;</span><br><span class="line">    <span class="comment">// 最高1 N % tmp1 + 1</span></span><br><span class="line">    <span class="comment">// 最高位first tmp1</span></span><br><span class="line">    <span class="keyword">int</span> firstOneNum = first == <span class="number">1</span> ? num % tmp1 + <span class="number">1</span> : tmp1;</span><br><span class="line">    <span class="comment">// 除去最高位之外，剩下1的数量</span></span><br><span class="line">    <span class="comment">// 最高位1 10(k-2次方) * (k-1) * 1</span></span><br><span class="line">    <span class="comment">// 最高位first 10(k-2次方) * (k-1) * first</span></span><br><span class="line">    <span class="keyword">int</span> otherOneNum = first * (len - <span class="number">1</span>) * (tmp1 / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> firstOneNum + otherOneNum + solution2(num % tmp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLenOfNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">powerBaseOf10</span><span class="params">(<span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先给出可整合数组的定义:如果一个数组在排序之后，每相邻两个数差的绝对值 都为 <span class="number">1</span>， 则该数组为可整合数组。例如，[<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>]排序之后为[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]， 符合每相邻两个数差的绝对值 都为 <span class="number">1</span>，所以这个数组为可整合数组。 给定一个整型数组 arr，请返回其中最大可整合子数组的长度。例如， [<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>]的最大可整合子数组为[<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，所以返回 <span class="number">5</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">转换可整合数组概念：</span><br><span class="line">1.子数组中不能有重复值</span><br><span class="line">2.子数组中的Max - Min &#x3D; length - 1 ，则它是可整合数组</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLIL2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">0</span>; L &lt; arr.length; L++) &#123; <span class="comment">// L 左边界</span></span><br><span class="line">        set.clear();</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> R = L; R &lt; arr.length; R++) &#123; <span class="comment">// R 右边界</span></span><br><span class="line">            <span class="comment">// arr[L..R]这个子数组在验证</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(arr[R])) &#123;</span><br><span class="line">                <span class="comment">// arr[L..R]上开始 出现重复值了，arr[L..R往后]不需要验证了，</span></span><br><span class="line">                <span class="comment">// 一定不是可整合的</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// arr[L..R]上无重复值</span></span><br><span class="line">            set.add(arr[R]);</span><br><span class="line">            max = Math.max(max, arr[R]);</span><br><span class="line">            min = Math.min(min, arr[R]);</span><br><span class="line">            <span class="keyword">if</span> (max - min == R - L) &#123; <span class="comment">// L..R 是可整合的</span></span><br><span class="line">                len = Math.max(len, R - L + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k(0) &#x3D; 1, k(1) &#x3D; 1时，如果接下来的项满足：</span><br><span class="line">k(n) &#x3D; k(0) * k(n - 1) + k(1) * k(n - 2) + ... + k(n - 2) * k(1) + k(n - 1) * k(0)</span><br><span class="line">或者</span><br><span class="line">k(n) &#x3D; c(2n, n) - c(2n, n-1) 数学排列组合公式</span><br><span class="line">或者</span><br><span class="line">k(n) &#x3D; c(2n, n) &#x2F; (n + 1)</span><br><span class="line">就说这个表达式，满足卡特兰数，常用的是范式1和2，3几乎不会使用到</span><br><span class="line"></span><br><span class="line">二叉树N个节点，能组成多少种结构（卡特兰数求法）？</span><br><span class="line">其前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796...</span><br><span class="line"></span><br><span class="line">最常见题目：</span><br><span class="line">有N个0和N个1，要求组合排列后，任何位置的前缀的0的数量不比1的数量少</span><br><span class="line">（等同于有三个值要入栈，求出栈的可能性，入栈的顺序肯定比出栈的顺序多，就会转换成卡特兰数问题）</span><br></pre></td></tr></table></figure>

<h2 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题目一：</span><br><span class="line">给定一个数组arr，从左到右表示昨天从早到晚股票的价格。作为一个事后诸葛亮，你想知道如果只做一次交易，且每次交易只买卖一股，返回能挣到的最大钱数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        ans = Math.max(ans, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目二：</span><br><span class="line">给定一个数组arr，从左到右表示昨天从早到晚股票的价格</span><br><span class="line">作为一个事后诸葛亮，你想知道如果随便交易，</span><br><span class="line">且每次交易只买卖一股，返回能挣到的最大钱数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">假设位置是i,如果arr[i] &gt; arr[i-1]，那么我获得arr[i] - arr[i-1]的利润</span><br><span class="line">每个位置都这样做，等于求递增的差值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        ans += Math.max(prices[i] - prices[i-<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目三：</span><br><span class="line">给定一个数组arr，从左到右表示昨天从早到晚股票的价格</span><br><span class="line">作为一个事后诸葛亮，你想知 道如果交易次数不超过K次，</span><br><span class="line">且每次交易只买卖一股，返回能挣到的最大钱数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">长度为N的数组arr，它的递增上坡数量一定是小于N&#x2F;2的，因为要有上坡和下坡</span><br><span class="line">最极限的例子：[1,5,3,4,2] 上下上下 也就是说最多的交易次数绝对不会大于N&#x2F;2</span><br><span class="line">若参数交易次数大于K次，等同于无限次交易，那么等同于题目二的解法</span><br><span class="line"></span><br><span class="line">以index为行，K为列，建立dp表,dp[i][j]表示arr[0..i]上，交易次数小于等于j次的最大收益</span><br><span class="line">dp[i][j]的可能性：</span><br><span class="line">可能性一：</span><br><span class="line">i位置不参与交易，dp[i][j] &#x3D; dp[i-1][j]</span><br><span class="line">可能性二：</span><br><span class="line">i位置参与交易,并且i位置作为最后一次卖出股票的时机，等于求最后一次买入股票的时机</span><br><span class="line">枚举[0..i][j-1]位置上的值 + arr[i] - arr[0..i]，求其中的最大值</span><br><span class="line"></span><br><span class="line">可能性二的枚举行为加速：</span><br><span class="line">dp[i-1][j] &#x3D; MAX[0..i-1] -&gt; (dp[0..i-1][j-1] - arr[0..i-1]) + arr[i-1]</span><br><span class="line">假设缓存计算结果 t &#x3D;  MAX[0..i-1] -&gt; (dp[0..i-1][j-1] - arr[0..i-1])</span><br><span class="line">dp[i][j] &#x3D; MAX(t,dp[i][j-1] - arr[i]) + arr[i]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (K &gt;= N / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> allTrans(prices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][K + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = dp[<span class="number">0</span>][j - <span class="number">1</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            t = Math.max(t, dp[i][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], t + prices[i]);</span><br><span class="line">            ans = Math.max(ans, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">allTrans</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        ans += Math.max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2021年02月03日 17:23</p>
        <p>原始链接： <a class="post-url" href="/2020/10/31/algorithm-trainingcamp3/" title="&#39;数据结构与算法 训练营三期&#39;">https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&title=《'数据结构与算法 训练营三期'》 — Kuro's Blog&pic=images/algorithm.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&title=《'数据结构与算法 训练营三期'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'数据结构与算法 训练营三期'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/10/31/algorithm-trainingcamp3/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/algorithm/" class="color5">algorithm</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#训练营三期"><span class="post-toc-text">训练营三期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#滑动窗口"><span class="post-toc-text">滑动窗口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#括号四连"><span class="post-toc-text">括号四连</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#辅助数组"><span class="post-toc-text">辅助数组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单调性"><span class="post-toc-text">单调性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#空间压缩"><span class="post-toc-text">空间压缩</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#编辑距离"><span class="post-toc-text">编辑距离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LRU"><span class="post-toc-text">LRU</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图的遍历"><span class="post-toc-text">图的遍历</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异或"><span class="post-toc-text">异或</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#卡特兰数"><span class="post-toc-text">卡特兰数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#股票问题"><span class="post-toc-text">股票问题</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/11/01/algorithm-trainingcamp4/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;数据结构与算法 训练营四期&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/10/30/algorithm-trainingcamp2/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;数据结构与算法 训练营二期&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="algorithm-trainingcamp3" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2021 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Dubbo/">Dubbo</a><a class="category-link" href="/categories/Elasticsearch/">Elasticsearch</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/FastDFS/">FastDFS</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kafka/">Kafka</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/MySql/">MySql</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Transaction/">Transaction</a><a class="category-link" href="/categories/Zookeeper/">Zookeeper</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/algorithm/">algorithm</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 10px;">Dubbo</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 14px;">Kafka</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 13px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 12px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16px;">ActiveMQ</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/Dubbo/" style="font-size: 10px;">Dubbo</a> <a href="/tags/Elasticsearch/" style="font-size: 17px;">Elasticsearch</a> <a href="/tags/FastDFS/" style="font-size: 10px;">FastDFS</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kafka/" style="font-size: 14px;">Kafka</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MySql/" style="font-size: 13px;">MySql</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 12px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/Zookeeper/" style="font-size: 10px;">Zookeeper</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>