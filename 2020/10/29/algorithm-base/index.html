<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;数据结构与算法&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="基础算法1234评估算法优劣的核心指标是什么？时间复杂度（流程决定）额外空间复杂度（流程决定）常数项时间（实现细节决定）  时间复杂度12345678910如何确定算法流程的时间复杂度？当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为：O(忽略掉系数的高阶项)时间复杂度的意义在于：当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;数据结构与算法&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/10/29/algorithm-base/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="基础算法1234评估算法优劣的核心指标是什么？时间复杂度（流程决定）额外空间复杂度（流程决定）常数项时间（实现细节决定）  时间复杂度12345678910如何确定算法流程的时间复杂度？当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。记为：O(忽略掉系数的高阶项)时间复杂度的意义在于：当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-29T14:32:00.000Z">
<meta property="article:modified_time" content="2020-12-04T14:53:15.933Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-algorithm-base" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;数据结构与算法&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Algorithm/">Algorithm</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-10-29
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">评估算法优劣的核心指标是什么？</span><br><span class="line">时间复杂度（流程决定）</span><br><span class="line">额外空间复杂度（流程决定）</span><br><span class="line">常数项时间（实现细节决定）</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如何确定算法流程的时间复杂度？</span><br><span class="line">当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。</span><br><span class="line"></span><br><span class="line">记为：O(忽略掉系数的高阶项)</span><br><span class="line"></span><br><span class="line">时间复杂度的意义在于：</span><br><span class="line"></span><br><span class="line">当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。</span><br><span class="line"></span><br><span class="line">这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">过程：</span><br><span class="line">arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。</span><br><span class="line">arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。</span><br><span class="line">arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。</span><br><span class="line">…</span><br><span class="line">arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。</span><br><span class="line"></span><br><span class="line">估算：</span><br><span class="line">很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般</span><br><span class="line">所以，总的常数操作数量 &#x3D; a*(N^2) + b*N + c (a、b、c都是常数)</span><br><span class="line"></span><br><span class="line">所以选择排序的时间复杂度为O(N^2)。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心思想：</span></span><br><span class="line"><span class="comment">//i ~ N-1 中最小的值放在 i 上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">// i ~ N-1</span></span><br><span class="line">    <span class="comment">// 最小值在哪个位置上  i～n-1</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123; </span><br><span class="line">        <span class="comment">// i ~ N-1 上找最小值的下标 </span></span><br><span class="line">        minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    swap(arr, i, minIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">过程：</span><br><span class="line">在arr[0～N-1]范围上：</span><br><span class="line">arr[0]和arr[1]，谁大谁来到1位置；arr[1]和arr[2]，谁大谁来到2位置…arr[N-2]和arr[N-1]，谁大谁来到N-1位置</span><br><span class="line"></span><br><span class="line">在arr[0～N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置</span><br><span class="line">在arr[0～N-3]范围上，重复上面的过程，但最后一步是arr[N-4]和arr[N-3]，谁大谁来到N-3位置</span><br><span class="line">…</span><br><span class="line">最后在arr[0～1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">估算：</span><br><span class="line">很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般</span><br><span class="line">所以，总的常数操作数量 &#x3D; a*(N^2) + b*N + c (a、b、c都是常数)</span><br><span class="line"></span><br><span class="line">所以冒泡排序的时间复杂度为O(N^2)。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0 ~ N-1</span></span><br><span class="line"><span class="comment">// 0 ~ N-2</span></span><br><span class="line"><span class="comment">// 0 ~ N-3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="comment">//重点在于i 和 i+1 比较交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">过程：</span><br><span class="line">想让arr[<span class="number">0</span>~<span class="number">0</span>]上有序，这个范围只有一个数，当然是有序的。</span><br><span class="line">想让arr[<span class="number">0</span>~<span class="number">1</span>]上有序，所以从arr[<span class="number">1</span>]开始往前看，如果arr[<span class="number">1</span>]&lt;arr[<span class="number">0</span>]，就交换。否则什么也不做。</span><br><span class="line">…</span><br><span class="line">想让arr[<span class="number">0</span>~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</span><br><span class="line">最后一步，想让arr[<span class="number">0</span>~N-<span class="number">1</span>]上有序， arr[N-<span class="number">1</span>]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</span><br><span class="line"></span><br><span class="line">估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0~0 有序的</span></span><br><span class="line"><span class="comment">// 0~i 想有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。</span><br><span class="line"></span><br><span class="line">很明显，在最差情况下，如果arr长度为N，插入排序的每一步常数操作的数量，还是如等差数列一般</span><br><span class="line"></span><br><span class="line">所以，总的常数操作数量 &#x3D; a*(N^2) + b*N + c (a、b、c都是常数)</span><br><span class="line"></span><br><span class="line">所以插入排序排序的时间复杂度为O(N^2)。</span><br></pre></td></tr></table></figure>

<h2 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。</span><br><span class="line"></span><br><span class="line">作为输入参数的空间，不算额外空间。</span><br><span class="line">作为输出结果的空间，也不算额外空间。</span><br><span class="line"></span><br><span class="line">因为这些都是必要的、和现实目标有关的。所以都不算。</span><br><span class="line"></span><br><span class="line">但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。</span><br><span class="line"></span><br><span class="line">如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。</span><br><span class="line"></span><br><span class="line">难道同样时间复杂度的流程，在实际运行时候就一样的好吗？</span><br><span class="line"></span><br><span class="line">当然不是。</span><br><span class="line"></span><br><span class="line">时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</span><br></pre></td></tr></table></figure>

<h2 id="算法流程的常数项"><a href="#算法流程的常数项" class="headerlink" title="算法流程的常数项"></a>算法流程的常数项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">放弃理论分析，生成随机数据直接测。</span><br><span class="line"></span><br><span class="line">为什么不去理论分析？</span><br><span class="line"></span><br><span class="line">不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。</span><br><span class="line"></span><br><span class="line">比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。</span><br><span class="line"></span><br><span class="line">所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。</span><br></pre></td></tr></table></figure>

<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个有序数组中，找某个数是否存在 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] sortedArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr == <span class="keyword">null</span> || sortedArr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = sortedArr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// L..R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">// mid = (L + R) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (sortedArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortedArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个有序数组中，找&gt;=value最左侧的位置 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>; <span class="comment">// 记录最左的对号</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部最小值问题(等于找数据的曲线变化转折点，数值连续下降再上升，就算是一个局部最小值)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// no exist</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[arr.length - <span class="number">1</span>] &lt; arr[arr.length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何不用额外变量交换两个数</span></span><br><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：a 和 b 不能指向同一个地址空间，否则怎么交换都是0</span></span><br><span class="line"><span class="comment">// 比如i和j是一个位置的话，会出错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//怎么把一个int类型的数，提取出最右侧的1来</span></span><br><span class="line">n &amp; (~n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// n 	: 001100100</span></span><br><span class="line"><span class="comment">// ~n	: 110011011</span></span><br><span class="line"><span class="comment">// ~n+1	: 110011100</span></span><br><span class="line"><span class="comment">//		: 000000100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// eor = a ^ b</span></span><br><span class="line">    <span class="comment">// eor != 0</span></span><br><span class="line">    <span class="comment">// eor必然有一个位置上是1（必然这两个数在这位上一个是0一个是1）</span></span><br><span class="line">    <span class="comment">// 0110010000</span></span><br><span class="line">    <span class="comment">// 0000010000</span></span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>); <span class="comment">// 提取出最右的1</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line">        <span class="comment">//  arr[1] =  111100011110000</span></span><br><span class="line">        <span class="comment">// rightOne=  000000000010000</span></span><br><span class="line">        <span class="comment">//只异或最右边有1的值，偶数的过滤完，剩下奇数的那个数</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            onlyOne ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(onlyOne + <span class="string">" "</span> + (eor ^ onlyOne));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提取整数n转换成二进制之后，他的中1的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bit1counts</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rightOne = n &amp; (~n + <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">        n = n ^ rightOne;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用数组实现队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pushi;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> polli;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[limit];</span><br><span class="line">        pushi = <span class="number">0</span>;</span><br><span class="line">        polli = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == limit) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈满了，不能再加了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        arr[pushi] = value;</span><br><span class="line">        pushi = nextIndex(pushi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空了，不能再拿了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> ans = arr[polli];</span><br><span class="line">        polli = nextIndex(polli);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果现在的下标是i，返回下一个位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; limit - <span class="number">1</span> ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能</span><br><span class="line">pop、push、getMin操作的时间复杂度都是 O(1)。 </span><br><span class="line">设计的栈类型可以使用现成的栈结构。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开多个栈，push的时候压入min和push之中的最小值，弹出则都弹出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.stackMin = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> newNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNum &lt; <span class="keyword">this</span>.getmin()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> newMin = <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">            <span class="keyword">this</span>.stackMin.push(newMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackData.push(newNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackData.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your stack is empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何用栈结构实现队列结构</span></span><br><span class="line"><span class="comment">//两个栈，一个push、一个pop，把push推到pop栈再弹出pop栈顶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStacksQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//只要pop空了再移过去,每次移过去要移动所有push栈的数据</span></span><br><span class="line">    <span class="comment">// push栈向pop栈倒入数据</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushToPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.empty()) &#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pushInt)</span> </span>&#123;</span><br><span class="line">        stackPush.push(pushInt);</span><br><span class="line">        pushToPop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何用队列结构实现栈结构</span></span><br><span class="line"><span class="comment">//两个队列，一个存，取，当取的时候把存的队列都塞到取的队列中，一直塞到存的队列剩下一个，把那个数据返回，并且设置取队列等于存队列，存队列等于取队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> Queue&lt;T&gt; help;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        Queue&lt;T&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            help.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        T ans = queue.poll();</span><br><span class="line">        help.offer(ans);</span><br><span class="line">        Queue&lt;T&gt; tmp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = tmp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递归公式</span><br><span class="line">T(N) &#x3D; a * T(N&#x2F;b) + O(N^d)(其中的a、b、d都是常数)</span><br><span class="line">的递归函数，可以直接通过Master公式来确定时间复杂度</span><br><span class="line">如果 log(b,a) &lt; d，复杂度为O(N^d)</span><br><span class="line">如果 log(b,a) &gt; d，复杂度为O(N^log(b,a))</span><br><span class="line">如果 log(b,a) &#x3D;&#x3D; d，复杂度为O(N^d  * logN)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[L..R]范围上求最大值  L ... R   N</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// arr[L..R]范围上只有一个数，直接返回，base case</span></span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">// 中点   	1</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = process(arr, L, mid);</span><br><span class="line">    <span class="keyword">int</span> rightMax = process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度:</span></span><br><span class="line"><span class="comment">//T（N） = 2 * T（N/2） + O(N^0)</span></span><br><span class="line"><span class="comment">//log(2,2) = 1 &gt; 0，复杂度为O(N)</span></span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1)哈希表在使用层面上可以理解为一种集合结构</span><br><span class="line">2)如果只有key，没有伴随数据value，可以使用HashSet结构</span><br><span class="line">3)如果既有key，又有伴随数据value，可以使用HashMap结构</span><br><span class="line">4)有无伴随数据，是HashMap和HashSet唯一的区别，实际结构是一回事 </span><br><span class="line">5)使用哈希表增(put)、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大 </span><br><span class="line">6)放入哈希表的东西，如果是基础类型，内部按值传递，内存占用是这个东西的大小 </span><br><span class="line">7)放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是8字节</span><br><span class="line"></span><br><span class="line">哈希表在使用时，增删改查时间复杂度都是O(1)</span><br><span class="line">有序表在使用时，比哈希表功能多，时间复杂度都是O(logN)</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）整体是递归，左边排好序+右边排好序+merge让整体有序</span><br><span class="line">2）让其整体有序的过程里用了排外序方法</span><br><span class="line">3）利用master公式来求解时间复杂度</span><br><span class="line">4）当然可以用非递归实现</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[L...R]范围上，变成有序的</span></span><br><span class="line"><span class="comment">//二分，开辟新数组，遍历二分的左右数组比较大小塞进去，然后拷贝回去</span></span><br><span class="line"><span class="comment">//O(N * log N)</span></span><br><span class="line"><span class="comment">//选择排序O(N^2)大量在浪费比较行为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//下标遍历两个数组，赋值新数组</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归方法实现</span></span><br><span class="line"><span class="comment">//通过把相邻的MergeSize个数据有序，分段，每次合并两段，再重复</span></span><br><span class="line"><span class="comment">//O(N * log N)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span> mergeSize = <span class="number">1</span>;<span class="comment">// 当前有序的，左组长度</span></span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line">        <span class="comment">//当前组的下标</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0.... </span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="comment">// L...M  左组（mergeSize）</span></span><br><span class="line">            <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (M &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  L...M   M+1...R(mergeSize)</span></span><br><span class="line">            <span class="keyword">int</span> R = Math.min(M + mergeSize, N - <span class="number">1</span>);</span><br><span class="line">            merge(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止双倍数组长度逸出int最大值</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//双倍扩大</span></span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//左组 和右组 迭代过程中产生的小和 + 自己调用merge产生的小和</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        process(arr, l, mid) </span><br><span class="line">        + </span><br><span class="line">        process(arr, mid + <span class="number">1</span>, r) </span><br><span class="line">        + </span><br><span class="line">        merge(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//右边的比左边的大时，计算右边还剩下多少个数 * 左边的值，累加到res上</span></span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当左右组数相同时，先拷贝右数</span></span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把所有非0的数放左边</span></span><br><span class="line"><span class="comment">//设定一个index，遇到非0的都和index交换，index++</span></span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        swap(arr, i, ++index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">荷兰国旗问题</span><br><span class="line"></span><br><span class="line">给定一个数组arr，和一个整数num。请把小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在数组的右边。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做为num的值</span></span><br><span class="line"><span class="comment">//  &lt;arr[R]  ==arr[R]  &gt; arr[R]</span></span><br><span class="line"><span class="comment">//返回 中间等于 arr[R]的区间</span></span><br><span class="line"><span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">// &lt; 区 右边界</span></span><br><span class="line"><span class="keyword">int</span> more = R;     <span class="comment">// &gt; 区 左边界 最右边的R不动</span></span><br><span class="line"><span class="keyword">int</span> index = L;</span><br><span class="line"><span class="comment">//遍历的区间在于  [L--- R-1]</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">        swap(arr, index++, ++less);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// &gt;</span></span><br><span class="line">        swap(arr, index, --more);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后再把index=R的数据插到more的左侧</span></span><br><span class="line"><span class="comment">// L...Less less+1...more-1  more...R-1 R</span></span><br><span class="line"><span class="comment">// L...Less less+1........more more+1...R</span></span><br><span class="line">swap(arr, more, R);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">快速排序1.0</span><br><span class="line"></span><br><span class="line">在arr[L..R]范围上，进行快速排序的过程：</span><br><span class="line">1）用arr[R]对该范围做partition，&lt;&#x3D; arr[R]的数在左部分并且保证arr[R]最后来到左部分的最后一个位置，记为M； &lt;&#x3D; arr[R]的数在右部分（arr[M+1..R]）</span><br><span class="line">2）对arr[L..M-1]进行快速排序(递归)</span><br><span class="line">3）对arr[M+1..R]进行快速排序(递归)</span><br><span class="line">因为每一次partition都会搞定一个数的位置且不会再变动，所以排序能完成</span><br><span class="line"></span><br><span class="line">时间复杂度O(N^2)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//V1.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L..R partition arr[R]  [   &lt;=arr[R]   arr[R]    &gt;arr[R]  ]</span></span><br><span class="line">    <span class="keyword">int</span> M = partition(arr, L, R);</span><br><span class="line">    process1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">    process1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">快速排序2.0</span><br><span class="line"></span><br><span class="line">在arr[L..R]范围上，进行快速排序的过程：</span><br><span class="line">1）用arr[R]对该范围做partition，&lt; arr[R]的数在左部分，&#x3D;&#x3D; arr[R]的数中间，&gt;arr[R]的数在右部分。假设&#x3D;&#x3D; arr[R]的数所在范围是[a,b]</span><br><span class="line">2）对arr[L..a-1]进行快速排序(递归)</span><br><span class="line">3）对arr[b+1..R]进行快速排序(递归)</span><br><span class="line">因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</span><br><span class="line"></span><br><span class="line">时间复杂度O(N^2)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//V2.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回arr[R]的下标范围</span></span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process2(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process2(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">快速排序3.0(随机快排+荷兰国旗技巧优化)</span><br><span class="line"></span><br><span class="line">在arr[L..R]范围上，进行快速排序的过程：</span><br><span class="line">1）在这个范围上，随机选一个数记为num，</span><br><span class="line">1）用num对该范围做partition，&lt; num的数在左部分，&#x3D;&#x3D; num的数中间，&gt;num的数在右部分。假设&#x3D;&#x3D; num的数所在范围是[a,b]</span><br><span class="line">2）对arr[L..a-1]进行快速排序(递归)</span><br><span class="line">3）对arr[b+1..R]进行快速排序(递归)</span><br><span class="line">因为每一次partition都会搞定一批数的位置且不会再变动，所以排序能完成</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//V3.0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br><span class="line">    <span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">    process3(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process3(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherlandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; L, R &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> less = L - <span class="number">1</span>; <span class="comment">// &lt; 区 右边界</span></span><br><span class="line">    <span class="keyword">int</span> more = R;     <span class="comment">// &gt; 区 左边界</span></span><br><span class="line">    <span class="keyword">int</span> index = L;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">            swap(arr, index++, ++less);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// &gt;</span></span><br><span class="line">            swap(arr, index, --more);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, more, R);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）通过分析知道，划分值越靠近中间，性能越好；越靠近两边，性能越差</span><br><span class="line">2）随机选一个数进行划分的目的就是让好情况和差情况都变成概率事件</span><br><span class="line">3）把每一种情况都列出来，会有每种情况下的时间复杂度，但概率都是1&#x2F;N</span><br><span class="line">4）那么所有情况都考虑，时间复杂度就是这种概率模型下的长期期望！</span><br><span class="line"></span><br><span class="line">时间复杂度O(N*logN)，额外空间复杂度O(logN)都是这么来的。</span><br></pre></td></tr></table></figure>

<h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1）堆结构就是用数组实现的完全二叉树结构</span><br><span class="line">2）完全二叉树中如果每棵子树的最大值都在顶部就是大根堆</span><br><span class="line">3）完全二叉树中如果每棵子树的最小值都在顶部就是小根堆</span><br><span class="line">4）堆结构的heapInsert与heapify操作</span><br><span class="line">5）堆结构的增大和减少 </span><br><span class="line">6）优先级队列结构，就是堆结构</span><br><span class="line"></span><br><span class="line">N个元素，树的高度： logN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父节点:(index - 1)&#x2F;2</span><br><span class="line">左子节点：2 * index + 1</span><br><span class="line">右子节点： 2 * index + 2</span><br><span class="line">注：有些算法不算第0个下标的数据，而是从1开始，因为计算节点将变成：</span><br><span class="line">父节点：index&#x2F;2   (index &gt;&gt; 1)</span><br><span class="line">左子节点： 2 * index  (index &lt;&lt; 1)</span><br><span class="line">右子节点： 2 * index + 1 ((index &lt;&lt; 1) | 1)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把第0个位置当做根节点，1~2位置当做根节点的左右节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMaxHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heapSize == limit) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"heap is full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[heapSize] = value;</span><br><span class="line">        <span class="comment">// value  heapSize</span></span><br><span class="line">        heapInsert(heap, heapSize++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户此时，让你返回最大值，并且在大根堆中，把最大值删掉</span></span><br><span class="line">    <span class="comment">// 剩下的数，依然保持大根堆组织</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = heap[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//最后的heapSize和根节点交换</span></span><br><span class="line">        swap(heap, <span class="number">0</span>, --heapSize);</span><br><span class="line">        heapify(heap, <span class="number">0</span>, heapSize);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// arr[index]</span></span><br><span class="line">        <span class="comment">// arr[index] 不比 arr[index父]大了 ， 停</span></span><br><span class="line">        <span class="comment">// index = 0;</span></span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 从index位置，往下看，不断的下沉，</span></span><br><span class="line">  <span class="comment">// 停：我的孩子都不再比我大；已经没孩子了</span></span><br><span class="line">    <span class="comment">// arr[index]位置的数，能否往下移动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">            <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">            <span class="comment">// 1）只有左孩子，left -&gt; largest</span></span><br><span class="line">            <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">            <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">堆排序</span><br><span class="line">1，先让整个数组都变成大根堆结构，建立堆的过程: </span><br><span class="line">    1)从上到下的方法，时间复杂度为O(N*logN) </span><br><span class="line">    2)从下到上的方法，时间复杂度为O(N) </span><br><span class="line">2，把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆，一直周而复始，时间复杂度为O(N*logN) </span><br><span class="line">3，堆的大小减小成0之后，排序完成</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="comment">// 堆排序的逻辑：先排一次大根堆，第0个位置肯定是最大的  O(N*logN)</span></span><br><span class="line"><span class="comment">// 把第0个位置和大根堆最后一个数交换，大根堆范围缩小1 O(N*logN)</span></span><br><span class="line"><span class="comment">// 接着循环一直排大根堆，直到heapSize等于0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次创建大根堆的逻辑可以优化成O(N)，要逆序从最后一个往上比较，父节点小的调用heapify下沉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// O(N*logN)写法</span></span><br><span class="line">    <span class="comment">//		for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span></span><br><span class="line">    <span class="comment">//			heapInsert(arr, i); // O(logN)</span></span><br><span class="line">    <span class="comment">//		&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(N)写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。</span><br><span class="line"></span><br><span class="line">请选择一个合适的排序策略，对这个数组进行排序。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(N * logK)</span></span><br><span class="line"><span class="comment">//在K个范围排序小根堆，然后弹出根节点，再加入下一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortedArrDistanceLessK</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认小根堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0...K-1</span></span><br><span class="line">    <span class="keyword">for</span> (; index &lt;= Math.min(arr.length - <span class="number">1</span>, k - <span class="number">1</span>); index++) &#123;</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;</span><br><span class="line">        heap.add(arr[index]);</span><br><span class="line">        arr[i] = heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当小根堆无法继续扩容时，以此弹出小根堆中最小的值</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">        arr[i++] = heap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）单个字符串中，字符从前到后的加到一棵多叉树上</span><br><span class="line">2）字符放在路上，节点上有专属的数据项（常见的是pass和end值）</span><br><span class="line">3）所有样本都这样添加，如果没有路就新建，如有路就复用</span><br><span class="line">4）沿途节点的pass值增加1，每个字符串结束时来到的节点end值增加1</span><br><span class="line"></span><br><span class="line">可以完成前缀相关的查询</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">设计一种结构。用户可以：</span><br><span class="line">1）void insert(String str)            添加某个字符串，可以重复添加，每次算1个</span><br><span class="line">2）int search(String str)             查询某个字符串在结构中还有几个</span><br><span class="line">3)  void delete(String str)           删掉某个字符串，可以重复删除，每次算1个</span><br><span class="line">4）int prefixNumber(String str)  查询有多少个字符串，是以str做前缀的</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过链表记录链路，index记录字母</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pass;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> Node1[] nexts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pass = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> Node1[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node1 root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        Node1 node = root;</span><br><span class="line">        node.pass++;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.nexts[index] = <span class="keyword">new</span> Node1();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">            node.pass++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">            Node1 node = root;</span><br><span class="line">            node.pass--;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span> (--node.nexts[index].pass == <span class="number">0</span>) &#123;</span><br><span class="line">                    node.nexts[index] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[index];</span><br><span class="line">            &#125;</span><br><span class="line">            node.end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// word这个单词之前加入过几次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        Node1 node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">        Node1 node = root;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.pass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">桶排序思想下的排序：计数排序 &amp; 基数排序 </span><br><span class="line"></span><br><span class="line">1)桶排序思想下的排序都是不基于比较的排序</span><br><span class="line"></span><br><span class="line">2)时间复杂度为O(N)，额外空间负载度O(M)</span><br><span class="line"></span><br><span class="line">3)应用范围有限，需要样本的数据状况满足桶的划分 </span><br><span class="line"></span><br><span class="line">一般来讲，计数排序要求，样本是整数，且范围比较窄</span><br><span class="line">一般来讲，基数排序要求，样本是10进制的正整数</span><br><span class="line">一旦要求稍有升级，改写代价增加是显而易见的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">计数排序:</span><br><span class="line">如年龄0~200，设定一个下标为0~200的数组，遍历并数组中的值++，适用范围有限且和样本数据强关联</span><br><span class="line">基数排序：</span><br><span class="line">建立十个桶队列，低位数据补齐至和高位相同位数，如 100,001</span><br><span class="line">按照个十百位顺序入队列，再依次取出十个桶队列的所有元素，最后有序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序非负数的十进制</span></span><br><span class="line"><span class="comment">// only for no-negative value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最大值的位数 如 100 ---&gt; 3位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxbits</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[l..r]排序  ,  digit</span></span><br><span class="line"><span class="comment">// l..r    3 56 17 100    3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> radix = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//d表示当前要取出的位数下标，1表示个位，2表示十位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= digit; d++) &#123; <span class="comment">// 有多少位就进出几次</span></span><br><span class="line">        <span class="comment">// 10个空间</span></span><br><span class="line">        <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line">        <span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">        <span class="comment">//这时候的count[]存储的个位数等于当前下标的数量</span></span><br><span class="line">        <span class="keyword">for</span> (i = L; i &lt;= R; i++) &#123;</span><br><span class="line">            <span class="comment">// 103  d=1   3</span></span><br><span class="line">            <span class="comment">// 209  d=1   9</span></span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            count[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count做累加和，i - 1的数据做累加，count[]存储的是个位数小于等于当前下标的数量</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">            count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//倒序遍历数组，把数据放在第count[j]个位置上，j--</span></span><br><span class="line">        <span class="comment">//通过这种方式实现队列排序</span></span><br><span class="line">        <span class="keyword">for</span> (i = R; i &gt;= L; i--) &#123;</span><br><span class="line">            j = getDigit(arr[i], d);</span><br><span class="line">            help[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">            count[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) &#123;</span><br><span class="line">            arr[i] = help[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x / ((<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">稳定性是指同样大小的样本再排序之后不会改变相对次序</span><br><span class="line"></span><br><span class="line">对基础类型来说，稳定性毫无意义</span><br><span class="line"></span><br><span class="line">对非基础类型来说，稳定性有重要意义</span><br><span class="line"></span><br><span class="line">有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      时间复杂度		额外空间复杂度	  稳定性</span><br><span class="line">选择排序		O(N^2)			O(1)		无</span><br><span class="line">冒泡排序		O(N^2)			O(1)		有</span><br><span class="line">插入排序		O(N^2)			O(1)		有</span><br><span class="line">归并排序		O(N*logN)		O(N)		有</span><br><span class="line">随机快排		O(N*logN)		O(logN)		无</span><br><span class="line">堆排序			O(N*logN)		 O(1)		 无</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">计数排序		O(N)			O(M)		有</span><br><span class="line">基数排序		O(N)			O(N)		有</span><br></pre></td></tr></table></figure>

<p>追求稳定性的话，可以选择归并排序，追求额外空间复杂度低的，选择堆排序，两者都不追求时，快排的效率最高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）不基于比较的排序，对样本数据有严格要求，不易改写</span><br><span class="line">2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用</span><br><span class="line">3）基于比较的排序，时间复杂度的极限是O(N*logN)</span><br><span class="line">4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。</span><br><span class="line">5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快慢指针：快指针走的步数是慢指针的两倍</span><br><span class="line">1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</span><br><span class="line">2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</span><br><span class="line">3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</span><br><span class="line">4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 头</span></span><br><span class="line"><span class="comment">//1）输入链表头节点，奇数长度返回中点，偶数长度返回上中点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表有3个点或以上</span></span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2）输入链表头节点，奇数长度返回中点，偶数长度返回下中点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3）输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrUpMidPreNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4）输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">midOrDownMidPreNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个单链表的头节点head，请判断该链表是否为回文结构。 </span><br><span class="line">笔试做法：</span><br><span class="line">1.创建栈，全都丢到栈里，弹出来和原来的链表做比较，空间复杂度O（N）</span><br><span class="line">2.快慢指针找到中点，中点后的链表压入栈中，空间复杂度O（N&#x2F;2）</span><br><span class="line">面试做法：</span><br><span class="line">快慢指针找到中点，reverse中点后的链表，然后头尾两个指针遍历比较，最后要还原reverse的链表</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// need n extra space</span></span><br><span class="line"><span class="comment">//时间复杂度O（N），空间复杂度O（N）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// need O(1) extra space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">    Node n2 = head;</span><br><span class="line">    <span class="keyword">while</span> (n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>) &#123; <span class="comment">// find mid node</span></span><br><span class="line">        n1 = n1.next; <span class="comment">// n1 -&gt; mid</span></span><br><span class="line">        n2 = n2.next.next; <span class="comment">// n2 -&gt; end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n1 中点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n2 = n1.next; <span class="comment">// n2 -&gt; right part first node</span></span><br><span class="line">    n1.next = <span class="keyword">null</span>; <span class="comment">// mid.next -&gt; null</span></span><br><span class="line">    Node n3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n2 != <span class="keyword">null</span>) &#123; <span class="comment">// right part convert</span></span><br><span class="line">        n3 = n2.next; <span class="comment">// n3 -&gt; save next node</span></span><br><span class="line">        n2.next = n1; <span class="comment">// next of right node convert</span></span><br><span class="line">        n1 = n2; <span class="comment">// n1 move</span></span><br><span class="line">        n2 = n3; <span class="comment">// n2 move</span></span><br><span class="line">    &#125;</span><br><span class="line">    n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">    n2 = head;<span class="comment">// n2 -&gt; left first node</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>) &#123; <span class="comment">// check palindrome</span></span><br><span class="line">        <span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next; <span class="comment">// left to mid</span></span><br><span class="line">        n2 = n2.next; <span class="comment">// right to mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    n1 = n3.next;</span><br><span class="line">    n3.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (n1 != <span class="keyword">null</span>) &#123; <span class="comment">// recover list</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将单向链表按某值划分成左边小、中间相等、右边大的形式</span><br><span class="line"></span><br><span class="line">1）把链表放入数组里，在数组上做partition（笔试用）</span><br><span class="line"></span><br><span class="line">2）分成小、中、大三部分，再把各个部分之间串起来（面试用）</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用6个指针，生成三条链表，最后连起来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">    Node sH = <span class="keyword">null</span>; <span class="comment">// small head</span></span><br><span class="line">    Node sT = <span class="keyword">null</span>; <span class="comment">// small tail</span></span><br><span class="line">    Node eH = <span class="keyword">null</span>; <span class="comment">// equal head</span></span><br><span class="line">    Node eT = <span class="keyword">null</span>; <span class="comment">// equal tail</span></span><br><span class="line">    Node mH = <span class="keyword">null</span>; <span class="comment">// big head</span></span><br><span class="line">    Node mT = <span class="keyword">null</span>; <span class="comment">// big tail</span></span><br><span class="line">    Node next = <span class="keyword">null</span>; <span class="comment">// save next node</span></span><br><span class="line">    <span class="comment">// every node distributed to three lists</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mH == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mH = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mT.next = head;</span><br><span class="line">                mT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有小于区域</span></span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的if，不管跑了没有，et</span></span><br><span class="line">    <span class="comment">// all reconnect</span></span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>) &#123; <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">        eT.next = mH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : (eH != <span class="keyword">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一种特殊的单链表节点类描述如下 </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> value; </span><br><span class="line">Node next; </span><br><span class="line">Node rand; </span><br><span class="line">Node(<span class="keyword">int</span> val) &#123; value = val; &#125; </span><br><span class="line">&#125; </span><br><span class="line">rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向<span class="keyword">null</span>。</span><br><span class="line">给定一个由Node节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。 </span><br><span class="line">【要求】</span><br><span class="line">时间复杂度O(N)，额外空间复杂度O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash表做法  空间复杂度O（N）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老</span></span><br><span class="line">        <span class="comment">// map.get(cur) 新</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).rand = map.get(cur.rand);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝链表结点，并插入到链表中，然后按对获取结点，设置rand值，再分离next指针，返回链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// copy node and link to every node</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 1' -&gt; 2</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老 next 老的下一个</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// set copy node rand</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 1' -&gt; 2 -&gt; 2'</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// cur 老</span></span><br><span class="line">        <span class="comment">// cur.next 新 copy</span></span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.rand = cur.rand != <span class="keyword">null</span> ? cur.rand.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// head head.next</span></span><br><span class="line">    Node res = head.next;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null </span><br><span class="line">【要求】</span><br><span class="line">如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line"><span class="comment">//当有环时，快指针和慢指针相遇后，慢指针接着往下走，快指针回到头结点，每次走一步，他们再次相遇的点就是第一个入环节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n1 慢  n2 快</span></span><br><span class="line">    Node n1 = head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line">    Node n2 = head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n2.next == <span class="keyword">null</span> || n2.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line">    <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line"><span class="comment">//记录链表长度，如果最后一个结点不同，则不相交</span></span><br><span class="line"><span class="comment">//相交的话，减去长链表的和短链表的差值，同长之后一起遍历，判断结点是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n  :  链表1长度减去链表2长度的值</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">    <span class="comment">//长链表先走差值步</span></span><br><span class="line">    n = Math.abs(n);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line"><span class="comment">//两个有环链表的三种情况：</span></span><br><span class="line"><span class="comment">//1.相交于入环节点或环外，loop1 == loop2，和环没有任何关系或者入环节点相交，直接当做无环相交</span></span><br><span class="line"><span class="comment">//2.不相交</span></span><br><span class="line"><span class="comment">//3.环内相交，loop走一圈，如果遇到了loop2，则环内相交，否则不相交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;</span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//相交入环节点或环外</span></span><br><span class="line">    <span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">先序：任何子树的处理顺序都是，先头节点、再左子树、然后右子树</span><br><span class="line"></span><br><span class="line">中序：任何子树的处理顺序都是，先左子树、再头节点、然后右子树</span><br><span class="line"></span><br><span class="line">后序：任何子树的处理顺序都是，先左子树、再右子树、然后头节点</span><br><span class="line"></span><br><span class="line">1）理解递归序</span><br><span class="line"></span><br><span class="line">2）先序、中序、后序都可以在递归序的基础上加工出来</span><br><span class="line"></span><br><span class="line">3）第一次到达一个节点就打印就是先序、第二次打印即中序、第三次即后序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上就是递归序</span></span><br><span class="line"><span class="comment">// 先序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    pre(head.left);</span><br><span class="line">    pre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    in(head.left);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">    in(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序打印所有节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos(head.left);</span><br><span class="line">    pos(head.right);</span><br><span class="line">    System.out.println(head.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用非递归的方式实现</span></span><br><span class="line"><span class="comment">//先序</span></span><br><span class="line"><span class="comment">//头结点压入栈，然后对栈实现pop弹出并打印，然后依次压入弹出的右、左结点</span></span><br><span class="line"><span class="comment">//入栈顺序：头-右-左 出栈顺序：头-左-右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归的中序遍历</span></span><br><span class="line"><span class="comment">//压入每个结点的左结点，压完时弹出栈，并打印，然后压入它的右结点，继续遍历右结点的左树</span></span><br><span class="line"><span class="comment">//入栈顺序：头-左-左 出栈顺序：左-左-头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归的后序遍历</span></span><br><span class="line"><span class="comment">//头结点压入栈，然后对栈实现pop弹出并打印，然后依次压入弹出的左、右结点（如果是这种情况，则会出现后序遍历的相反输出操作）</span></span><br><span class="line"><span class="comment">//所以只需要弄两个栈，一个栈弹出的内容压到第二个栈中，最后输出第二个栈的内容</span></span><br><span class="line"><span class="comment">//入栈顺序 头-左-右 出栈顺序：头-右-左 -&gt;入第二个栈后顺序：左右头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            head = s1.pop();</span><br><span class="line">            s2.push(head);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            System.out.print(s2.pop().value + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只用一个栈实现非递归的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos2</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//h用于记录上一个打印的节点</span></span><br><span class="line">        stack.push(h);</span><br><span class="line">        Node c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            c = stack.peek();</span><br><span class="line">            <span class="comment">//如果h不是c的左右节点，代表c的左右节点没处理过，那么先压入左树处理</span></span><br><span class="line">            <span class="keyword">if</span> (c.left != <span class="keyword">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">                stack.push(c.left);</span><br><span class="line">            <span class="comment">//如果h处于c的左节点，并且c的右节点不为空，压入右树处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="keyword">null</span> &amp;&amp; h != c.right) &#123;</span><br><span class="line">                stack.push(c.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//c的左右节点已经处理过了，打印c节点</span></span><br><span class="line">                System.out.print(stack.pop().value + <span class="string">" "</span>);</span><br><span class="line">                h = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现二叉树的按层遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">level</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树最宽的层有多少个节点</span></span><br><span class="line"><span class="comment">//思路：map中存储&lt;Node,层数&gt;,用一个变量来存储当前的层数，当队列中取出来的节点层数与当前层数不同时，则代表上一层遍历结束，计算上一层的层数</span></span><br><span class="line"><span class="comment">//宽度都是需要进入下一层时才开始计算，所以最后一层要单独计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthUseMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    <span class="comment">// key 在 哪一层，value</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    levelMap.put(head, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> curNodeLevel = levelMap.get(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevel++;</span><br><span class="line">            curLevelNodes = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, curLevelNodes);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用hashMap计算二叉树最大宽度</span></span><br><span class="line"><span class="comment">//遍历，并且记录每次遍历的最右边的子节点，它就是下一层的最右边的节点，每次遍历一层，比较对象是否相等，相等则到达当前层最右边位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxWidthNoMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(head);</span><br><span class="line">    Node curEnd = head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line">    Node nextEnd = <span class="keyword">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevelNodes = <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">            nextEnd = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">            nextEnd = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        curLevelNodes++;</span><br><span class="line">        <span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">            max = Math.max(max, curLevelNodes);</span><br><span class="line">            curLevelNodes = <span class="number">0</span>;</span><br><span class="line">            curEnd = nextEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二叉树的序列化和反序列化</span><br><span class="line"></span><br><span class="line">1）可以用先序或者中序或者后序或者按层遍历，来实现二叉树的序列化</span><br><span class="line"></span><br><span class="line">2）用了什么方式序列化，就用什么样的方式反序列化</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序-序列化  不要忽略空，每个节点都有左右两个NULL值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pres</span><span class="params">(Node head, Queue&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans.add(String.valueOf(head.value));</span><br><span class="line">        pres(head.left, ans);</span><br><span class="line">        pres(head.right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序--反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">preb</span><span class="params">(Queue&lt;String&gt; prelist)</span> </span>&#123;</span><br><span class="line">    String value = prelist.poll();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    head.left = preb(prelist);</span><br><span class="line">    head.right = preb(prelist);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按层遍历序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">levelSerial</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ans.add(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//加入队列时序列化</span></span><br><span class="line">        ans.add(String.valueOf(head.value));</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">        queue.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans.add(String.valueOf(head.left.value));</span><br><span class="line">                queue.add(head.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//左节点等于空，加序列化，不加队列</span></span><br><span class="line">                ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ans.add(String.valueOf(head.right.value));</span><br><span class="line">                queue.add(head.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//右节点等于空，加序列化，不加队列</span></span><br><span class="line">                ans.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">二叉树结构如下定义：</span><br><span class="line">Class Node &#123;</span><br><span class="line">  V value;</span><br><span class="line">  Node left;</span><br><span class="line">  Node right;</span><br><span class="line">  Node parent;</span><br><span class="line">&#125;</span><br><span class="line">给你二叉树中的某个节点，返回该节点的中序遍历的后继节点</span><br><span class="line">     <span class="number">1</span></span><br><span class="line">  <span class="number">2</span>	    <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>   <span class="number">7</span></span><br><span class="line">中序遍历：<span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">7</span></span><br><span class="line"><span class="number">4</span>的后继节点是<span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果有右树，找到它右树的最左节点</span></span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无右子树，循环找到node节点是父...节点的左侧时，返回</span></span><br><span class="line">        Node parent = node.parent;</span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.right == node) &#123; <span class="comment">// 当前节点是其父亲节点右孩子</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。 如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 </span><br><span class="line">给定一个输入参数N，代表纸条都从下边向上方连续对折N次。 请从上到下打印所有折痕的方向。 </span><br><span class="line">例如:N&#x3D;1时，打印: down N&#x3D;2时，打印: down down up </span><br><span class="line"></span><br><span class="line">思路：等于一个二叉树，头结点down、左树全是down、右树全是up</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归过程，来到了某一个节点，</span></span><br><span class="line"><span class="comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span></span><br><span class="line"><span class="comment">//printProcess(1, N, true);</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> N, <span class="keyword">boolean</span> down)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过层数进行递归</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//递归的中序遍历</span></span><br><span class="line">    System.out.println(down ? <span class="string">"凹 "</span> : <span class="string">"凸 "</span>);</span><br><span class="line">    printProcess(i + <span class="number">1</span>, N, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）假设以X节点为头，假设可以向X左树和X右树要任何信息</span><br><span class="line">2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）</span><br><span class="line">3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息</span><br><span class="line">4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S</span><br><span class="line">5）递归函数都返回S，每一棵子树都这么要求</span><br><span class="line">6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断是否是一颗完全二叉树</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">  1.左/右树是否平衡</span></span><br><span class="line"><span class="comment">  2.左/右树的高度是否超过1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 左、右要求一样，Info 信息返回的结构体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isBalaced;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> b, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        isBalaced = b;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是一颗完全二叉树</span></span><br><span class="line"><span class="comment">//左树平衡、右树平衡、左右树高度相差不超过1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process2(X.left);</span><br><span class="line">    Info rightInfo = process2(X.right);</span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!leftInfo.isBalaced || !rightInfo.isBalaced || Math.abs(leftInfo.height - rightInfo.height) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，任何两个节点之间都存在距离,返回整棵二叉树的最大距离</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  思路：</span></span><br><span class="line"><span class="comment">  1.与X无关：</span></span><br><span class="line"><span class="comment">      左树/右树的最大距离</span></span><br><span class="line"><span class="comment">  2.与X有关：</span></span><br><span class="line"><span class="comment">      左树的高度 + 右树的高度 + 1</span></span><br><span class="line"><span class="comment">  3.从左/右树要得到的信息：</span></span><br><span class="line"><span class="comment">      左/右树的高度、最大距离。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxDistance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        maxDistance = dis;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前树的最大高度 = Max(左树,右树)高度 + 1</span></span><br><span class="line"><span class="comment">//当前树最大距离 = Max ( Max(左树,右树)距离, 左树高度+右树高度+1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);</span><br><span class="line">    <span class="comment">//左右树最大高度+1</span></span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左右数高度+1 || 左树最大距离 || 右树最大距离  三者求max</span></span><br><span class="line">    <span class="keyword">int</span> maxDistance = Math.max(</span><br><span class="line">        Math.max(leftInfo.maxDistance, rightInfo.maxDistance),</span><br><span class="line">        leftInfo.height + rightInfo.height + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(maxDistance, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，</span><br><span class="line">返回这颗二叉树中最大的二叉搜索子树的节点数量</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思路：</span></span><br><span class="line"><span class="comment">   1.与X无关：</span></span><br><span class="line"><span class="comment">     1.1 左/右树是否是二叉搜索树</span></span><br><span class="line"><span class="comment">     1.2 左/右树的子树有多少个二叉搜索树节点</span></span><br><span class="line"><span class="comment">   2.与X相关：</span></span><br><span class="line"><span class="comment">     2.1 左树的最大值是否小于X</span></span><br><span class="line"><span class="comment">     2.2 右树的最小值是否大于X</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isAllBST;</span><br><span class="line">    <span class="comment">//最大的搜索二叉树节点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxSubBSTSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> is, <span class="keyword">int</span> size, <span class="keyword">int</span> mi, <span class="keyword">int</span> ma)</span> </span>&#123;</span><br><span class="line">        isAllBST = is;</span><br><span class="line">        maxSubBSTSize = size;</span><br><span class="line">        min = mi;</span><br><span class="line">        max = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//先赋值当前节点的最大值和最小值</span></span><br><span class="line">    <span class="keyword">int</span> min = X.value;</span><br><span class="line">    <span class="keyword">int</span> max = X.value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果左树不为空</span></span><br><span class="line">    <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//取X和左树的min、max的最大值，最小值</span></span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右树不为空</span></span><br><span class="line">    <span class="keyword">if</span>(rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//同样</span></span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//先赋默认值</span></span><br><span class="line">    <span class="keyword">int</span> maxSubBSTSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先赋值左、右的最大二叉搜索子树的节点数量</span></span><br><span class="line">    <span class="keyword">if</span>(leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightInfo !=<span class="keyword">null</span>) &#123;</span><br><span class="line">        maxSubBSTSize = Math.max(maxSubBSTSize, rightInfo.maxSubBSTSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAllBST = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//结点也是搜索二叉树的一部分</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        <span class="comment">// 左树整体需要是搜索二叉树</span></span><br><span class="line">        (  leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.isAllBST    )</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        (  rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.isAllBST    )</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        <span class="comment">// 左树最大值&lt;x</span></span><br><span class="line">        (leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : leftInfo.max &lt; X.value)</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        (rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : rightInfo.min &gt; X.value)</span><br><span class="line">    ) &#123;</span><br><span class="line">    <span class="comment">//取左树的max + 右树的max + 1</span></span><br><span class="line">        maxSubBSTSize = </span><br><span class="line">            (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize)</span><br><span class="line">            +</span><br><span class="line">            (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize)</span><br><span class="line">            +</span><br><span class="line">            <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置该节点及子树都是搜索二叉树</span></span><br><span class="line">        isAllBST = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">派对的最大快乐值</span><br><span class="line">这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：</span><br><span class="line">1.如果某个员工来了，那么这个员工的所有直接下级都不能来</span><br><span class="line">2.派对的整体快乐值是所有到场员工快乐值的累加</span><br><span class="line">3.你的目标是让派对的整体快乐值尽量大</span><br><span class="line">给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1.X不发请柬：</span></span><br><span class="line"><span class="comment">  1.1 X/happy = 0</span></span><br><span class="line"><span class="comment">  1.2 累加各个max(下层员工来的maxHappy, 不来的maxHappy)</span></span><br><span class="line"><span class="comment">2.X发请柬：</span></span><br><span class="line"><span class="comment">  2.1 X的快乐值 x.happy</span></span><br><span class="line"><span class="comment">  2.2 每个直接下层员工不来，累加他们的最大快乐值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> happy;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; nexts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        happy = h;</span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="comment">//来的最大快乐值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> yes;</span><br><span class="line">    <span class="comment">//不来的最大快乐值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        yes = y;</span><br><span class="line">        no = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process2</span><span class="params">(Employee x)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//基层员工，最底层，没有下级节点</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(x.nexts.isEmpty()</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(x.happy, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//X来的当前快乐值</span></span><br><span class="line">    <span class="keyword">int</span> yes = x.happy;</span><br><span class="line">  <span class="comment">//不来为0</span></span><br><span class="line">    <span class="keyword">int</span> no = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Employee next : x.nexts) &#123;</span><br><span class="line">        Info nextInfo = process2(next);</span><br><span class="line">        <span class="comment">//当X来，则累加它子树不来的max最大快乐值</span></span><br><span class="line">        yes += nextInfo.no;</span><br><span class="line">        <span class="comment">//当X不来，则累加子树Max(来/不来)的最大快乐值</span></span><br><span class="line">        no += Math.max(nextInfo.yes, nextInfo.no);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(yes, no);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line">1.与X无关：</span><br><span class="line">  1.1 Max（左树的答案，右树的答案）</span><br><span class="line">  1.2 左右树最搜索二叉树头结点</span><br><span class="line">  1.3 搜索二叉树的结点数量</span><br><span class="line">2.与X有关：</span><br><span class="line">  2.1 左树的Max&lt;X&lt;右树的Min</span><br><span class="line">  2.2 左右树的Max、Min</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一棵子树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最大搜二叉树结点</span></span><br><span class="line">    <span class="keyword">public</span> Node maxSubBSTHead;</span><br><span class="line">    <span class="comment">//结点数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxSubBSTSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(Node h, <span class="keyword">int</span> size, <span class="keyword">int</span> mi, <span class="keyword">int</span> ma)</span> </span>&#123;</span><br><span class="line">        maxSubBSTHead = h;</span><br><span class="line">        maxSubBSTSize = size;</span><br><span class="line">        min = mi;</span><br><span class="line">        max = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);</span><br><span class="line">    <span class="keyword">int</span> min = X.value;</span><br><span class="line">    <span class="keyword">int</span> max = X.value;</span><br><span class="line">    Node maxSubBSTHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSubBSTSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, leftInfo.min);</span><br><span class="line">        max = Math.max(max, leftInfo.max);</span><br><span class="line">        maxSubBSTHead = leftInfo.maxSubBSTHead;</span><br><span class="line">        maxSubBSTSize = leftInfo.maxSubBSTSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        min = Math.min(min, rightInfo.min);</span><br><span class="line">        max = Math.max(max, rightInfo.max);</span><br><span class="line">        <span class="keyword">if</span> (rightInfo.maxSubBSTSize &gt; maxSubBSTSize) &#123;</span><br><span class="line">            maxSubBSTHead = rightInfo.maxSubBSTHead;</span><br><span class="line">            maxSubBSTSize = rightInfo.maxSubBSTSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左树整体是否是搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> ((leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.maxSubBSTHead == X.left &amp;&amp; leftInfo.max &lt; X.value))</span><br><span class="line">        &amp;&amp; (rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (rightInfo.maxSubBSTHead == X.right &amp;&amp; rightInfo.min &gt; X.value))) &#123;</span><br><span class="line">        maxSubBSTHead = X;</span><br><span class="line">        maxSubBSTSize = (leftInfo == <span class="keyword">null</span> ? <span class="number">0</span> : leftInfo.maxSubBSTSize)</span><br><span class="line">            + (rightInfo == <span class="keyword">null</span> ? <span class="number">0</span> : rightInfo.maxSubBSTSize) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(maxSubBSTHead, maxSubBSTSize, min, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一棵二叉树的头节点head，返回这颗二叉树中是不是完全二叉树</span><br><span class="line"></span><br><span class="line">思路：</span><br><span class="line">1.X是否是满二叉树</span><br><span class="line">  1.1 左树的高度&#x3D;右树的高度，并且都是满二叉树</span><br><span class="line">2.X的最后一层没有越过左树</span><br><span class="line">  2.1 左树是完全二叉树，右树是满二叉树，并且左树高度比右树高度大1</span><br><span class="line">3.X的最后一层刚好填满左树</span><br><span class="line">  3.1 左&#x2F;右树都是满二叉树，并且左树高度比右树高度大1</span><br><span class="line">4.X的最后一层越过左树，来到右树</span><br><span class="line">  4.1 左树是完全二叉树，右树是满二叉树，并且左树高度比右树高度大1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每一棵子树，是否是满二叉树、是否是完全二叉树、高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否是满二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isFull;</span><br><span class="line">    <span class="comment">//是否是完全二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isCBT;</span><br><span class="line">    <span class="comment">//高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> full, <span class="keyword">boolean</span> cbt, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        isFull = full;</span><br><span class="line">        isCBT = cbt;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (X == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//空树-满二叉树-完全二叉树-高度0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftInfo = process(X.left);</span><br><span class="line">    Info rightInfo = process(X.right);</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//左树满、右树满、并且高度相同</span></span><br><span class="line">    <span class="keyword">boolean</span> isFull = leftInfo.isFull </span><br><span class="line">        &amp;&amp; </span><br><span class="line">        rightInfo.isFull </span><br><span class="line">        &amp;&amp; leftInfo.height == rightInfo.height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isCBT = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isFull) &#123;</span><br><span class="line">        isCBT = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 以x为头整棵树，不满</span></span><br><span class="line">        <span class="comment">//左右树都是完全二叉树才进行判断逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (leftInfo.isCBT &amp;&amp; rightInfo.isCBT) &#123;</span><br><span class="line">            <span class="comment">//左树是完全二叉树、右树是满的、并且高度大1</span></span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isCBT </span><br><span class="line">                &amp;&amp; rightInfo.isFull </span><br><span class="line">                &amp;&amp; leftInfo.height == rightInfo.height + <span class="number">1</span>) &#123;</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左树是满的、右树也是满的，并且高度大1</span></span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isFull </span><br><span class="line">                &amp;&amp; </span><br><span class="line">                rightInfo.isFull </span><br><span class="line">                &amp;&amp; leftInfo.height == rightInfo.height + <span class="number">1</span>) &#123;</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左树是满的，右树是完全二叉树，并且高度相同</span></span><br><span class="line">            <span class="keyword">if</span> (leftInfo.isFull </span><br><span class="line">                &amp;&amp; rightInfo.isCBT &amp;&amp; leftInfo.height == rightInfo.height) &#123;</span><br><span class="line">                isCBT = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(isFull, isCBT, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）最自然智慧的算法</span><br><span class="line"></span><br><span class="line">2）用一种局部最功利的标准，总是做出在当前看来是最好的选择</span><br><span class="line"></span><br><span class="line">3）难点在于证明局部最功利的标准可以得到全局最优解</span><br><span class="line"></span><br><span class="line">4）对于贪心算法的学习主要以增加阅历和经验为主</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个由字符串组成的数组strs，</span><br><span class="line">必须把所有的字符串拼接起来，</span><br><span class="line">返回所有可能的拼接结果中，字典序最小的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="comment">// strs里放着所有的字符串</span></span><br><span class="line"><span class="comment">// 已经使用过的字符串的下标，在use里登记了，不要再使用了</span></span><br><span class="line"><span class="comment">// 之前使用过的字符串，拼接成了-&gt; path</span></span><br><span class="line"><span class="comment">// 用all收集所有可能的拼接结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String[] strs, HashSet&lt;Integer&gt; use, String path, ArrayList&lt;String&gt; all)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (use.size() == strs.length) &#123;</span><br><span class="line">        all.add(path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!use.contains(i)) &#123;</span><br><span class="line">                <span class="comment">//深度优先遍历，加完使用完还原现场删掉它</span></span><br><span class="line">                use.add(i);</span><br><span class="line">                process(strs, use, path + strs[i], all);</span><br><span class="line">                use.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a + b).compareTo(b + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString2</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> MyComparator());</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        res += strs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。</span><br><span class="line">给你每一个项目开始的时间和结束的时间</span><br><span class="line">你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。</span><br><span class="line">返回最多的宣讲场次。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="comment">// 还剩什么会议都放在programs里</span></span><br><span class="line"><span class="comment">// done 之前已经安排了多少会议，数量</span></span><br><span class="line"><span class="comment">// timeLine目前来到的时间点是什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前来到timeLine的时间点，已经安排了done多的会议，剩下的会议programs可以自由安排</span></span><br><span class="line"><span class="comment">// 返回能安排的最多会议数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(Program[] programs, <span class="keyword">int</span> done, <span class="keyword">int</span> timeLine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (programs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有会议可以选择</span></span><br><span class="line">    <span class="keyword">int</span> max = done;</span><br><span class="line">    <span class="comment">// 当前安排的会议是什么会，每一个都枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (programs[i].start &gt;= timeLine) &#123;</span><br><span class="line">            <span class="comment">//移除i位置上的元素，拷贝新数组，所以不需要还原现场</span></span><br><span class="line">            Program[] next = copyButExcept(programs, i);</span><br><span class="line">            max = Math.max(max, process(next, done + <span class="number">1</span>, programs[i].end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="comment">//按照结束时间排序，结束时间最早的，添加进安排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange2</span><span class="params">(Program[] programs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(programs, <span class="keyword">new</span> ProgramComparator());</span><br><span class="line">    <span class="keyword">int</span> timeLine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; programs.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timeLine &lt;= programs[i].start) &#123;</span><br><span class="line">        result++;</span><br><span class="line">        timeLine = programs[i].end;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串str，只由‘X’和‘.’两种字符构成。</span><br><span class="line">‘X’表示墙，不能放灯，也不需要点亮</span><br><span class="line">‘.’表示居民点，可以放灯，需要点亮</span><br><span class="line">如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮</span><br><span class="line">返回如果点亮str中所有需要点亮的位置，至少需要几盏灯</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str[index....]位置，自由选择放灯还是不放灯</span></span><br><span class="line"><span class="comment">// str[0..index-1]位置呢？已经做完决定了，那些放了灯的位置，存在lights里</span></span><br><span class="line"><span class="comment">// 要求选出能照亮所有.的方案，并且在这些有效的方案中，返回最少需要几个灯</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, HashSet&lt;Integer&gt; lights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) &#123; <span class="comment">// 结束的时候</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">'X'</span>) &#123; <span class="comment">// 当前位置是点的话</span></span><br><span class="line">                <span class="keyword">if</span> (!lights.contains(i - <span class="number">1</span>) </span><br><span class="line">                    &amp;&amp; !lights.contains(i) </span><br><span class="line">                    &amp;&amp; !lights.contains(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lights.size();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// str还没结束</span></span><br><span class="line">        <span class="comment">// i   X  .</span></span><br><span class="line">        <span class="comment">//当i位置不放灯的递归答案</span></span><br><span class="line">        <span class="keyword">int</span> no = process(str, index + <span class="number">1</span>, lights);</span><br><span class="line">        <span class="keyword">int</span> yes = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//当i位置是'.'，并且放灯的答案</span></span><br><span class="line">        <span class="keyword">if</span> (str[index] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            lights.add(index);</span><br><span class="line">            yes = process(str, index + <span class="number">1</span>, lights);</span><br><span class="line">            lights.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//求最小值</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(no, yes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="comment">// i位置为 X --&gt;i = i+1</span></span><br><span class="line"><span class="comment">// i位置为i时：</span></span><br><span class="line"><span class="comment">//  -&gt; i+1位置为X --&gt; i放灯, i=i+2</span></span><br><span class="line"><span class="comment">//  -&gt; i+1位置为i</span></span><br><span class="line"><span class="comment">//     -&gt; i+2位置为X--&gt;i+1放灯，i=i+3</span></span><br><span class="line"><span class="comment">//     -&gt; i+2位置为i--&gt;i+1放灯，i=i+3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minLight2</span><span class="params">(String road)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = road.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> light = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; str.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[index] == <span class="string">'X'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// i -&gt; .</span></span><br><span class="line">            <span class="comment">//不管什么情况，都需要找个位置放灯，然后移动下标</span></span><br><span class="line">            light++;</span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> == str.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[index + <span class="number">1</span>] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                    index = index + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = index + <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一块金条切成两半，是需要花费和长度数值一样的铜板的。</span><br><span class="line">比如长度为20的金条，不管怎么切，都要花费20个铜板。 一群人想整分整块金条，怎么分最省铜板? </span><br><span class="line"></span><br><span class="line">例如,给定数组&#123;10,20,30&#125;，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。</span><br><span class="line"></span><br><span class="line">如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;一共花费110铜板。</span><br><span class="line">但如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。</span><br><span class="line">输入一个数组，返回分割的最小代价。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            ans = Math.min(ans, process(copyAndMergeTwo(arr, i, j), pre + arr[i] + arr[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="comment">//哈夫曼树，数据压入小根堆中，依次弹出两个数相加（累加到sum），并再次压入栈中，一直到栈中只剩下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lessMoney2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        pQ.add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pQ.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cur = pQ.poll() + pQ.poll();</span><br><span class="line">        sum += cur;</span><br><span class="line">        pQ.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 正数数组costs、正数数组profits、正数K、正数M</span><br><span class="line">costs[i]表示i号项目的花费</span><br><span class="line">profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)</span><br><span class="line">K表示你只能串行的最多做k个项目</span><br><span class="line">M表示你初始的资金</span><br><span class="line">说明: 每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。</span><br><span class="line">输出：你最后获得的最大钱数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法</span></span><br><span class="line"><span class="comment">//按照花费放进小根堆中，按照利润放到大根堆中</span></span><br><span class="line"><span class="comment">//弹出小于当前资金（W）的项目，依次塞到大根堆中，取堆顶那个，重复循环，直到项目达到K个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> W, <span class="keyword">int</span>[] Profits, <span class="keyword">int</span>[] Capital)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; minCostQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">    <span class="comment">//大根堆</span></span><br><span class="line">    PriorityQueue&lt;Program&gt; maxProfitQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Profits.length; i++) &#123;</span><br><span class="line">        minCostQ.add(<span class="keyword">new</span> Program(Profits[i], Capital[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;</span><br><span class="line">            maxProfitQ.add(minCostQ.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxProfitQ.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> W;</span><br><span class="line">        &#125;</span><br><span class="line">        W += maxProfitQ.poll().p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）有若干个样本a、b、c、d…类型假设是V</span><br><span class="line">2）在并查集中一开始认为每个样本都在单独的集合里</span><br><span class="line">3）用户可以在任何时候调用如下两个方法：</span><br><span class="line">       boolean isSameSet(V x, V y) : 查询样本x和样本y是否属于一个集合</span><br><span class="line">       void union(V x, V y) : 把x和y各自所在集合的所有样本合并成一个集合</span><br><span class="line">4） isSameSet和union方法的代价越低越好</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code01_UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionSet</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//样本对应的样本节点链</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;V, Node&lt;V&gt;&gt; nodes;</span><br><span class="line">        <span class="comment">//每个样本节点对应的父样本节点</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Node&lt;V&gt;&gt; parents;</span><br><span class="line">        <span class="comment">//样本头节店和它底下的链路数量</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node&lt;V&gt;, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionSet</span><span class="params">(List&lt;V&gt; values)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            parents = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (V cur : values) &#123;</span><br><span class="line">                Node&lt;V&gt; node = <span class="keyword">new</span> Node&lt;&gt;(cur);</span><br><span class="line">                nodes.put(cur, node);</span><br><span class="line">                parents.put(node, node);</span><br><span class="line">                sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//扁平化链表，调用该方法次数越多，它的时间复杂度越低，因为链表约扁平</span></span><br><span class="line">        <span class="comment">// 从点cur开始，一直往上找，找到不能再往上的代表点，返回</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;V&gt; <span class="title">findFather</span><span class="params">(Node&lt;V&gt; cur)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//扁平化操作，把一条链表的长度，规整成所有都指向最终的头节点即可</span></span><br><span class="line">            Stack&lt;Node&lt;V&gt;&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (cur != parents.get(cur)) &#123;</span><br><span class="line">                path.push(cur);</span><br><span class="line">                cur = parents.get(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cur头节点</span></span><br><span class="line">            <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">                parents.put(path.pop(), cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> findFather(nodes.get(a)) == findFather(nodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!nodes.containsKey(a) || !nodes.containsKey(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node&lt;V&gt; aHead = findFather(nodes.get(a));</span><br><span class="line">            Node&lt;V&gt; bHead = findFather(nodes.get(b));</span><br><span class="line">            <span class="keyword">if</span> (aHead != bHead) &#123;</span><br><span class="line">                <span class="keyword">int</span> aSetSize = sizeMap.get(aHead);</span><br><span class="line">                <span class="keyword">int</span> bSetSize = sizeMap.get(bHead);</span><br><span class="line">                <span class="comment">//数量短的链表合并到数量长的链表中，降低扁平化的循环次数</span></span><br><span class="line">                Node&lt;V&gt; big = aSetSize &gt;= bSetSize ? aHead : bHead;</span><br><span class="line">                Node&lt;V&gt; small = big == aHead ? bHead : aHead;</span><br><span class="line">                parents.put(small, big);</span><br><span class="line">                sizeMap.put(big, aSetSize + bSetSize);</span><br><span class="line">                sizeMap.remove(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1,10,13) (2,10,37) (400,500,37)</span></span><br><span class="line"><span class="comment">// 如果两个user，a字段一样、或者b字段一样、或者c字段一样，就认为是一个人</span></span><br><span class="line"><span class="comment">// 请合并users，返回合并之后的用户数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeUsers</span><span class="params">(List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">    UnionSet&lt;User&gt; unionFind = <span class="keyword">new</span> UnionSet&lt;&gt;(users);</span><br><span class="line">    HashMap&lt;String, User&gt; mapA = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;String, User&gt; mapB = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;String, User&gt; mapC = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(User user : users) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mapA.containsKey(user.a)) &#123;</span><br><span class="line">            unionFind.union(user, mapA.get(user.a));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            mapA.put(user.a, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mapB.containsKey(user.b)) &#123;</span><br><span class="line">            unionFind.union(user, mapB.get(user.b));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            mapB.put(user.b, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mapC.containsKey(user.c)) &#123;</span><br><span class="line">            unionFind.union(user, mapC.get(user.c));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            mapC.put(user.c, user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向并查集询问，合并之后，还有多少个集合？</span></span><br><span class="line">    <span class="keyword">return</span> unionFind.getSetNum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）由点的集合和边的集合构成</span><br><span class="line"></span><br><span class="line">2）虽然存在有向图和无向图的概念，但实际上都可以用有向图来表达</span><br><span class="line"></span><br><span class="line">3）边上可能带有权值</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点结构的描述  A  0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//点上的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//入度（多少条边指向这个点）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> in;</span><br><span class="line">    <span class="comment">//出度（多少条边出这个点）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> out;</span><br><span class="line">    <span class="comment">//点连出去的节点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">    <span class="comment">//点连出去的边</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="comment">//边的方向</span></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//&lt;编号，点&gt;</span></span><br><span class="line">  <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="comment">//边</span></span><br><span class="line">  <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把各种数据结构的图表达形式转换成固定的算法解析的格式</span></span><br><span class="line"><span class="comment">// matrix 所有的边</span></span><br><span class="line"><span class="comment">// N*3 的矩阵</span></span><br><span class="line"><span class="comment">// [weight, from节点上面的值，to节点上面的值]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123; </span><br><span class="line">        <span class="comment">// matrix[0][0], matrix[0][1]  matrix[0][2]</span></span><br><span class="line">        Integer weight = matrix[i][<span class="number">0</span>];</span><br><span class="line">        Integer from = matrix[i][<span class="number">1</span>];</span><br><span class="line">        Integer to = matrix[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(from)) &#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> Node(from));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(to)) &#123;</span><br><span class="line">            graph.nodes.put(to, <span class="keyword">new</span> Node(to));</span><br><span class="line">        &#125;</span><br><span class="line">        Node fromNode = graph.nodes.get(from);</span><br><span class="line">        Node toNode = graph.nodes.get(to);</span><br><span class="line">        Edge newEdge = <span class="keyword">new</span> Edge(weight, fromNode, toNode);</span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        fromNode.out++;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        fromNode.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">宽度优先遍历</span><br><span class="line">1，利用队列实现</span><br><span class="line">2，从源节点开始依次按照宽度进队列，然后弹出</span><br><span class="line">3，每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</span><br><span class="line">4，直到队列变空</span><br><span class="line"></span><br><span class="line">深度优先遍历</span><br><span class="line">1，利用栈实现</span><br><span class="line">2，从源节点开始把节点按照深度放入栈，然后弹出</span><br><span class="line">3，每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</span><br><span class="line">4，直到栈变空</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line"><span class="comment">// SET 过滤重复的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    queue.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                set.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="comment">//先把节点压入栈中，输出，然后遍历它的next节点，发现没遍历过则压入原节点和next节点（并打印），break</span></span><br><span class="line"><span class="comment">//等next节点的深度遍历完后，最后重新弹出原节点继续遍历没被遍历完的next节点，周而复始</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图的拓扑排序算法</span><br><span class="line"></span><br><span class="line">1）在图中找到所有入度为0的点输出</span><br><span class="line">2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始</span><br><span class="line">3）图的所有点都被删除后，依次输出的顺序就是拓扑排序</span><br><span class="line"></span><br><span class="line">要求：有向图且其中没有环</span><br><span class="line">应用：事件安排、编译顺序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// directed graph and no loop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key：某一个node</span></span><br><span class="line">    <span class="comment">// value：剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 剩余入度为0的点，才能进这个队列</span></span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>) &#123;</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拓扑排序的结果，依次加入result</span></span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">        Node cur = zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroInQueue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最小生成树算法之Kruskal</span><br><span class="line"></span><br><span class="line">1）总是从权值最小的边开始考虑，依次考察权值依次变大的边</span><br><span class="line">2）当前的边要么进入最小生成树的集合，要么丢弃</span><br><span class="line">3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边</span><br><span class="line">4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边</span><br><span class="line">5）考察完所有边之后，最小生成树的集合也得到了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有边权重排序，并依次使用并查集判断是否需要使用边来合并from和to的节点</span></span><br><span class="line"><span class="comment">//如果是无向图，因为按照集合边淘汰原则，丢失了（无向边=来回的双向边）双向边的一部分，所以需要补边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">    unionFind.makeSets(graph.nodes.values());</span><br><span class="line">    <span class="comment">//根据边的权重排序，小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">      priorityQueue.add(edge);  <span class="comment">// O(logM)</span></span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="comment">// M 条边</span></span><br><span class="line">      Edge edge = priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line">      <span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">        result.add(edge);</span><br><span class="line">        unionFind.union(edge.from, edge.to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最小生成树算法之Prim</span><br><span class="line"></span><br><span class="line">1）可以从任意节点出发来寻找最小生成树</span><br><span class="line">2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边</span><br><span class="line">3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环</span><br><span class="line">4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）</span><br><span class="line">5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）</span><br><span class="line">6）当所有点都被选取，最小生成树就得到了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解锁的边进入小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哪些点被解锁出来了</span></span><br><span class="line">    HashSet&lt;Node&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 依次挑选的的边在result里</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for循环主要是为了防止森林，多个图</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">// 随便挑了一个点</span></span><br><span class="line">        <span class="comment">// node 是开始点</span></span><br><span class="line">        <span class="keyword">if</span> (!nodeSet.contains(node)) &#123;</span><br><span class="line">            nodeSet.add(node);</span><br><span class="line">            <span class="keyword">for</span> (Edge edge : node.edges) &#123; <span class="comment">// 由一个点，解锁所有相连的边</span></span><br><span class="line">                priorityQueue.add(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                Edge edge = priorityQueue.poll(); <span class="comment">// 弹出解锁的边中，最小的边</span></span><br><span class="line">                Node toNode = edge.to; <span class="comment">// 可能的一个新的点</span></span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(toNode)) &#123; <span class="comment">// 不含有的时候，就是新的点</span></span><br><span class="line">                    nodeSet.add(toNode);</span><br><span class="line">                    result.add(edge);</span><br><span class="line">                    <span class="comment">//解锁了新的点，解锁新的边</span></span><br><span class="line">                    <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                        priorityQueue.add(nextEdge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line"></span><br><span class="line">1）Dijkstra算法必须指定一个源点</span><br><span class="line">2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己的最小距离为0，源点到其他所有点的最小距离都为正无穷大</span><br><span class="line">3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步</span><br><span class="line">4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node from)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从head出发到所有点的最小距离</span></span><br><span class="line">    <span class="comment">// key : 从head出发到达key</span></span><br><span class="line">    <span class="comment">// value : 从head出发到达key的最小距离</span></span><br><span class="line">    <span class="comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distanceMap.put(from, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 已经求过距离的节点，存在selectedNodes中，以后再也不碰</span></span><br><span class="line">    HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// from 0</span></span><br><span class="line">    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">            Node toNode = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                distanceMap.put(edge.to, </span><br><span class="line">                                Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectedNodes.add(minNode);</span><br><span class="line">        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HashMap&lt;Node, Integer&gt; distanceMap, </span></span></span><br><span class="line"><span class="function"><span class="params">    HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进：优化每个节点都需要遍历获取最小路径的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HashMap&lt;Node, Integer&gt; distanceMap, </span></span></span><br><span class="line"><span class="function"><span class="params">    HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node node;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] nodes; <span class="comment">// 实际的堆结构</span></span><br><span class="line">    <span class="comment">// key 某一个node， value 上面堆中的位置</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;</span><br><span class="line">    <span class="comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 堆上有多少个点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeHeap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> Node[size];</span><br><span class="line">        heapIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span></span><br><span class="line">    <span class="comment">// 判断要不要更新，如果需要的话，就更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inHeap(node)) &#123;</span><br><span class="line">            distanceMap.put(node, Math.min(distanceMap.get(node), distance));</span><br><span class="line">            insertHeapify(node, heapIndexMap.get(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isEntered(node)) &#123;</span><br><span class="line">            nodes[size] = node;</span><br><span class="line">            heapIndexMap.put(node, size);</span><br><span class="line">            distanceMap.put(node, distance);</span><br><span class="line">            insertHeapify(node, size++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NodeRecord <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NodeRecord nodeRecord = <span class="keyword">new</span> NodeRecord(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>);</span><br><span class="line">        distanceMap.remove(nodes[size - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span></span><br><span class="line">        nodes[size - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        heapify(<span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">return</span> nodeRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeapify</span><span class="params">(Node node, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (distanceMap.get(nodes[index]) </span><br><span class="line">               &lt; distanceMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> smallest = left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">                ? left + <span class="number">1</span></span><br><span class="line">                : left;</span><br><span class="line">            smallest = distanceMap.get(nodes[smallest]) </span><br><span class="line">                &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">            <span class="keyword">if</span> (smallest == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(smallest, index);</span><br><span class="line">            index = smallest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEntered</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inHeap</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">        heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">        Node tmp = nodes[index1];</span><br><span class="line">        nodes[index1] = nodes[index2];</span><br><span class="line">        nodes[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进后的dijkstra算法</span></span><br><span class="line"><span class="comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra2</span><span class="params">(Node head, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    NodeHeap nodeHeap = <span class="keyword">new</span> NodeHeap(size);</span><br><span class="line">    nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);</span><br><span class="line">    HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">        NodeRecord record = nodeHeap.pop();</span><br><span class="line">        Node cur = record.node;</span><br><span class="line">        <span class="keyword">int</span> distance = record.distance;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : cur.edges) &#123;</span><br><span class="line">            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(cur, distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">暴力递归就是尝试 </span><br><span class="line">1，把问题转化为规模缩小了的同类问题的子问题</span><br><span class="line">2，有明确的不需要继续进行递归的条件(base case)</span><br><span class="line">3，有当得到了子问题的结果之后的决策过程</span><br><span class="line">4，不记录每一个子问题的解</span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印n层汉诺塔从最左边移动到最右边的全部过程</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.汉诺塔简单版本写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    leftToRight(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请把1~N层圆盘 从左 -&gt; 右</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftToRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from left to right"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftToMid(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from left to right"</span>);</span><br><span class="line">    midToRight(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请把1~N层圆盘 从左 -&gt; 中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftToMid</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from left to mid"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftToRight(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from left to mid"</span>);</span><br><span class="line">    rightToMid(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightToMid</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from right to mid"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rightToLeft(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from right to mid"</span>);</span><br><span class="line">    leftToMid(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midToRight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from mid to right"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    midToLeft(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from mid to right"</span>);</span><br><span class="line">    leftToRight(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midToLeft</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from mid to left"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    midToRight(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from mid to left"</span>);</span><br><span class="line">    rightToLeft(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightToLeft</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Move 1 from right to left"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rightToMid(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"Move "</span> + n + <span class="string">" from right to left"</span>);</span><br><span class="line">    midToLeft(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思想:（from -&gt; to）</span></span><br><span class="line"><span class="comment">  拆成三个大步：</span></span><br><span class="line"><span class="comment">    1.把N-1的圆盘移动到 other上</span></span><br><span class="line"><span class="comment">    2.把N的圆盘移动到to上</span></span><br><span class="line"><span class="comment">    3.把N-1的圆盘移动到to上（这步操作等于递归N-1的圆盘重新移动）</span></span><br><span class="line"><span class="comment">  移动的最优步数：(2^n -1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        func(n, <span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1~i 圆盘 目标是from -&gt; to， other是另外一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> N, String from, String to, String other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span>) &#123; <span class="comment">// base</span></span><br><span class="line">        System.out.println(<span class="string">"Move 1 from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func(N - <span class="number">1</span>, from, other, to);</span><br><span class="line">        System.out.println(<span class="string">"Move "</span> + N + <span class="string">" from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">        func(N - <span class="number">1</span>, other, to, from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归的版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> finish1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> base;</span><br><span class="line">    <span class="keyword">public</span> String from;</span><br><span class="line">    <span class="keyword">public</span> String to;</span><br><span class="line">    <span class="keyword">public</span> String other;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(<span class="keyword">boolean</span> f1, <span class="keyword">int</span> b, String f, String t, String o)</span> </span>&#123;</span><br><span class="line">        finish1 = <span class="keyword">false</span>;</span><br><span class="line">        base = b;</span><br><span class="line">        from = f;</span><br><span class="line">        to = t;</span><br><span class="line">        other = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi3</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Record&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(<span class="keyword">new</span> Record(<span class="keyword">false</span>, N, <span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>));</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Record cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur.base == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Move 1 from "</span> + cur.from + <span class="string">" to "</span> + cur.to);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.peek().finish1 = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur.finish1) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(<span class="keyword">new</span> Record(<span class="keyword">false</span>, cur.base - <span class="number">1</span>, cur.from, cur.other, cur.to));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Move "</span> + cur.base + <span class="string">" from "</span> + cur.from + <span class="string">" to "</span> + cur.to);</span><br><span class="line">                stack.push(<span class="keyword">new</span> Record(<span class="keyword">false</span>, cur.base - <span class="number">1</span>, cur.other, cur.to, cur.from));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个栈，请你逆序这个栈，</span><br><span class="line">不能申请额外的数据结构，</span><br><span class="line">只能使用递归函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1.先把栈底的元素拿出来</span></span><br><span class="line"><span class="comment">2.再递归调用函数依次拿出每次栈底的数据，重新push进去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//依次取出每次迭代的栈中的栈底元素</span></span><br><span class="line">    <span class="keyword">int</span> i = f(stack);</span><br><span class="line">    <span class="comment">//迭代取栈数据</span></span><br><span class="line">    reverse(stack);</span><br><span class="line">    <span class="comment">//最后栈底的元素肯定是原先栈头的元素，塞进去</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先取出栈元素，如果等于空，则直接返回栈底元素</span></span><br><span class="line">    <span class="keyword">int</span> result = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果栈还不为空，则继续一直到返回栈底的元素</span></span><br><span class="line">        <span class="keyword">int</span> last = f(stack);</span><br><span class="line">        <span class="comment">//重新将当前函数中的栈元素放到栈中</span></span><br><span class="line">        stack.push(result);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印一个字符串的全部子序列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">深度优先遍历，到了每个index判断index是否要拼接到path里，yes/no，一直到index==length时，添加进集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">subs</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    String path = <span class="string">""</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    process1(str, <span class="number">0</span>, ans, path);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str固定，不变</span></span><br><span class="line"><span class="comment">// index此时来到的位置, 要  or 不要</span></span><br><span class="line"><span class="comment">// 如果index来到了str中的终止位置，把沿途路径所形成的答案，放入ans中</span></span><br><span class="line"><span class="comment">// 之前做出的选择，就是path</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index, List&lt;String&gt; ans, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">        ans.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不添加路径</span></span><br><span class="line">    String no = path;</span><br><span class="line">    process1(str, index + <span class="number">1</span>, ans, no);</span><br><span class="line">    <span class="comment">//拼接路径</span></span><br><span class="line">    String yes = path + String.valueOf(str[index]);</span><br><span class="line">    process1(str, index + <span class="number">1</span>, ans, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印一个字符串的全部子序列，要求不要出现重复字面值的子序列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str  index  set</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">subsNoRepeat</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    String path = <span class="string">""</span>;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    process2(str, <span class="number">0</span>, set, path);</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String cur : set) &#123;</span><br><span class="line">        ans.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HashSet&lt;String&gt; set, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">        set.add(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String no = path;</span><br><span class="line">    process2(str, index + <span class="number">1</span>, set, no);</span><br><span class="line">    String yes = path + String.valueOf(str[index]);</span><br><span class="line">    process2(str, index + <span class="number">1</span>, set, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印一个字符串的全部排列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：index=0，大于等于index的元素都有机会和index的元素进行交换，做出不同的排列，index++，依次排，递归排完后还原现场，把交换的数据交换回来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">    process(chs, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..i-1]已经做好决定的</span></span><br><span class="line"><span class="comment">// str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">// i终止位置，str当前的样子，就是一种结果 -&gt; ans</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, ArrayList&lt;String&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">        ans.add(String.valueOf(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果i没有终止，i...  都可以来到i位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str.length; j++) &#123; <span class="comment">// j  i后面所有的字符都有机会</span></span><br><span class="line">        swap(str, i, j);</span><br><span class="line">        process(str, i + <span class="number">1</span>, ans);</span><br><span class="line">        <span class="comment">//还原交换现场</span></span><br><span class="line">        swap(str, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印一个字符串的全部排列，要求不要出现重复的排列</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 思想：分支限界</span></span><br><span class="line"><span class="comment"> 要交换的数值和index上的数值相同则跳过</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">permutationNoRepeat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">    process2(chs, <span class="number">0</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..i-1]已经做好决定的</span></span><br><span class="line"><span class="comment">// str[i...]都有机会来到i位置</span></span><br><span class="line"><span class="comment">// i终止位置，str当前的样子，就是一种结果 -&gt; ans</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, ArrayList&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">        res.add(String.valueOf(str));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>]; <span class="comment">// visit[0 1 .. 25]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str.length; j++) &#123;</span><br><span class="line">        <span class="comment">// str[j] = 'a'   -&gt; 0   visit[0] -&gt; 'a'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// str[j] = 'z'   -&gt; 25   visit[25] -&gt; 'z'</span></span><br><span class="line">        <span class="keyword">if</span> (!visit[str[j] - <span class="string">'a'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">            visit[str[j] - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">            swap(str, i, j);</span><br><span class="line">            process2(str, i + <span class="number">1</span>, res);</span><br><span class="line">            swap(str, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**从左往右的尝试模型1**</span></span><br><span class="line"></span><br><span class="line">规定1和A对应、2和B对应、3和C对应...</span><br><span class="line">那么一个数字字符串比如"111”就可以转化为:</span><br><span class="line">"AAA"、"KA"和"AK"</span><br><span class="line">给定一个只有数字字符组成的字符串str，返回有多少种转化结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：找到BaseCase 递归（i、i+1），下个递归是（i+1、i+2）</span></span><br><span class="line"><span class="comment">分支限界 i+1 &lt;str.length , i+1 &lt; 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0...i-1]已经转化完了，固定了</span></span><br><span class="line"><span class="comment">// i之前的位置，如何转化已经做过决定了, 不用再关心</span></span><br><span class="line"><span class="comment">// i... 有多少种转化的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == str.length) &#123; <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = process(str, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length) &#123;</span><br><span class="line">            res += process(str, i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[i] == <span class="string">'2'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = process(str, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i + <span class="number">1</span>] &gt;= <span class="string">'0'</span> &amp;&amp; str[i + <span class="number">1</span>] &lt;= <span class="string">'6'</span>)) &#123;</span><br><span class="line">            res += process(str, i + <span class="number">2</span>); <span class="comment">// (i和i+1)作为单独的部分，后续有多少种方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(str, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">暴力递归改动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dpWays2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    dp[N] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length) &#123;</span><br><span class="line">                dp[i] += dp[i + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'2'</span>) &#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i + <span class="number">1</span>] &gt;= <span class="string">'0'</span> &amp;&amp; str[i + <span class="number">1</span>] &lt;= <span class="string">'6'</span>)) &#123;</span><br><span class="line">                dp[i] += dp[i + <span class="number">2</span>]; <span class="comment">// (i和i+1)作为单独的部分，后续有多少种方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**从左往右的尝试模型2**</span></span><br><span class="line"></span><br><span class="line">给定两个长度都为N的数组weights和values，</span><br><span class="line">weights[i]和values[i]分别代表 i号物品的重量和价值。</span><br><span class="line">给定一个正数bag，表示一个载重bag的袋子，</span><br><span class="line">你装的物品不能超过这个重量。</span><br><span class="line">返回你能装下最多的价值是多少?</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：寻找baseCase，两种情况，要么背，要么不背，计算背的重量超过bag就返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(w, v, <span class="number">0</span>, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不变 ： w[]  v[]  bag</span></span><br><span class="line"><span class="comment">// index... 最大价值</span></span><br><span class="line"><span class="comment">// 0..index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW</span></span><br><span class="line"><span class="comment">// 如果返回-1，认为没有方案</span></span><br><span class="line"><span class="comment">// 如果不返回-1，认为返回的值是真实价值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> alreadyW, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (alreadyW &gt; bag) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重量没超</span></span><br><span class="line">    <span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = process(w, v, index + <span class="number">1</span>, alreadyW, bag);</span><br><span class="line">    <span class="keyword">int</span> p2next = process(w, v, index + <span class="number">1</span>, alreadyW + w[index], bag);</span><br><span class="line">    <span class="keyword">int</span> p2 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p2next != -<span class="number">1</span>) &#123;</span><br><span class="line">        p2 = v[index] + p2next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：背包没剩余空间就返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只剩下rest的空间了，</span></span><br><span class="line"><span class="comment">// index...货物自由选择，但是剩余空间不要小于0</span></span><br><span class="line"><span class="comment">// 返回 index...货物能够获得的最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123; <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rest &gt;=0</span></span><br><span class="line">    <span class="keyword">if</span> (index == w.length) &#123; <span class="comment">// base case 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有货也有空间</span></span><br><span class="line">    <span class="keyword">int</span> p1 = process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="keyword">int</span> p2 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p2Next = process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line">    <span class="keyword">if</span>(p2Next!=-<span class="number">1</span>) &#123;</span><br><span class="line">        p2 = v[index] + p2Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">暴力递归改动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dpWay</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> bag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = w.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= bag; rest++) &#123;</span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span> (rest &gt;= w[index]) &#123;</span><br><span class="line">                dp[index][rest] = Math.max(dp[index][rest], v[index] + dp[index + <span class="number">1</span>][rest - w[index]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**范围上尝试的模型**</span></span><br><span class="line"></span><br><span class="line">给定一个整型数组arr，代表数值不同的纸牌排成一条线，</span><br><span class="line">玩家A和玩家B依次拿走每张纸牌，</span><br><span class="line">规定玩家A先拿，玩家B后拿，</span><br><span class="line">但是每个玩家每次只能拿走最左或最右的纸牌，</span><br><span class="line">玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">  f函数表示先手获取的卡牌，f函数先手肯定会取一个对后手取牌最不好的结果</span></span><br><span class="line"><span class="comment">  s函数表示后手选择的卡牌，s函数后手肯定只能选择先手留给你的最差的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(</span><br><span class="line">        f(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>),</span><br><span class="line">        s(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// L....R</span></span><br><span class="line"><span class="comment">// F  S  L+1..R</span></span><br><span class="line"><span class="comment">// L..R-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[L];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(</span><br><span class="line">        arr[L] + s(arr, L + <span class="number">1</span>, R),</span><br><span class="line">        arr[R] + s(arr, L, R - <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(</span><br><span class="line">        f(arr, L + <span class="number">1</span>, R), <span class="comment">// arr[i]</span></span><br><span class="line">        f(arr, L, R - <span class="number">1</span>)  <span class="comment">// arr[j]</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">暴力递归改动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">int</span>[][] s = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++) &#123;</span><br><span class="line">        f[i][i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s[i][i] = 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R =i;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; N &amp;&amp; R &lt; N) &#123;</span><br><span class="line"></span><br><span class="line">            f[L][R] = Math.max(</span><br><span class="line">                arr[L] + s[L + <span class="number">1</span>][ R],</span><br><span class="line">                arr[R] + s[L][R - <span class="number">1</span>]</span><br><span class="line">            ); </span><br><span class="line">            s[L][R] = Math.min(</span><br><span class="line">                f[L + <span class="number">1</span>][R], <span class="comment">// arr[i]</span></span><br><span class="line">                f[L][R - <span class="number">1</span>]  <span class="comment">// arr[j]</span></span><br><span class="line">            ); </span><br><span class="line">            L++;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(f[<span class="number">0</span>][N-<span class="number">1</span>], s[<span class="number">0</span>][N-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="皇后问题"><a href="#皇后问题" class="headerlink" title="皇后问题"></a>皇后问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N皇后问题是指在N*N的棋盘上要摆N个皇后，</span><br><span class="line">要求任何两个皇后不同行、不同列， 也不在同一条斜线上</span><br><span class="line">给定一个整数n，返回n皇后的摆法有多少种。 </span><br><span class="line">n&#x3D;1，返回1</span><br><span class="line">n&#x3D;2或3，2皇后和3皇后问题无论怎么摆都不行，返回0</span><br><span class="line">n&#x3D;8，返回92</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// record[0] ?  record[1]  ?  record[2]</span></span><br><span class="line">    <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// record[i] -&gt; i行的皇后，放在了第几列</span></span><br><span class="line">    <span class="keyword">return</span> process1(<span class="number">0</span>, record, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 潜台词：record[0..i-1]的皇后，任何两个皇后一定都不共行、不共列，不共斜线</span></span><br><span class="line"><span class="comment">// 目前来到了第i行</span></span><br><span class="line"><span class="comment">// record[0..i-1]表示之前的行，放了的皇后位置</span></span><br><span class="line"><span class="comment">// n代表整体一共有多少行  0~n-1行</span></span><br><span class="line"><span class="comment">// 返回值是，摆完所有的皇后，合理的摆法有多少种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] record, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123; <span class="comment">// 终止行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有到终止位置，还有皇后要摆</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 当前行在i行，尝试i行所有的列  -&gt; j</span></span><br><span class="line">        <span class="comment">// 当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，</span></span><br><span class="line">        <span class="comment">// 如果是，认为有效</span></span><br><span class="line">        <span class="comment">// 如果不是，认为无效</span></span><br><span class="line">        <span class="keyword">if</span> (isValid(record, i, j)) &#123;</span><br><span class="line">            record[i] = j;</span><br><span class="line">            res += process1(i + <span class="number">1</span>, record, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record[0..i-1]你需要看，record[i...]不需要看</span></span><br><span class="line"><span class="comment">// 返回i行皇后，放在了j列，是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] record, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123; <span class="comment">// 之前的某个k行的皇后	</span></span><br><span class="line">        <span class="comment">// k, record[k]   i, j</span></span><br><span class="line">        <span class="comment">//不能和列、左对角线、右对角线匹配上</span></span><br><span class="line">        <span class="keyword">if</span> (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">N皇后的位运算优化，优化常数项，复杂度都相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 请不要超过32皇后问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || n &gt; <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果你是13皇后问题，limit 最右13个1，其他都是0</span></span><br><span class="line">    <span class="keyword">int</span> limit = n == <span class="number">32</span> ? -<span class="number">1</span> : (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> process2(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// limit 划定了问题的规模 -&gt; 固定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// colLim 列的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="comment">// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> limit, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> colLim, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> leftDiaLim,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> rightDiaLim)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// base case  要么有结果（相等），要么放不下皇后（pos=0不进循环，直接return）</span></span><br><span class="line">    <span class="keyword">if</span> (colLim == limit) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有可以放皇后的位置，都在pos上</span></span><br><span class="line">    <span class="comment">// colLim | leftDiaLim | rightDiaLim   -&gt; 总限制</span></span><br><span class="line">    <span class="comment">// ~ (colLim | leftDiaLim | rightDiaLim) -&gt; 取反会产生一大堆左侧的1，</span></span><br><span class="line">    <span class="comment">//limit &amp; (...) 可以把左侧的一坨0干扰，右侧每个1，可尝试</span></span><br><span class="line">    <span class="keyword">int</span> pos = limit &amp; ( ~(colLim | leftDiaLim | rightDiaLim) );</span><br><span class="line">    <span class="keyword">int</span> mostRightOne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 取取出pos中，最右侧的1来，剩下位置都是0</span></span><br><span class="line">        mostRightOne = pos &amp; (~pos + <span class="number">1</span>);</span><br><span class="line">        pos = pos - mostRightOne;</span><br><span class="line">        <span class="comment">//累加计算的结果</span></span><br><span class="line">        res += process2(limit, </span><br><span class="line">                        colLim | mostRightOne,</span><br><span class="line">                        (leftDiaLim | mostRightOne) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">                        (rightDiaLim | mostRightOne) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种皇后优化时间的对比</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(num2(n));</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"cost time: "</span> + (end - start) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(num1(n));</span><br><span class="line">    end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"cost time: "</span> + (end - start) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**什么暴力递归可以继续优化？**</span></span><br><span class="line"></span><br><span class="line">有重复调用同一个子问题的解，这种递归可以优化</span><br><span class="line"></span><br><span class="line">如果每一个子问题都是不同的解，无法优化也不用优化</span><br><span class="line"></span><br><span class="line"><span class="strong">**任何暴力尝试，只要有重复计算的过程，把可变参数的结构变成固化的过程，做成缓存，再精细之后，就是动态规划**</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**暴力递归和动态规划的关系**</span></span><br><span class="line"></span><br><span class="line">某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</span><br><span class="line"></span><br><span class="line">任何动态规划问题，都一定对应着某一个有解的重复调用的暴力递归</span><br><span class="line"></span><br><span class="line">但不是所有的暴力递归，都一定对应着动态规划</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**如何找到某个问题的动态规划方式？**</span></span><br><span class="line"></span><br><span class="line">1）设计暴力递归：重要原则+4种常见尝试模型！重点！</span><br><span class="line"></span><br><span class="line">2）分析有没有重复解：套路解决</span><br><span class="line"></span><br><span class="line">3）用记忆化搜索 -&gt; 用严格表结构实现动态规划：套路解决</span><br><span class="line"></span><br><span class="line">4）看看能否继续优化：套路解决</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**常见的4种尝试模型**</span></span><br><span class="line"></span><br><span class="line">1）从左往右的尝试模型</span><br><span class="line"></span><br><span class="line">2）范围上的尝试模型</span><br><span class="line"></span><br><span class="line">3）多样本位置全对应的尝试模型</span><br><span class="line"></span><br><span class="line">4）寻找业务限制的尝试模型</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**暴力递归到动态规划的套路**</span></span><br><span class="line"></span><br><span class="line">1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用</span><br><span class="line">2）找到哪些参数的变化会影响返回值，对每一个列出变化范围</span><br><span class="line">3）参数间的所有的组合数量，意味着表大小</span><br><span class="line">4）记忆化搜索的方法就是傻缓存，非常容易得到</span><br><span class="line">5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解</span><br><span class="line">6）对于有枚举行为的决策过程，进一步优化</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设有排成一行的N个位置，记为1~N，N 一定大于或等于 2</span><br><span class="line">开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)</span><br><span class="line">如果机器人来到1位置，那么下一步只能往右来到2位置；</span><br><span class="line">如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；</span><br><span class="line">如果机器人来到中间位置，那么下一步可以往左走或者往右走；</span><br><span class="line">规定机器人必须走 K 步，最终能来到P位置(P也是1~N中的一个)的方法有多少种</span><br><span class="line">给定四个参数 N、M、K、P，返回方法数。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想：</span></span><br><span class="line"><span class="comment">  最小化问题 每次走一步，有哪些选择，制定baseCase</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数无效直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || K &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, M, K, P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// N : 位置为1 ~ N，固定参数</span></span><br><span class="line"><span class="comment">// cur : 当前在cur位置，可变参数</span></span><br><span class="line"><span class="comment">// rest : 还剩res步没有走，可变参数</span></span><br><span class="line"><span class="comment">// P : 最终目标位置是P，固定参数</span></span><br><span class="line"><span class="comment">// 该函数的含义：只能在1~N这些位置上移动，当前在cur位置，走完rest步之后，停在P位置的方法数作为返回值返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">walk</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有剩余步数了，当前的cur位置就是最后的位置</span></span><br><span class="line">    <span class="comment">// 如果最后的位置停在P上，那么之前做的移动是有效的</span></span><br><span class="line">    <span class="comment">// 如果最后的位置没在P上，那么之前做的移动是无效的</span></span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur == P ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有rest步要走，而当前的cur位置在1位置上，那么当前这步只能从1走向2</span></span><br><span class="line">    <span class="comment">// 后续的过程就是，来到2位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> walk(N, <span class="number">2</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有rest步要走，而当前的cur位置在N位置上，那么当前这步只能从N走向N-1</span></span><br><span class="line">    <span class="comment">// 后续的过程就是，来到N-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        <span class="keyword">return</span> walk(N, N - <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果还有rest步要走，而当前的cur位置在中间位置上，那么当前这步可以走向左，也可以走向右</span></span><br><span class="line">    <span class="comment">// 走向左之后，后续的过程就是，来到cur-1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">// 走向右之后，后续的过程就是，来到cur+1位置上，还剩rest-1步要走</span></span><br><span class="line">    <span class="comment">// 走向左、走向右是截然不同的方法，所以总方法数要都算上</span></span><br><span class="line">    <span class="keyword">return</span> walk(N, cur + <span class="number">1</span>, rest - <span class="number">1</span>, P) + walk(N, cur - <span class="number">1</span>, rest - <span class="number">1</span>, P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">记忆搜索下的动态规划：（暴力递归重复计算做缓存）</span></span><br><span class="line"><span class="comment">任何暴力尝试，只要有重复计算的过程，把可变参数的结构变成固化的过程，做成缓存，再精细之后，就是动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">waysCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> K, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数无效直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || K &lt; <span class="number">1</span> || M &lt; <span class="number">1</span> || M &gt; N || P &lt; <span class="number">1</span> || P &gt; N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][K+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt;= N; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt;= K; col++) &#123;</span><br><span class="line">            dp[row][col] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> walkCache(N, M, K, P,dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap&lt;String, Integer&gt;   (19,100)  "19_100"</span></span><br><span class="line"><span class="comment">// 我想把所有cur和rest的组合，返回的结果，加入到缓存里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">walkCache</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> cur, <span class="keyword">int</span> rest, <span class="keyword">int</span> P, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[cur][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[cur][rest] = cur == P ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[cur][rest] = walkCache(N, <span class="number">2</span>, rest - <span class="number">1</span>, P, dp);</span><br><span class="line">        <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        dp[cur][rest] =walkCache(N, N - <span class="number">1</span>, rest - <span class="number">1</span>, P,dp);</span><br><span class="line">        <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[cur][rest] = walkCache(N, cur + <span class="number">1</span>, rest - <span class="number">1</span>, P,dp) </span><br><span class="line">        + walkCache(N, cur - <span class="number">1</span>, rest - <span class="number">1</span>, P, dp);</span><br><span class="line">    <span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定数组arr，arr中所有的值都为正数且不重复</span><br><span class="line">每个值代表一种面值的货币，每种面值的货币可以使用任意张</span><br><span class="line">再给定一个整数 aim，代表要找的钱数</span><br><span class="line">求组成 aim 的方法数</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力递归</span></span><br><span class="line"><span class="comment">// arr中都是正数且无重复值，返回组成aim的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process1(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span> ;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> zhang = <span class="number">0</span>;  zhang * arr[index] &lt;= rest ;zhang++) &#123;</span><br><span class="line">        ways += process1(arr, index + <span class="number">1</span>, rest -  (zhang * arr[index])  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">暴力递归改记忆搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>][aim+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 一开始所有的过程，都没有计算呢</span></span><br><span class="line">    <span class="comment">// dp[..][..]  = -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process2(arr, <span class="number">0</span>, aim , dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果index和rest的参数组合，是没算过的，dp[index][rest] == -1</span></span><br><span class="line"><span class="comment">// 如果index和rest的参数组合，是算过的，dp[index][rest]  &gt; - 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process2</span><span class="params">(<span class="keyword">int</span>[] arr, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> rest,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[index][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[index][rest];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index == arr.length) &#123;</span><br><span class="line">        dp[index][rest] = rest == <span class="number">0</span> ? <span class="number">1</span> :<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>  dp[index][rest];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> zhang = <span class="number">0</span>;  zhang * arr[index] &lt;= rest ;zhang++) &#123;</span><br><span class="line">        ways += process2(arr, index + <span class="number">1</span>, rest -  (zhang * arr[index]) , dp );</span><br><span class="line">    &#125;</span><br><span class="line">    dp[index][rest] = ways;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标准动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways3</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// dp[N][1...aim] = 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> zhang = <span class="number">0</span>;  zhang * arr[index] &lt;= rest ;zhang++) &#123;</span><br><span class="line">                ways += dp[index + <span class="number">1</span>] [rest -  (zhang * arr[index])];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index][rest] = ways;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">优化的动态规划,省略动态规划的枚举行为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ways4</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// dp[N][1...aim] = 0;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">            dp[index][rest] = dp[index+<span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span>(rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">10</span>,<span class="number">50</span>,<span class="number">100</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1000</span>;</span><br><span class="line">    System.out.println(ways1(arr, sum));</span><br><span class="line">    System.out.println(ways2(arr, sum));</span><br><span class="line">    System.out.println(ways3(arr, sum));</span><br><span class="line">    System.out.println(ways4(arr, sum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串str，给定一个字符串类型的数组arr。</span><br><span class="line">arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。</span><br><span class="line">返回需要至少多少张贴纸可以完成这个任务。</span><br><span class="line">例子：str&#x3D; &quot;babac&quot;，arr &#x3D; &#123;&quot;ba&quot;,&quot;c&quot;,&quot;abcd&quot;&#125;</span><br><span class="line">至少需要两张贴纸&quot;ba&quot;和&quot;abcd&quot;，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">把贴纸都转换成二维数组存储26个字母的数量，通过数量相减计算字符串rest的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minStickers1</span><span class="params">(String[] stickers, String target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = stickers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">26</span>];<span class="comment">// stickers -&gt; [26] [26] [26]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            map[i][c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dp.put(<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> process1(dp, map, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 傻缓存，如果t已经算过了，直接返回dp中的值</span></span><br><span class="line"><span class="comment">// t 剩余的目标</span></span><br><span class="line"><span class="comment">// 0..N每一个字符串所含字符的词频统计</span></span><br><span class="line"><span class="comment">// 返回值是-1，map 中的贴纸  怎么都无法rest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HashMap&lt;String, Integer&gt; dp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>[][] map, </span></span></span><br><span class="line"><span class="function"><span class="params">    String rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.containsKey(rest)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp.get(rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下就是正式的递归调用过程</span></span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE; <span class="comment">// ans -&gt; 搞定rest，使用的最少的贴纸数量 </span></span><br><span class="line">    <span class="keyword">int</span> n = map.length; <span class="comment">// N种贴纸</span></span><br><span class="line">    <span class="keyword">int</span>[] tmap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// tmap 去替代 rest</span></span><br><span class="line">    <span class="keyword">char</span>[] target = rest.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : target) &#123;</span><br><span class="line">        tmap[c - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举当前第一张贴纸是谁？</span></span><br><span class="line">        <span class="keyword">if</span> (map[i][target[<span class="number">0</span>] - <span class="string">'a'</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// i 贴纸， j 枚举a~z字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (tmap[j] &gt; <span class="number">0</span>) &#123; <span class="comment">// j这个字符是target需要的</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Math.max(<span class="number">0</span>, tmap[j] - map[i][j]); k++) &#123;</span><br><span class="line">                    sb.append((<span class="keyword">char</span>) (<span class="string">'a'</span> + j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sb -&gt;  i</span></span><br><span class="line">        String s = sb.toString();</span><br><span class="line">        <span class="keyword">int</span> tmp = process1(dp, map, s);</span><br><span class="line">        <span class="keyword">if</span> (tmp != -<span class="number">1</span>) &#123;</span><br><span class="line">            ans = Math.min(ans, <span class="number">1</span> + tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ans 系统最大  rest</span></span><br><span class="line">    dp.put(rest, ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">    <span class="keyword">return</span> dp.get(rest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**多样本位置全对应的尝试模型**</span></span><br><span class="line"></span><br><span class="line">两个字符串的最长公共子序列问题</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路</span></span><br><span class="line"><span class="comment">把样本数据当做二维数组，求最右下角的值，就是问题的答案</span></span><br><span class="line"><span class="comment">db[i][j]赋值的四种思考方式：</span></span><br><span class="line"><span class="comment">  1.db[i][j] = db[i-1][j-1] : 最长子序列和两个字符串的最后字符无关</span></span><br><span class="line"><span class="comment">  2.db[i][j] = db[i-1][j] ：最长子序列和str1最后字符串无关</span></span><br><span class="line"><span class="comment">  3.db[i][j] = db[i][j-1] ：最长子序列和str2最后字符串无关</span></span><br><span class="line"><span class="comment">  4.db[i][j] = db[i-1][j-1] + 1 :  str1和str2最后字符相同（满足str1[i] = str2[j]）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcse</span><span class="params">(<span class="keyword">char</span>[] str1, <span class="keyword">char</span>[] str2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[str1.length][str2.length];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j - <span class="number">1</span>], str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str2.length; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[str1.length - <span class="number">1</span>][str2.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**寻找业务限制的尝试模型**</span></span><br><span class="line"></span><br><span class="line">给定一个数组，代表每个人喝完咖啡准备刷杯子的时间</span><br><span class="line">只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯</span><br><span class="line">每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发</span><br><span class="line">返回让所有咖啡杯变干净的最早完成时间</span><br><span class="line">三个参数：int[] arr、int a、int b</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process(drinks, 3, 10, 0,0)</span></span><br><span class="line"><span class="comment">// a 洗一杯的时间 固定变量</span></span><br><span class="line"><span class="comment">// b 自己挥发干净的时间 固定变量</span></span><br><span class="line"><span class="comment">// drinks 每一个员工喝完的时间 固定变量</span></span><br><span class="line"><span class="comment">// drinks[0..index-1]都已经干净了，不用你操心了</span></span><br><span class="line"><span class="comment">// drinks[index...]都想变干净，这是我操心的，washLine表示洗的机器何时可用</span></span><br><span class="line"><span class="comment">// drinks[index...]变干净，最少的时间点返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> index, <span class="keyword">int</span> washLine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == drinks.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.max(washLine, drinks[index]) + a, drinks[index] + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩不止一杯咖啡</span></span><br><span class="line">    <span class="comment">// wash是我当前的咖啡杯，洗完的时间</span></span><br><span class="line">    <span class="keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;<span class="comment">// 洗，index一杯，结束的时间点</span></span><br><span class="line">    <span class="comment">// index+1...变干净的最早时间</span></span><br><span class="line">    <span class="keyword">int</span> next1 = process(drinks, a, b, index + <span class="number">1</span>, wash);</span><br><span class="line">    <span class="comment">// index....</span></span><br><span class="line">    <span class="keyword">int</span> p1 = Math.max(wash, next1);</span><br><span class="line">    <span class="keyword">int</span> dry = drinks[index] + b; <span class="comment">// 挥发，index一杯，结束的时间点</span></span><br><span class="line">    <span class="keyword">int</span> next2 = process(drinks, a, b, index + <span class="number">1</span>, washLine);</span><br><span class="line">    <span class="keyword">int</span> p2 = Math.max(dry, next2);</span><br><span class="line">    <span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">暴力递归改动态规划</span></span><br><span class="line"><span class="comment">根据每一杯咖啡的washLine的最大值来定二维数组</span></span><br><span class="line"><span class="comment">washLine的最大值是所有咖啡都放咖啡机洗的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">        <span class="keyword">return</span> drinks[drinks.length - <span class="number">1</span>] + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a &lt; b</span></span><br><span class="line">    <span class="keyword">int</span> N = drinks.length;</span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">0</span>; <span class="comment">// 咖啡机什么时候可用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        limit = Math.max(limit, drinks[i]) + a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N][limit + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// N-1行，所有的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> washLine = <span class="number">0</span>; washLine &lt;= limit; washLine++) &#123;</span><br><span class="line">        dp[N - <span class="number">1</span>][washLine] = Math.min(Math.max(washLine, drinks[N - <span class="number">1</span>]) + a, drinks[N - <span class="number">1</span>] + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">2</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> washLine = <span class="number">0</span>; washLine &lt;= limit; washLine++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p1 = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;</span><br><span class="line">            <span class="keyword">if</span> (wash &lt;= limit) &#123;</span><br><span class="line">                p1 = Math.max(wash, dp[index + <span class="number">1</span>][wash]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> p2 = Math.max(drinks[index] + b, dp[index + <span class="number">1</span>][washLine]);</span><br><span class="line">            dp[index][washLine] = Math.min(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年12月04日 22:53</p>
        <p>原始链接： <a class="post-url" href="/2020/10/29/algorithm-base/" title="&#39;数据结构与算法&#39;">https://midkuro.gitee.io/2020/10/29/algorithm-base/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/10/29/algorithm-base/&title=《'数据结构与算法'》 — Kuro's Blog&pic=images/algorithm.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/10/29/algorithm-base/&title=《'数据结构与算法'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/10/29/algorithm-base/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'数据结构与算法'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/10/29/algorithm-base/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/10/29/algorithm-base/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/10/29/algorithm-base/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/Algorithm/" class="color5">Algorithm</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#基础算法"><span class="post-toc-text">基础算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#时间复杂度"><span class="post-toc-text">时间复杂度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择排序"><span class="post-toc-text">选择排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#冒泡排序"><span class="post-toc-text">冒泡排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#插入排序"><span class="post-toc-text">插入排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#额外空间复杂度"><span class="post-toc-text">额外空间复杂度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#算法流程的常数项"><span class="post-toc-text">算法流程的常数项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二分法"><span class="post-toc-text">二分法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#异或运算"><span class="post-toc-text">异或运算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#栈和队列"><span class="post-toc-text">栈和队列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#递归"><span class="post-toc-text">递归</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#哈希表"><span class="post-toc-text">哈希表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#归并排序"><span class="post-toc-text">归并排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#快速排序"><span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆结构"><span class="post-toc-text">堆结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前缀树"><span class="post-toc-text">前缀树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#桶排序"><span class="post-toc-text">桶排序</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#链表"><span class="post-toc-text">链表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树"><span class="post-toc-text">二叉树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二叉树的递归套路"><span class="post-toc-text">二叉树的递归套路</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#贪心算法"><span class="post-toc-text">贪心算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并查集"><span class="post-toc-text">并查集</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图"><span class="post-toc-text">图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#暴力递归"><span class="post-toc-text">暴力递归</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#汉诺塔问题"><span class="post-toc-text">汉诺塔问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#背包问题"><span class="post-toc-text">背包问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#皇后问题"><span class="post-toc-text">皇后问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#动态规划"><span class="post-toc-text">动态规划</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/11/09/mybatis-config/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;Mybatis的介绍和基本使用&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/10/29/juc-base/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;多线程与高并发&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="algorithm-base" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Algorithm/">Algorithm</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/MYSQL/">MYSQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/Nginx/Redis/">Redis</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 17px;">ActiveMQ</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 12px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 16px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 17px;">ActiveMQ</a> <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/Cryptography/" style="font-size: 12px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 13px;">Docker</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 11px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 11px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 14px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 12px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 12px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 13px;">NIO</a> <a href="/tags/Netty/" style="font-size: 11px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 16px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 12px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 14px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 13px;">Thread</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>