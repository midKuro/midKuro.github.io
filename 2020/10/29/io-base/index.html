<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>&#39;内存与IO，磁盘IO，网络IO&#39; | Kuro&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Kuro,Kuro's Blog" />
  
  
    <meta name="baidu_site_verification" content="code-JRipY21QjX" />
  


  <meta name="description" content="内存与IO，磁盘IO，网络IO文件描述符12常用软件：yum install -y strace lsof  pmap tcpdump  1234567VFS:  虚拟文件系统 案例[root@node01 ~]# dfFilesystem     1K-blocks     Used Available Use% Mounted on&#x2F;dev&#x2F;sda3      202092480 107765">
<meta property="og:type" content="article">
<meta property="og:title" content="&#39;内存与IO，磁盘IO，网络IO&#39;">
<meta property="og:url" content="https://midkuro.gitee.io/2020/10/29/io-base/index.html">
<meta property="og:site_name" content="Kuro&#39;s Blog">
<meta property="og:description" content="内存与IO，磁盘IO，网络IO文件描述符12常用软件：yum install -y strace lsof  pmap tcpdump  1234567VFS:  虚拟文件系统 案例[root@node01 ~]# dfFilesystem     1K-blocks     Used Available Use% Mounted on&#x2F;dev&#x2F;sda3      202092480 107765">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-01.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-02.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-03.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-04.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-05.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-06.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-07.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-08.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-09.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-10.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-11.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-12.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-13.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-14.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-17.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-18.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-16.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-15.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-19.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-20.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-21.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-22.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-23.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-24.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-25.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-27.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-26.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-28.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-29.png">
<meta property="og:image" content="https://midkuro.gitee.io/images/io-base/io-30.png">
<meta property="article:published_time" content="2020-10-29T14:31:00.000Z">
<meta property="article:modified_time" content="2020-11-25T16:07:36.551Z">
<meta property="article:author" content="Kuro">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="NIO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://midkuro.gitee.io/images/io-base/io-01.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?code-JRipY21QjX";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  


  
  <!-- <meta name="baidu-site-verification" content="code-JRipY21QjX" /> -->
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Kuro&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.gif" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Kuro&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        坚持 是一种品格
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Kuro"  href="//midkuro.gitee.io">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/midKuro/midkuro.github.io">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-io-base" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      &#39;内存与IO，磁盘IO，网络IO&#39;
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/NIO/">NIO</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2020-10-29
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="内存与IO，磁盘IO，网络IO"><a href="#内存与IO，磁盘IO，网络IO" class="headerlink" title="内存与IO，磁盘IO，网络IO"></a>内存与IO，磁盘IO，网络IO</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常用软件：</span><br><span class="line">yum install -y strace lsof  pmap tcpdump</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VFS:  虚拟文件系统 案例</span><br><span class="line"></span><br><span class="line">[root@node01 ~]# df</span><br><span class="line">Filesystem     1K-blocks     Used Available Use% Mounted on</span><br><span class="line">/dev/sda3      202092480 10776508 181050220   6% /</span><br><span class="line">tmpfs            1954400        0   1954400   0% /dev/shm</span><br><span class="line">/dev/sda1         198337    27795    160302  15% /boot</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda3      202092480 7187520 184639208   4% &#x2F;</span><br><span class="line">tmpfs            1954400       0   1954400   0% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;dev&#x2F;sda1         198337   27795    160302  15% &#x2F;boot</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试pipeline类型：</span><br><span class="line">&#123; echo $BASHPID ;  read x;  &#125;  |  &#123; cat ; echo $BASHPID ;  read y; &#125; </span><br><span class="line">测试socket类型：</span><br><span class="line">exec  8&lt;&gt;  &#x2F;dev&#x2F;tcp&#x2F;www.baidu.com&#x2F;80</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lsof -op $$</span><br><span class="line">【以下是整合的结果】</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE OFFSET     NODE NAME</span><br><span class="line">bash    4398 root  cwd    DIR    8,3        10227872 &#x2F;root&#x2F;mashibing</span><br><span class="line">bash    4398 root  rtd    DIR    8,3               2 &#x2F;</span><br><span class="line">bash    4398 root  txt    REG    8,3         7077890 &#x2F;bin&#x2F;bash</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572903 &#x2F;lib64&#x2F;libresolv-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572891 &#x2F;lib64&#x2F;libnss_dns-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1709499 &#x2F;usr&#x2F;lib&#x2F;locale&#x2F;locale-archive</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572893 &#x2F;lib64&#x2F;libnss_files-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572877 &#x2F;lib64&#x2F;libc-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572883 &#x2F;lib64&#x2F;libdl-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572920 &#x2F;lib64&#x2F;libtinfo.so.5.7</span><br><span class="line">bash    4398 root  mem    REG    8,3         1572867 &#x2F;lib64&#x2F;ld-2.12.so</span><br><span class="line">bash    4398 root  mem    REG    8,3         1968395 &#x2F;usr&#x2F;lib64&#x2F;gconv&#x2F;gconv-modules.cache</span><br><span class="line">bash    4398 root    &quot;0u   CHR  136,2    0t0        5 &#x2F;dev&#x2F;pts&#x2F;2&quot;</span><br><span class="line">bash    4398 root    1u   CHR  136,2    0t0        5 &#x2F;dev&#x2F;pts&#x2F;2</span><br><span class="line">bash    4513 root    &quot;0r  FIFO    0,8    0t0    39968 pipe&quot;</span><br><span class="line">bash    4398 root    2u   CHR  136,2    0t0        5 &#x2F;dev&#x2F;pts&#x2F;2</span><br><span class="line">bash    4398 root    &quot;6r   REG    8,3    0t0 10227564 &#x2F;root&#x2F;ooxx.txt&quot;</span><br><span class="line">bash    4398 root    &quot;8u  IPv4  39172    0t0      TCP node01:54723-&gt;104.193.88.123:http (CLOSE_WAIT)&quot;&quot;</span><br><span class="line">bash    4398 root  255u   CHR  136,2    0t0        5 &#x2F;dev&#x2F;pts&#x2F;2</span><br><span class="line"></span><br><span class="line">read a &lt;&amp; 6</span><br><span class="line">通过读取6号文件描述符，查看0t4的offset变化</span><br><span class="line"></span><br><span class="line">一切皆文件：这里主要展示 socket&#x2F;pipeline</span><br><span class="line">另外，fd，文件描述符代表打开的文件，有inode号和seek偏移指针的概念</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">管道：</span><br><span class="line">1，衔接，前一个命令的输出作为后一个命令的输入</span><br><span class="line">2，管道会触发创建【子进程】</span><br><span class="line"></span><br><span class="line">echo $$  |   more  --&gt;当前bash的进程号</span><br><span class="line">echo $BASHPID |  more  --&gt;当前bash的子进程的进程号</span><br><span class="line">原因：$$ 高于 |  </span><br><span class="line"></span><br><span class="line">使用linux的时候：</span><br><span class="line">父子进程</span><br><span class="line"></span><br><span class="line">父进程的数据，子进程可不可以看得到？ 不能</span><br><span class="line"></span><br><span class="line">常规思想，进程是数据隔离的！</span><br><span class="line"></span><br><span class="line">进阶思想，父进程其实可以让子进程看到数据！ &#96;export&#96;</span><br><span class="line"></span><br><span class="line">linux中</span><br><span class="line">export的环境变量，子进程的修改不会破坏父进程</span><br><span class="line">父进程的修改也不会破坏子进程</span><br><span class="line"></span><br><span class="line">Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vi</span> <span class="string">/etc/sysctl.conf</span></span><br><span class="line"><span class="comment">#脏页的策略</span></span><br><span class="line"><span class="meta">vm.dirty_background_ratio</span> = <span class="string">0</span></span><br><span class="line"><span class="meta">vm.dirty_background_bytes</span> = <span class="string">1048576</span></span><br><span class="line"><span class="meta">vm.dirty_ratio</span> = <span class="string">0</span></span><br><span class="line"><span class="meta">vm.dirty_bytes</span> = <span class="string">1048576</span></span><br><span class="line"><span class="meta">vm.dirty_writeback_centisecs</span> = <span class="string">5000</span></span><br><span class="line"><span class="meta">vm.dirty_expire_centisecs</span> = <span class="string">30000</span></span><br></pre></td></tr></table></figure>

<h2 id="虚拟内存和内存映射"><a href="#虚拟内存和内存映射" class="headerlink" title="虚拟内存和内存映射"></a>虚拟内存和内存映射</h2><p><img src="/images/io-base/io-01.png" alt="system"></p>
<p><img src="/images/io-base/io-02.png" alt="system"></p>
<h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最基本的file写，每次都要调用内核态写数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testBasicFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试buffer文件IO，达到一个缓冲区大小时调用内核态</span></span><br><span class="line"><span class="comment">//  jvm  8kB   syscall  write(8KBbyte[])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBufferedFileIO</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        out.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mmap通过映射进程和内核态的共享区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRandomAccessFileWrite</span><span class="params">()</span> <span class="keyword">throws</span>  Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(path, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">    raf.write(<span class="string">"hello mashibing\n"</span>.getBytes());</span><br><span class="line">    raf.write(<span class="string">"hello seanzhou\n"</span>.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"write------------"</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    raf.seek(<span class="number">4</span>);</span><br><span class="line">    raf.write(<span class="string">"ooxx"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"seek---------"</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    FileChannel rafchannel = raf.getChannel();</span><br><span class="line">    <span class="comment">//mmap  堆外  和文件映射的   byte  not  objtect</span></span><br><span class="line">    MappedByteBuffer map = rafchannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">"@@@"</span>.getBytes());  <span class="comment">//不是系统调用  但是数据会到达 内核的pagecache</span></span><br><span class="line">    <span class="comment">//曾经我们是需要out.write()  这样的系统调用，才能让程序的data 进入内核的pagecache</span></span><br><span class="line">    <span class="comment">//曾经必须有用户态内核态切换</span></span><br><span class="line">    <span class="comment">//mmap的内存映射，依然是内核的pagecache体系所约束的！！！</span></span><br><span class="line">    <span class="comment">//换言之，丢数据</span></span><br><span class="line">    <span class="comment">//你可以去github上找一些 其他C程序员写的jni扩展库，使用linux内核的Direct IO</span></span><br><span class="line">    <span class="comment">//直接IO是忽略linux的pagecache</span></span><br><span class="line">    <span class="comment">//是把pagecache  交给了程序自己开辟一个字节数组当作pagecache，动用代码逻辑来维护一致性/dirty。。。一系列复杂问题</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"map--put--------"</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map.force(); //  flush</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    raf.seek(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">    <span class="comment">//ByteBuffer buffer = ByteBuffer.allocateDirect(1024);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> read = rafchannel.read(buffer);   <span class="comment">//buffer.put()</span></span><br><span class="line">    System.out.println(buffer);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.print(((<span class="keyword">char</span>)buffer.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">whatByteBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        ByteBuffer buffer = ByteBuffer.allocate(1024);</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"postition: "</span> + buffer.position());</span><br><span class="line">    System.out.println(<span class="string">"limit: "</span> +  buffer.limit());</span><br><span class="line">    System.out.println(<span class="string">"capacity: "</span> + buffer.capacity());</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">    buffer.put(<span class="string">"123"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------put:123......"</span>);</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">    buffer.flip();   <span class="comment">//读写交替</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------flip......"</span>);</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">    buffer.get();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------get......"</span>);</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">    buffer.compact();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------compact......"</span>);</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">    buffer.clear();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"-------------clear......"</span>);</span><br><span class="line">    System.out.println(<span class="string">"mark: "</span> + buffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-03.png" alt="system"></p>
<h2 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIOPropertites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//server socket listen property:</span></span><br><span class="line">    <span class="comment">//缓冲区大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVE_BUFFER = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//监听阻塞的超时时限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> REUSE_ADDR = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//内核中等待队列的大小（无关联进程的四元组数量）（等同于丢包）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACK_LOG = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//client socket listen property on server endpoint:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_KEEPALIVE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_OOB = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_REC_BUF = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_REUSE_ADDR = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_SEND_BUF = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_LINGER = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_LINGER_N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLI_TIMEOUT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> CLI_NO_DELAY = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    StandardSocketOptions.TCP_NODELAY</span></span><br><span class="line"><span class="comment">    StandardSocketOptions.SO_KEEPALIVE</span></span><br><span class="line"><span class="comment">    StandardSocketOptions.SO_LINGER</span></span><br><span class="line"><span class="comment">    StandardSocketOptions.SO_RCVBUF</span></span><br><span class="line"><span class="comment">    StandardSocketOptions.SO_SNDBUF</span></span><br><span class="line"><span class="comment">    StandardSocketOptions.SO_REUSEADDR</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>), BACK_LOG);</span><br><span class="line">            server.setReceiveBufferSize(RECEIVE_BUFFER);</span><br><span class="line">            server.setReuseAddress(REUSE_ADDR);</span><br><span class="line">            server.setSoTimeout(SO_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"server up use 9090!"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// System.in.read();  //分水岭：</span></span><br><span class="line"></span><br><span class="line">                Socket client = server.accept();  <span class="comment">//阻塞的，没有 -1  一直卡着不动  accept(4,</span></span><br><span class="line">                System.out.println(<span class="string">"client port: "</span> + client.getPort());</span><br><span class="line"></span><br><span class="line">                client.setKeepAlive(CLI_KEEPALIVE);</span><br><span class="line">                client.setOOBInline(CLI_OOB);</span><br><span class="line">                client.setReceiveBufferSize(CLI_REC_BUF);</span><br><span class="line">                client.setReuseAddress(CLI_REUSE_ADDR);</span><br><span class="line">                client.setSendBufferSize(CLI_SEND_BUF);</span><br><span class="line">                client.setSoLinger(CLI_LINGER, CLI_LINGER_N);</span><br><span class="line">                client.setSoTimeout(CLI_TIMEOUT);</span><br><span class="line">                client.setTcpNoDelay(CLI_NO_DELAY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//client.read   //阻塞   没有  -1 0</span></span><br><span class="line">                <span class="keyword">new</span> Thread(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            InputStream in = client.getInputStream();</span><br><span class="line">                            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                            <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">                            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">int</span> num = reader.read(data);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">"client read some data is :"</span> + num + <span class="string">" val :"</span> + <span class="keyword">new</span> String(data, <span class="number">0</span>, num));</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">"client readed nothing!"</span>);</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">"client readed -1..."</span>);</span><br><span class="line">                                    System.in.read();</span><br><span class="line">                                    client.close();</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                ).start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(<span class="string">"192.168.150.11"</span>,<span class="number">9090</span>);</span><br><span class="line">            client.setSendBufferSize(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">//TCP缓存优化发包，优化不需要每次小字节都发送过去，攒一批再发</span></span><br><span class="line">            client.setTcpNoDelay(<span class="keyword">false</span>);</span><br><span class="line">            OutputStream out = client.getOutputStream();</span><br><span class="line"></span><br><span class="line">            InputStream in = System.in;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(line != <span class="keyword">null</span> )&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bb = line.getBytes();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">byte</span> b : bb) &#123;</span><br><span class="line">                        out.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-04.png" alt="system"></p>
<p><img src="/images/io-base/io-05.png" alt="system"></p>
<blockquote>
<p>TCP的拥塞：</p>
<p>若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>，这种情况就叫做<strong>网络拥塞</strong>。</p>
<p>建立TCP连接时会发送客户端能接受的数据包大小（滑动窗口），每次接收到数据包时会返回服务端可接收的数据包大小（滑动窗口大小），如果客户端发送的数据包超过了服务端的能接收的大小，客户端需要阻塞等待服务端的处理。</p>
<p>MTU：数据包大小</p>
<p>MSS：数据大小</p>
</blockquote>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketBIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8090</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"step1: new ServerSocket(8090) "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket client = server.accept();  <span class="comment">//阻塞1</span></span><br><span class="line">            System.out.println(<span class="string">"step2:client\t"</span> + client.getPort());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in = client.getInputStream();</span><br><span class="line">                        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                            String dataline = reader.readLine(); <span class="comment">//阻塞2</span></span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">null</span> != dataline)&#123;</span><br><span class="line">                                System.out.println(dataline);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                client.close();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"客户端断开"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-06.png" alt="system"></p>
<p><img src="/images/io-base/io-07.png" alt="system"></p>
<p><img src="/images/io-base/io-08.png" alt="system"></p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  what   why  how</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;SocketChannel&gt; clients = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ss = ServerSocketChannel.open();  <span class="comment">//服务端开启监听：接受客户端</span></span><br><span class="line">        ss.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">        ss.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  OS  NONBLOCKING!!!  //只让接受客户端  不阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        ss.setOption(StandardSocketOptions.TCP_NODELAY, false);</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.TCP_NODELAY</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.SO_KEEPALIVE</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.SO_LINGER</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.SO_RCVBUF</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.SO_SNDBUF</span></span><br><span class="line"><span class="comment">//        StandardSocketOptions.SO_REUSEADDR</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//接受客户端的连接</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            SocketChannel client = ss.accept(); <span class="comment">//不会阻塞？  -1 NULL</span></span><br><span class="line">            <span class="comment">//accept  调用内核了：1，没有客户端连接进来，返回值？在BIO 的时候一直卡着，但是在NIO ，不卡着，返回-1，NULL</span></span><br><span class="line">            <span class="comment">//如果来客户端的连接，accept 返回的是这个客户端的fd  5，client  object</span></span><br><span class="line">            <span class="comment">//NONBLOCKING 就是代码能往下走了，只不过有不同的情况</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//   System.out.println("null.....");</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.configureBlocking(<span class="keyword">false</span>); <span class="comment">//重点  socket（服务端的listen socket&lt;连接请求三次握手后，往我这里扔，我去通过accept 得到  连接的socket&gt;，连接socket&lt;连接后的数据读写使用的&gt; ）</span></span><br><span class="line">                <span class="keyword">int</span> port = client.socket().getPort();</span><br><span class="line">                System.out.println(<span class="string">"client..port: "</span> + port);</span><br><span class="line">                clients.add(client);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">4096</span>);  <span class="comment">//可以在堆里   堆外</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历已经链接进来的客户端能不能读写数据</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel c : clients) &#123;   <span class="comment">//串行化！！！！  多线程！！</span></span><br><span class="line">                <span class="keyword">int</span> num = c.read(buffer);  <span class="comment">// &gt;0  -1  0   //不会阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">byte</span>[] aaa = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">                    buffer.get(aaa);</span><br><span class="line"></span><br><span class="line">                    String b = <span class="keyword">new</span> String(aaa);</span><br><span class="line">                    System.out.println(c.socket().getPort() + <span class="string">" : "</span> + b);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-09.png" alt="system"></p>
<h3 id="Linux内核函数"><a href="#Linux内核函数" class="headerlink" title="Linux内核函数"></a>Linux内核函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定四元组地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, socklen_t addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听来自客户端的tcp socket的连接请求,backlog是等待队列数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和新的客户端建立连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, socklen_t *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取客户端发送的数据</span></span><br><span class="line"><span class="function">ssize_t <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, size_t len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送需要轮训的【fd列表、事件】、要监视的描述符的数目、超时配置（-1=阻塞）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, nfds_t nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置fd的相关内容、如读写、非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟一个大小为size的红黑树空间，返回epfd（类似于红黑树的根节点）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加fd到红黑树 op操作如add/del, fd是需要添加进红黑树的文件描述符,epoll_event监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过传递红黑树的epfd，拉取链表中已经就绪的fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EPOLL中文件描述符的状态</span></span><br><span class="line">EPOLLIN       连接到达；有数据来临；</span><br><span class="line"><span class="function">The associated file is available <span class="keyword">for</span> <span class="title">read</span><span class="params">(<span class="number">2</span>)</span> operations.</span></span><br><span class="line"><span class="function">EPOLLOUT      有数据要写</span></span><br><span class="line"><span class="function">The associated file is available <span class="keyword">for</span> <span class="title">write</span><span class="params">(<span class="number">2</span>)</span> operations.</span></span><br></pre></td></tr></table></figure>

<h3 id="多路复用器"><a href="#多路复用器" class="headerlink" title="多路复用器"></a>多路复用器</h3><p><img src="/images/io-base/io-10.png" alt="system"></p>
<p><img src="/images/io-base/io-11.png" alt="system"></p>
<p><img src="/images/io-base/io-12.png" alt="system"></p>
<p><img src="/images/io-base/io-13.png" alt="system"></p>
<p><img src="/images/io-base/io-14.png" alt="system"></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#LINUX中的JVM参数来控制使用EPOLL还是POLL，默认是选择性能最好的那个</span></span><br><span class="line"><span class="meta">-Djava.nio.channels.spi.SelectorProvider</span>=<span class="string">sun.nio.ch.EPollSelectorProvider</span></span><br><span class="line"><span class="meta">-Djava.nio.channels.spi.SelectorProvider</span>=<span class="string">sun.nio.ch.PollSelectorProvider</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#追踪Linux内核调用</span></span><br><span class="line"><span class="attr">javac</span> <span class="string">SocketMultiplexingSingleThreadv1.class</span></span><br><span class="line"><span class="attr">strace</span> <span class="string">-ff -o out java SocketMultiplexingSingleThreadv1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Linux模拟客户端创建连接</span></span><br><span class="line"><span class="attr">nc</span> <span class="string">192.168.163.1 9090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Linux模拟服务端等待客户端连接</span></span><br><span class="line"><span class="attr">nc</span> <span class="string">-l 192.168.163.1 9090</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;   <span class="comment">//linux 多路复用器（select poll    epoll kqueue） nginx  event&#123;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果在epoll模型下，open--》  epoll_create -&gt; fd3</span></span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll  优先选择：epoll  但是可以 -D修正</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//server 约等于 listen状态的 fd4</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            register</span></span><br><span class="line"><span class="comment">            如果：</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd4 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd4,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  <span class="comment">//死循环</span></span><br><span class="line"></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">                System.out.println(keys.size()+<span class="string">"   size"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//1,调用多路复用器(select,poll  or  epoll  (epoll_wait))</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                select()是啥意思：</span></span><br><span class="line"><span class="comment">                1，select，poll  其实  内核的select（fd4）  poll(fd4)</span></span><br><span class="line"><span class="comment">                2，epoll：  其实 内核的 epoll_wait()</span></span><br><span class="line"><span class="comment">                *, 参数可以带时间：没有时间，0  ：  阻塞，有时间设置一个超时</span></span><br><span class="line"><span class="comment">                selector.wakeup()  结果返回0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                懒加载：</span></span><br><span class="line"><span class="comment">                其实再触碰到selector.select()调用的时候触发了epoll_ctl的调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  <span class="comment">//返回的有状态的fd集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="comment">//so，管你啥多路复用器，你呀只能给我状态，我还得一个一个的去处理他们的R/W。同步好辛苦！！！！！！！！</span></span><br><span class="line">                    <span class="comment">//  NIO  自己对着每一个fd调用系统调用，浪费资源，那么你看，这里是不是调用了一次select方法，知道具体的那些可以R/W了？</span></span><br><span class="line">                    <span class="comment">//幕兰，是不是很省力？</span></span><br><span class="line">                    <span class="comment">//我前边可以强调过，socket：  listen   通信 R/W</span></span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove(); <span class="comment">//set  不移除会重复循环处理</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="comment">//看代码的时候，这里是重点，如果要去接受一个新的连接</span></span><br><span class="line">                            <span class="comment">//语义上，accept接受连接且返回新连接的FD对吧？</span></span><br><span class="line">                            <span class="comment">//那新的FD怎么办？</span></span><br><span class="line">                            <span class="comment">//select，poll，因为他们内核没有空间，那么在jvm中保存和前边的fd4那个listen的一起</span></span><br><span class="line">                            <span class="comment">//epoll： 我们希望通过epoll_ctl把新的客户端fd注册到内核空间</span></span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);  <span class="comment">//连read 还有 write都处理了</span></span><br><span class="line">                            <span class="comment">//在当前线程，这个方法可能会阻塞  ，如果阻塞了十年，其他的IO早就没电了。。。</span></span><br><span class="line">                            <span class="comment">//所以，为什么提出了 IO THREADS</span></span><br><span class="line">                            <span class="comment">//redis  是不是用了epoll，redis是不是有个io threads的概念 ，redis是不是单线程的</span></span><br><span class="line">                            <span class="comment">//tomcat 8,9  异步的处理方式  IO  和   处理上  解耦</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept(); <span class="comment">//来啦，目的是调用accept接受客户端  fd7</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);  <span class="comment">//前边讲过了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 0.0  我类个去</span></span><br><span class="line">            <span class="comment">//你看，调用了register</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            select，poll：jvm里开辟一个数组 fd7 放进去</span></span><br><span class="line"><span class="comment">            epoll：  epoll_ctl(fd3,ADD,fd7,EPOLLIN</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1();</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><img src="/images/io-base/io-17.png" alt="system"></p>
<p><img src="/images/io-base/io-18.png" alt="system"></p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><img src="/images/io-base/io-16.png" alt="system"></p>
<blockquote>
<p>四次分手：</p>
<p>1.服务端发起断开连接的FIN通知</p>
<p>2.客户端接收FIN通知并返回FIN_ACK确认</p>
<p>3.客户端也发送断开连接的FIN通知</p>
<p>4.服务端接受FIN通知并返回ACK确认</p>
<p>经过正常的四次分手后，客户端处于 <em>closed</em> 状态</p>
<p>由于是服务端先发起断开请求，所以服务端处于TIME_WAIT状态</p>
</blockquote>
<p><img src="/images/io-base/io-15.png" alt="system"></p>
<blockquote>
<p>如果服务端代码中没有写<code>client.close()</code>：</p>
<p>1.客户端发起了断开连接的FIN通知</p>
<p>2.服务端接收到FIN通知并返回FIN_ACK确认</p>
<p>3.服务端自身标记成 <em>close_wait</em> 状态</p>
<p>4.客户端接收到FIN_ACK，标记自身状态为FIN_WAIT2等待服务端发送FIN通知</p>
<p>4.由于服务端没有编写<code>client.close()</code>，所以不会发送四次分手的二次确认</p>
<p>5.客户端没有收到客户端也想断开FIN的通知，依旧是 <em>FIN_WAIT2</em> 状态</p>
</blockquote>
<h3 id="单Selector单线程"><a href="#单Selector单线程" class="headerlink" title="单Selector单线程"></a>单Selector单线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            readHandler(key);  <span class="comment">//只处理了  read  并注册 关心这个key的write事件</span></span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123; </span><br><span class="line">                            writeHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"write handler..."</span>);</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                client.write(buffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        key.cancel();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"read handler....."</span>);</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="comment">//处理读事件中注册写事件</span></span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client.register(key.selector(),SelectionKey.OP_WRITE,buffer);</span><br><span class="line">                    <span class="comment">//关心  OP_WRITE 其实就是关系send-queue是不是有空间</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1_1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1_1();</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面单线程的Selector中，先accept、read、write，都处于一个单线程中，没有什么问题，但是会造成CPU资源无法充分利用，若有其中一个Client处理了很长时间，会导致事件的堆积。</p>
</blockquote>
<h3 id="单Selector多线程"><a href="#单Selector多线程" class="headerlink" title="单Selector多线程"></a>单Selector多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketMultiplexingSingleThreadv1_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = ServerSocketChannel.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            selector = Selector.open();  <span class="comment">//  select  poll  *epoll</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initServer();</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了。。。。。"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(key);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//若不增加cancel方法，则会造成多次调用</span></span><br><span class="line">                            <span class="comment">//key.cancel(); 等同于取消注册Selctor，调用epoll_crl(fd,del)</span></span><br><span class="line">                            readHandler(key);  <span class="comment">//只处理了  read  并注册 关心这个key的write事件</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                            <span class="comment">//若不增加cancel方法，则会造成多次调用</span></span><br><span class="line">                            <span class="comment">//key.cancel();</span></span><br><span class="line">                            writeHandler(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"write handler..."</span>);</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                client.write(buffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        key.cancel();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel client = ssc.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">            System.out.println(<span class="string">"新客户端："</span> + client.getRemoteAddress());</span><br><span class="line">            System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"read handler....."</span>);</span><br><span class="line">        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                read = client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    client.register(key.selector(),SelectionKey.OP_WRITE,buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    client.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketMultiplexingSingleThreadv1_1 service = <span class="keyword">new</span> SocketMultiplexingSingleThreadv1_1();</span><br><span class="line">        service.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-19.png" alt="system"></p>
<p><img src="/images/io-base/io-20.png" alt="system"></p>
<h3 id="多Selector单线程"><a href="#多Selector单线程" class="headerlink" title="多Selector单线程"></a>多Selector单线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V1版本：混合模式，只有一个线程负责accept，每个都会被分配client，进行R&#x2F;W</span><br><span class="line">    </span><br><span class="line">V2版本：index&#x3D;[0]的Selector只注册ACCEPT事件，其他Selector注册R&#x2F;W事件</span><br><span class="line">    </span><br><span class="line">V3版本：创建Boss线程组，多个Selector负责ACCEPT事件，创建Wroker线程组，多个Select负责R&#x2F;W事件</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainSocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//V3启动代码</span></span><br><span class="line">        <span class="comment">//创建Boss线程组，线程数量num=3</span></span><br><span class="line">        SelectorThreadGroup bossGroup = <span class="keyword">new</span> SelectorThreadGroup(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//创建Worker线程组，线程数量num=3</span></span><br><span class="line">        SelectorThreadGroup workerGroup = <span class="keyword">new</span> SelectorThreadGroup(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        bossGroup.start();</span><br><span class="line">        workerGroup.start();</span><br><span class="line">        <span class="comment">//绑定Boss和Worker关系</span></span><br><span class="line">        bossGroup.setWorker(workerGroup);</span><br><span class="line">        <span class="comment">//Boss线程组注册ServerSocker</span></span><br><span class="line">        bossGroup.bind(<span class="number">7777</span>, <span class="number">8888</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//V1、V2的启动代码</span></span><br><span class="line">        <span class="comment">//SelectorThreadGroup stg = new SelectorThreadGroup(3);</span></span><br><span class="line">        <span class="comment">//stg.start();</span></span><br><span class="line">        <span class="comment">//stg.bind(7777, 8888, 9999);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每线程对应一个selector，</span></span><br><span class="line"><span class="comment">// 多线程情况下，该主机，该程序的并发客户端被分配到多个selector上</span></span><br><span class="line"><span class="comment">//注意，每个客户端，只绑定到其中一个selector</span></span><br><span class="line"><span class="comment">//不会有交互问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    SelectorThreadGroup stg;</span><br><span class="line"></span><br><span class="line">    Selector selector;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//线程和线程组之间的通信队列</span></span><br><span class="line">    LinkedBlockingDeque&lt;Channel&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectorThread</span><span class="params">(SelectorThreadGroup stg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stg = stg;</span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                 <span class="comment">//1.阻塞  无事件注册时依靠wakeup()唤醒</span></span><br><span class="line">                <span class="keyword">int</span> num = selector.select();</span><br><span class="line">                <span class="comment">//2.处理selectkeys</span></span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="comment">//每个Selector内部串行处理事件，多线程Selector各自处理不同的事件</span></span><br><span class="line">                    <span class="comment">//多个Selector的事件互不影响，无需调用key.cancel</span></span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey next = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (next.isAcceptable()) &#123;</span><br><span class="line">                            acceptHandler(next);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next.isReadable()) &#123;</span><br><span class="line">                            readHandler(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">                <span class="comment">//3,处理一些task :  listen  client 队列中有新的需要注册到Selector的事件</span></span><br><span class="line">                <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                    Channel channel = queue.take();</span><br><span class="line">                    registerChannel(channel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注册Channel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            ServerSocketChannel server = (ServerSocketChannel) channel;</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + server.getLocalAddress() + <span class="string">" ServerSocket has register to Selector..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SocketChannel client = (SocketChannel) channel;</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ, byteBuffer);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + client.getRemoteAddress() + <span class="string">" Socket has register to Selector..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + channel.getLocalAddress() + <span class="string">" accept listen..."</span>);</span><br><span class="line"></span><br><span class="line">        SocketChannel client = channel.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据线程组的规则挑选一个Selector进行事件注册</span></span><br><span class="line">        stg.registerV3(client);</span><br><span class="line">        <span class="comment">//stg.registerV2(client);</span></span><br><span class="line">        <span class="comment">//stg.registerV1(client);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"   register read..."</span> + channel.getRemoteAddress());</span><br><span class="line">        ByteBuffer byteBuffer = (ByteBuffer) key.attachment();</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">                    channel.write(byteBuffer);</span><br><span class="line">                &#125;</span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key.channel();</span><br><span class="line">                System.out.println(<span class="string">"断开连接:"</span> + channel.getRemoteAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorThreadGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SelectorThread[] sts;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用于计算数组下标</span></span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V3版本专用：默认启动类都是Boss组，需要存储Worker组的信息</span></span><br><span class="line">    SelectorThreadGroup worker = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SelectorThreadGroup</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">         <span class="comment">//num  线程数</span></span><br><span class="line">        sts = <span class="keyword">new</span> SelectorThread[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            sts[i] = <span class="keyword">new</span> SelectorThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(sts[i]).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorker</span><span class="params">(SelectorThreadGroup worker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.worker = worker;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//创建ServerSocker的端口监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span>... ports)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> port : ports) &#123;</span><br><span class="line">            ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            registerV3(server);</span><br><span class="line">            <span class="comment">//registerV2(server);</span></span><br><span class="line">            <span class="comment">//registerV1(server);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//V3版本：Boss线程组的Selector进行注册accept事件，Worker线程组注册R/W事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerV3</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        SelectorThread st = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            <span class="comment">//注册ACCEPT到BOSS组，从STG对象中挑选Selector(复用V1版本的方法)</span></span><br><span class="line">            st = <span class="keyword">this</span>.nextSelectorV1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//注册R/W到Worker组，从workers对象中挑选Selector(复用V1版本的方法)</span></span><br><span class="line">            st = worker.nextSelectorV1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,通过队列传递数据 消息</span></span><br><span class="line">        st.queue.add(channel);</span><br><span class="line">        <span class="comment">//2,通过打断阻塞，让对应的线程去自己在打断后完成注册selector</span></span><br><span class="line">        st.selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V2版本：只挑第一个Selector进行注册accept事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerV2</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        SelectorThread st = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">            st = sts[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st = nextSelectorV2();</span><br><span class="line">        &#125;</span><br><span class="line">        st.queue.add(channel);</span><br><span class="line">        st.selector.wakeup();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V2版本：返回sts数组[1 - num]下标的其中一个Selector</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectorThread <span class="title">nextSelectorV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = count.getAndIncrement() % (sts.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sts[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V1版本：根据轮训规则随便挑一个Selector进行注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerV1</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        SelectorThread st = nextSelectorV1();</span><br><span class="line">        st.queue.add(channel);</span><br><span class="line">        st.selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//V1版本：轮训返回sts数组中的其中一个Selector</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectorThread <span class="title">nextSelectorV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = count.getAndIncrement() % sts.length;</span><br><span class="line">        <span class="keyword">return</span> sts[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty响应式编程"><a href="#Netty响应式编程" class="headerlink" title="Netty响应式编程"></a>Netty响应式编程</h2><h3 id="缓冲池概念"><a href="#缓冲池概念" class="headerlink" title="缓冲池概念"></a>缓冲池概念</h3><p>在对象引用的实现中，每当一个Buffer实例没有被引用时，则会销毁该对象实例，如被GC回收，但是Buffer对象创建时的内存分配开销是比较大的，如果频繁创建Buffer对象，频繁进行内存分配释放，则开销较大，影响性能，故在netty4中新增了对象池化机制，即Buffer对象没有被引用时，可以放到一个对象缓存池中，而不是马上销毁，当需要时，则重新从对象缓存池中取出，而不需要重新创建。</p>
<h4 id="PooledByteBuf"><a href="#PooledByteBuf" class="headerlink" title="PooledByteBuf"></a>PooledByteBuf</h4><p>继承于AbstractReferenceCountedByteBuf，在引用计数的基础上，添加池化机制减少对象创建，内存分配释放，提高性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型T控制底层底层存放数据的实现</span></span><br><span class="line"><span class="comment">// 如字节数组byte[]，Java NIO的ByteBuffer</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledByteBuf</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心字段recyclerHandle</span></span><br><span class="line">    <span class="comment">// 每个对象实例包含一个recyclerHandle字段，</span></span><br><span class="line">    <span class="comment">// 该字段作为中介，将该对象实例放到该对象实例所在的类的对象池（类级别字段）中</span></span><br><span class="line">    <span class="comment">// Handle类的value字段指向该对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Recycler.Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> PoolChunk&lt;T&gt; chunk;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> handle;</span><br><span class="line">    <span class="keyword">protected</span> T memory;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxLength;</span><br><span class="line">    PoolThreadCache cache;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer tmpNioBuf;</span><br><span class="line">    <span class="keyword">private</span> ByteBufAllocator allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间省略其他方法</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该对象引用计数为0时，释放该对象</span></span><br><span class="line">        <span class="comment">// 调用recycle方法，将该对象实例放到其所在类的对象缓存池中</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> handle = <span class="keyword">this</span>.handle;</span><br><span class="line">            <span class="keyword">this</span>.handle = -<span class="number">1</span>;</span><br><span class="line">            memory = <span class="keyword">null</span>;</span><br><span class="line">            tmpNioBuf = <span class="keyword">null</span>;</span><br><span class="line">            chunk.arena.free(chunk, handle, maxLength, cache);</span><br><span class="line">            chunk = <span class="keyword">null</span>;</span><br><span class="line">            recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        recyclerHandle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PooledDirectByteBuf"><a href="#PooledDirectByteBuf" class="headerlink" title="PooledDirectByteBuf"></a>PooledDirectByteBuf</h4><p>直接内存的池化实现类</p>
<p>RECYCLER为PooledDirectByteBuf类的对象实例缓存池；</p>
<p>newInstance方法，从缓存池RECYCLER获取一个DirectByteBuf的对象实例，然后调用reuse重置该buf，然后返回给调用方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDirectByteBuf</span> <span class="keyword">extends</span> <span class="title">PooledByteBuf</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;PooledDirectByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;PooledDirectByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PooledDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PooledDirectByteBuf(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PooledDirectByteBuf的reuse实现：</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method must be called before reuse this &#123;<span class="doctag">@link</span> PooledByteBufAllocator&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reuse</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    maxCapacity(maxCapacity);</span><br><span class="line">    setRefCnt(<span class="number">1</span>);</span><br><span class="line">    setIndex0(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    discardMarks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PooledHeapByteBuf"><a href="#PooledHeapByteBuf" class="headerlink" title="PooledHeapByteBuf"></a>PooledHeapByteBuf</h4><p>堆内存的池化实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class PooledHeapByteBuf extends PooledByteBuf&lt;byte[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;PooledHeapByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;PooledHeapByteBuf&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> PooledHeapByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledHeapByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PooledHeapByteBuf(handle, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PooledHeapByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        PooledHeapByteBuf buf = RECYCLER.get();</span><br><span class="line">        buf.reuse(maxCapacity);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBytebuf</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//基于直接内存的ByteBuf 初始容量 8byte，最大容量20byte</span></span><br><span class="line">    <span class="comment">//ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(8, 20);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不基于pool 池化的堆内存ByteBuf</span></span><br><span class="line">    <span class="comment">//ByteBuf buf = UnpooledByteBufAllocator.DEFAULT.heapBuffer(8, 20);</span></span><br><span class="line">    <span class="comment">//池化的 堆内存 ByteBuf</span></span><br><span class="line">    ByteBuf buf = PooledByteBufAllocator.DEFAULT.heapBuffer(<span class="number">8</span>, <span class="number">20</span>);</span><br><span class="line">    print(buf);</span><br><span class="line"></span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line">    buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    print(buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ByteBuf buf)</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否可读状态</span></span><br><span class="line">    System.out.println(<span class="string">"buf.isReadable()    :"</span>+buf.isReadable());</span><br><span class="line">    <span class="comment">//读的起始下标</span></span><br><span class="line">    System.out.println(<span class="string">"buf.readerIndex()   :"</span>+buf.readerIndex());</span><br><span class="line">    <span class="comment">//可读的字节长度</span></span><br><span class="line">    System.out.println(<span class="string">"buf.readableBytes() "</span>+buf.readableBytes());</span><br><span class="line">    <span class="comment">//是否可写状态</span></span><br><span class="line">    System.out.println(<span class="string">"buf.isWritable()    :"</span>+buf.isWritable());</span><br><span class="line">    <span class="comment">//写的起始下标</span></span><br><span class="line">    System.out.println(<span class="string">"buf.writerIndex()   :"</span>+buf.writerIndex());</span><br><span class="line">    <span class="comment">//可写的字节长度</span></span><br><span class="line">    System.out.println(<span class="string">"buf.writableBytes() :"</span>+buf.writableBytes());</span><br><span class="line">    <span class="comment">//当前ByteBuf容量</span></span><br><span class="line">    System.out.println(<span class="string">"buf.capacity()  :"</span>+buf.capacity());</span><br><span class="line">    <span class="comment">//ByteBuf最大容量</span></span><br><span class="line">    System.out.println(<span class="string">"buf.maxCapacity()   :"</span>+buf.maxCapacity());</span><br><span class="line">    <span class="comment">//是否直接内存</span></span><br><span class="line">    System.out.println(<span class="string">"buf.isDirect()  :"</span>+buf.isDirect());</span><br><span class="line">    System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clientMode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//类似于管理Selector的线程组 </span></span><br><span class="line">    NioEventLoopGroup thread = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端模式：Netty提供的NioSocketChannl</span></span><br><span class="line">    NioSocketChannel client = <span class="keyword">new</span> NioSocketChannel();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将client注册到Selector中，等同于 epoll_ctl(5,ADD,3)</span></span><br><span class="line">    thread.register(client);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应式编程：创建一个管道，添加一个处理类，接收到消息时响应调用处理</span></span><br><span class="line">    ChannelPipeline p = client.pipeline();</span><br><span class="line">    p.addLast(<span class="keyword">new</span> MyInHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reactor  异步的特征  异步注册监听事件</span></span><br><span class="line">    ChannelFuture connect = client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.150.11"</span>, <span class="number">9090</span>));</span><br><span class="line">    <span class="comment">//sync进行同步阻塞，等待注册完成</span></span><br><span class="line">    ChannelFuture sync = connect.sync();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//创建拷贝的ByteBuf</span></span><br><span class="line">    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">    <span class="comment">//发送消息并且刷新（异步操作）</span></span><br><span class="line">    ChannelFuture send = client.writeAndFlush(buf);</span><br><span class="line">    <span class="comment">//阻塞等待发送成功</span></span><br><span class="line">    send.sync();</span><br><span class="line">  <span class="comment">//关闭通道并阻塞等待关闭成功</span></span><br><span class="line">    sync.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"client over...."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该注解用于多个Client响应时共享Handler对象，否则一个Handler只能给一个Client使用</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//响应式注册</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client  registed..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"client active..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//响应式读取，将接受到的内容写回给Server端</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//msg = client.read() 默认调用得到的，可以直接强转</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//这里不能直接用 buf.readCharSequence 读成字符串，因为读出来后，buffer内容将被清空</span></span><br><span class="line">        <span class="comment">//CharSequence str = buf.readCharSequence(buf.readableBytes(), CharsetUtil.UTF_8);</span></span><br><span class="line">        <span class="comment">//调用getCharSequence读取Buffer内容，但是内容不会被清空</span></span><br><span class="line">        CharSequence str = buf.getCharSequence(<span class="number">0</span>,buf.readableBytes(), CharsetUtil.UTF_8);</span><br><span class="line">        <span class="comment">//输出内容</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="comment">//回写有内容的Buffer给Server</span></span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serverMode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//类似于管理Selector的线程组</span></span><br><span class="line">    NioEventLoopGroup thread = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//服务端模式：NioServerSocketChannel</span></span><br><span class="line">    NioServerSocketChannel server = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将client注册到Selector中，等同于 epoll_ctl(5,ADD,3)</span></span><br><span class="line">    thread.register(server);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//响应式编程：创建一个管道，添加一个处理类，接收到消息时响应调用处理</span></span><br><span class="line">    ChannelPipeline p = server.pipeline();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加响应式处理事件</span></span><br><span class="line">    <span class="comment">//accept接收客户端，并且注册到selector(传参Selector线程组、Client的READ响应事件)</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> MyAcceptHandler(thread,<span class="keyword">new</span> MyInHandler()));</span><br><span class="line">    <span class="comment">//优化的方案，添加一层</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> MyAcceptHandler(thread,<span class="keyword">new</span> ChannelInit()));  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异步注册监听事件</span></span><br><span class="line">    ChannelFuture bind = server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.150.1"</span>, <span class="number">9090</span>));</span><br><span class="line">  <span class="comment">//bind.sync() 阻塞 并 阻塞等待Server发送关闭请求（理论上永远不会发生，主要是为了让Main线程进入Wait状态，子进程进行Netty事件监听工作，而不结束程序）</span></span><br><span class="line">    bind.sync().channel().closeFuture().sync();</span><br><span class="line">    System.out.println(<span class="string">"server close...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyAcceptHandler</span>  <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAcceptHandler</span><span class="params">(EventLoopGroup thread, ChannelHandler myInHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector = thread;</span><br><span class="line">        <span class="keyword">this</span>.handler = myInHandler;  <span class="comment">//ChannelInit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server registerd..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  listen  socket   accept    client</span></span><br><span class="line">        <span class="comment">//  socket           R/W</span></span><br><span class="line">        <span class="comment">//accept  我怎么没调用额？</span></span><br><span class="line">        <span class="comment">//Netty 自动调用了 </span></span><br><span class="line">        SocketChannel client = (SocketChannel) msg;  </span><br><span class="line">        <span class="comment">//1.响应式的  handler</span></span><br><span class="line">        <span class="comment">//下文案例优化的相应注释：client::pipeline[ChannelInit]</span></span><br><span class="line">        ChannelPipeline p = client.pipeline();</span><br><span class="line">        p.addLast(handler);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.注册</span></span><br><span class="line">        selector.register(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>由于使用注解<code>@ChannelHandler.Sharable</code>造成所有客户端都使用了同一个Handler对象，如果每个客户端都想要独立的Handler对象呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为啥要有一个inithandler，可以没有，但是MyInHandler就得设计成单例</span></span><br><span class="line"><span class="comment">//思想：外层包一个Handler，复写它的Register方法，当注册的时候，在Register中创建各自的Handler</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChannelInit</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel client = ctx.channel();</span><br><span class="line">        ChannelPipeline p = client.pipeline();</span><br><span class="line">        <span class="comment">//在原有的基础Handler上再添加新的Handler</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> MyInHandler()); <span class="comment">//2.client::pipeline[ChannelInit,MyInHandler]</span></span><br><span class="line">        <span class="comment">//然后移除自身的Handler</span></span><br><span class="line">        ctx.pipeline().remove(<span class="keyword">this</span>); <span class="comment">//3.client::pipeline[MyInHandler]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty客户端"><a href="#Netty客户端" class="headerlink" title="Netty客户端"></a>Netty客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nettyClient</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    ChannelFuture connect = bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> MyHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.1.134"</span>, <span class="number">9090</span>));</span><br><span class="line">    connect.sync();</span><br><span class="line"></span><br><span class="line">    NioSocketChannel client = (NioSocketChannel) connect.channel();</span><br><span class="line">    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"hello server"</span>.getBytes());</span><br><span class="line">    ChannelFuture channelFuture = client.writeAndFlush(buf);</span><br><span class="line">    channelFuture.sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Netty服务端"><a href="#Netty服务端" class="headerlink" title="Netty服务端"></a>Netty服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nettyServer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">//Server需要绑定Boss和Worker线程组，这里偷懒复用同一个</span></span><br><span class="line">    ChannelFuture bind = bootstrap.group(group, group)</span><br><span class="line">        .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioServerSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ChannelPipeline pipeline = channel.pipeline();</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> MyHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"192.168.3.32"</span>, <span class="number">9090</span>));</span><br><span class="line">    bind.sync().channel().closeFuture().sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写RPC框架"><a href="#手写RPC框架" class="headerlink" title="手写RPC框架"></a>手写RPC框架</h2><p><img src="/images/io-base/io-21.png" alt="system"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理调用的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">saySomething</span><span class="params">(String hello)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者的启动函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果这里包含了Provider的服务，则将走本地调用</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            String Isay = <span class="string">"~~~hello~~~~"</span> + i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Say say = ProxyUtils.proxy(Say<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                String recv = say.saySomething(Isay);</span><br><span class="line">                System.out.println(<span class="string">"I say : 【"</span> + Isay + <span class="string">"】 and provider return  ："</span> + recv);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用JDK的动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">proxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader = clazz.getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] classes = &#123;clazz&#125;;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(classLoader, classes, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="comment">//如何设计我们的consumer对于provider的调用过程</span></span><br><span class="line">            <span class="comment">//调用 服务，方法，参数  ==》 封装成message  [content]</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            String name = clazz.getName();</span><br><span class="line"></span><br><span class="line">            Object object = Dispatcher.get(clazz.getName());</span><br><span class="line">            <span class="comment">//从本地对象中获取，判断是否是本地调用，若是本地调用，则直接反射方法，若不是，则走RPC</span></span><br><span class="line">            <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"走本地调用：FC..."</span>);</span><br><span class="line">                Method m = clazz.getMethod(methodName, parameterTypes);</span><br><span class="line">                <span class="keyword">return</span> m.invoke(object, args);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"走RPC调用：RPC..."</span>);</span><br><span class="line">            <span class="comment">//消息体</span></span><br><span class="line">            MsgBody msgBody = <span class="keyword">new</span> MsgBody(name, methodName, args, parameterTypes);</span><br><span class="line">            <span class="comment">//调用Socket发送请求</span></span><br><span class="line">            SynchronousQueue&lt;Object&gt; blockQueue = ClientFactory.getFactory().transport(msgBody);</span><br><span class="line">            <span class="comment">//如果从IO ，未来回来了，怎么将代码执行到这里</span></span><br><span class="line">            <span class="keyword">return</span> blockQueue.take();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgHeader</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拆包的协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> protocol;</span><br><span class="line">    <span class="comment">//唯一ID</span></span><br><span class="line">    <span class="keyword">public</span> String uuid;</span><br><span class="line">    <span class="comment">//消息体长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dataLen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Consumer发给Provider的协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> tranProtocol = <span class="number">0x1010</span>;</span><br><span class="line">    <span class="comment">//Provider发给Consumer的协议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> recvProtocol = <span class="number">0x0101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgHeader</span><span class="params">(<span class="keyword">int</span> protocol, String uuid, <span class="keyword">long</span> dataLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">        <span class="keyword">this</span>.uuid = uuid;</span><br><span class="line">        <span class="keyword">this</span>.dataLen = dataLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set、toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgBody</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RPC远程调用接口名称</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//RPC远程调用方法名</span></span><br><span class="line">    String method;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    Object[] args;</span><br><span class="line">    <span class="comment">//方法类型</span></span><br><span class="line">    Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgBody</span><span class="params">(String name, String method, Object[] args, Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略get、set、toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化对象的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toBytes(Object object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        baos.reset();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">toObject</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链接池"><a href="#链接池" class="headerlink" title="链接池"></a>链接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链接池工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问同一个Server最多能创建的Client数量</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientFactory factory = <span class="keyword">new</span> ClientFactory();</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;InetSocketAddress, ClientPool&gt; pools = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得一个NioSocketChannel链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NioSocketChannel <span class="title">getClientChannel</span><span class="params">(InetSocketAddress server)</span> </span>&#123;</span><br><span class="line">        ClientPool pool = pools.get(server);</span><br><span class="line">        <span class="comment">//懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pools.putIfAbsent(server, <span class="keyword">new</span> ClientPool(size));</span><br><span class="line">            pool = pools.get(server);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pool.getClient(server);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SynchronousQueue&lt;Object&gt; <span class="title">transport</span><span class="params">(MsgBody msgBody)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//requestID+message  ，本地要缓存</span></span><br><span class="line">        SynchronousQueue&lt;Object&gt; blockQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        CallBackUtils.add(uuid, blockQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//协议：【header&lt;&gt;】【msgBody】</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bodyBytes = SerializableUtils.toBytes(msgBody);</span><br><span class="line">        MsgHeader header = <span class="keyword">new</span> MsgHeader(MsgHeader.tranProtocol, uuid, bodyBytes.length);</span><br><span class="line">        <span class="keyword">byte</span>[] headerBytes = SerializableUtils.toBytes(header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过打印headerBytes查看协议头有多少字节</span></span><br><span class="line">        <span class="comment">//System.out.println("headerBytes : " + headerBytes.length);</span></span><br><span class="line"></span><br><span class="line">        ByteBuf byteBuf = PooledByteBufAllocator.DEFAULT.heapBuffer(headerBytes.length + bodyBytes.length);</span><br><span class="line">        byteBuf.writeBytes(headerBytes);</span><br><span class="line">        byteBuf.writeBytes(bodyBytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接池：：取得连接</span></span><br><span class="line">        <span class="comment">//获取连接过程中： 开始-创建，过程-直接取</span></span><br><span class="line">        InetSocketAddress server = <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9090</span>);</span><br><span class="line">        NioSocketChannel clientChannel = getClientChannel(server);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5，发送--&gt; 走IO  out --&gt;走Netty（event 驱动）</span></span><br><span class="line">        ChannelFuture channelFuture = clientChannel.writeAndFlush(byteBuf);</span><br><span class="line">        channelFuture.sync();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> blockQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采用最简单的轮训算法</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//缓存链接的数组</span></span><br><span class="line">    NioSocketChannel[] clients;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//懒加载client</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        clients = <span class="keyword">new</span> NioSocketChannel[num];</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//这里偷懒全局加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> NioSocketChannel <span class="title">getClient</span><span class="params">(InetSocketAddress server)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(clients.length);</span><br><span class="line">        NioSocketChannel client = clients[index];</span><br><span class="line">        <span class="comment">//如果client存在则返回--》需要注意的是，它是允许多个线程持有同一个client</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span> &amp;&amp; client.isActive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果client不存在则创建，并返回</span></span><br><span class="line">        clients[index] = create(server);</span><br><span class="line">        <span class="keyword">return</span> clients[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NioSocketChannel <span class="title">create</span><span class="params">(InetSocketAddress server)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;		</span><br><span class="line">        <span class="comment">//创建只有一个EventLoop的工作组</span></span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        ChannelFuture connect = bootstrap.group(worker)</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//这里用了拆包协议，下文会详细讲解</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ProtocolDecoder());</span><br><span class="line">                    <span class="comment">//具体处理回调的Handler</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ConsumerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .connect(server);</span><br><span class="line">        connect.sync();</span><br><span class="line">        <span class="keyword">return</span> (NioSocketChannel) connect.channel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Provider启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1个Selector.ACCPET的EventLoop线程组</span></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//20个Selector处理R/W的工作组</span></span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">20</span>);</span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        ChannelFuture bind = bootstrap.group(boss, worker)</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"server accept client port: "</span> + ch.remoteAddress().getPort());</span><br><span class="line"></span><br><span class="line">                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                    <span class="comment">//1.原始的思想</span></span><br><span class="line">                    <span class="comment">//pipeline.addList(new ProviderRequestHandler());</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//2.进阶的思想</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ProtocolDecoder());</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ProviderHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9090</span>));</span><br><span class="line"></span><br><span class="line">        bind.sync().channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySay</span> <span class="keyword">implements</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saySomething</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I say Hello back"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Provider原始思想的Handler：</span><br><span class="line">1.读取到ByteBuf后，根据消息头的大小进行数据分割，由于前面预测试输出过一个MsgHttper对象的byte数组大小为143</span><br><span class="line">2.所以读取的前143个字节的数据转换成MsgHeader对象</span><br><span class="line">3.然后根据MsgHeader的属性dataLen获取到消息体大小</span><br><span class="line">4.然后读取dataLen个字节的数据转换成MsgBody对象</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始的思想的Handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderRequestHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) buf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">143</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] headBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">143</span>];</span><br><span class="line">            byteBuf.readBytes(headBytes, byteBuf.readerIndex(), headBytes.length);</span><br><span class="line">            MsgHeader header = (MsgHeader) SerializableUtils.toObject(headBytes);</span><br><span class="line">            System.out.println(header);</span><br><span class="line">            <span class="keyword">if</span> (byteBuf.readableBytes() &gt;= header.dataLen) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) header.dataLen];</span><br><span class="line">                byteBuf.readBytes(bodyBytes);</span><br><span class="line">                MsgBody msgBody = (MsgBody) SerializableUtils.toObject(bodyBytes);</span><br><span class="line">                System.out.println(msgBody);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：这种设计在并发的情况下会不会产生问题？一个ByteBuf对象包含一个完整的数据包吗？</p>
</blockquote>
<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p><img src="/images/io-base/io-22.png" alt="system"></p>
<p><img src="/images/io-base/io-23.png" alt="system"></p>
<p>根据上文的思想，需要实现拆包和缓存不完整的数据包和下次数据包进行拼接，而Netty框架肯定也考虑了这个问题，对种现象进行了封装，称做 <a href="https://www.cnblogs.com/xiangnan6122/p/10206392.html" target="_blank" rel="noopener">解码器</a>，<strong>它的作用是实现数据包的拆包操作，并将拆好的数据包添加进一个<code>List&lt;Object&gt; obj</code>中，它会一个一个传递给下一个Handler。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于对Byte数据按照不同的协议进行解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buf, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) buf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为一个buffer中可能有多个数据包，使用while循环读取多次</span></span><br><span class="line">        <span class="keyword">while</span> (byteBuf.readableBytes() &gt; <span class="number">143</span>) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] headBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">143</span>];</span><br><span class="line">            <span class="comment">//使用getBytes先获取头信息，readIndex指针不移动</span></span><br><span class="line">            byteBuf.getBytes(byteBuf.readerIndex(), headBytes);</span><br><span class="line">            MsgHeader header = (MsgHeader) SerializableUtils.toObject(headBytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//数据拆包，如果可读数据包含一个完整的msgBody大小时，则进行读取，否则跳出当前循环等待拼接下次数据包</span></span><br><span class="line">            <span class="keyword">if</span> (byteBuf.readableBytes() - headBytes.length &gt;= header.dataLen) &#123;</span><br><span class="line">                <span class="comment">//由于之前读取没有移动readIndex，所以现在让它移动指针</span></span><br><span class="line">                byteBuf.readBytes(headBytes.length);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把数据先读到byte数组里，再判断不同协议转换成不同的对象进行拆包</span></span><br><span class="line">                <span class="keyword">byte</span>[] msgBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) header.dataLen];</span><br><span class="line">                byteBuf.readBytes(msgBytes);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果是Client发送给Server的拆包操作，以tranPrototol协议来拆包</span></span><br><span class="line">                <span class="keyword">if</span> (header.protocol == MsgHeader.tranProtocol) &#123;</span><br><span class="line"></span><br><span class="line">                    MsgBody msgBody = (MsgBody) SerializableUtils.toObject(msgBytes);</span><br><span class="line">                    <span class="comment">//将数据拆成Header和MsgBody，添加进out，传递给下一个Handler</span></span><br><span class="line">                    out.add(<span class="keyword">new</span> ProtocolMessage(header, msgBody));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (header.protocol == MsgHeader.recvProtocol) &#123;</span><br><span class="line">                    <span class="comment">//如果是Client接受Server返回的拆包操作，以recvProtocol协议拆包</span></span><br><span class="line">                    Object result = SerializableUtils.toObject(msgBytes);</span><br><span class="line">                    <span class="comment">//将数据拆成Header和result，添加进out，传递给下一个Handler</span></span><br><span class="line">                    out.add(<span class="keyword">new</span> ProtocolMessage(header, result));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolMessage</span> </span>&#123;</span><br><span class="line">    MsgHeader header;</span><br><span class="line">    MsgBody msgBody;</span><br><span class="line">    Object result;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Consumer发送的协议封包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolMessage</span><span class="params">(MsgHeader header, MsgBody msgBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = header;</span><br><span class="line">        <span class="keyword">this</span>.msgBody = msgBody;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//Provider发送的协议封包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolMessage</span><span class="params">(MsgHeader header, Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.header = header;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里做具体ChannelRead的IO逻辑： 如果假设处理完了，要给客户端返回了~！！！需要注意哪些环节~?</span><br><span class="line">1.因为是个RPC，得返回Header带过来的uuid！！！！</span><br><span class="line">2.关注RPC通信协议 protocol,在client那一侧也要解决解码问题</span><br><span class="line">3.业务数据处理</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">业务处理的几种策略:</span><br><span class="line">1.直接在当前方法处理IO 和 业务 和 返回</span><br><span class="line">  弊端：processSelectorKeys和runTask(业务处理)捆绑，其他Channel需要等待它的处理</span><br><span class="line"></span><br><span class="line">2.自己创建线程池</span><br><span class="line">  需要注意：当前线程和处理业务的线程肯定不是同一个线程</span><br><span class="line"></span><br><span class="line">3.业务逻辑传递给其他EventLoop,每一个EventLoop都有一个单线程、Selector、还有一个task队列</span><br><span class="line">  编码：ctx.executor().parent().next().execute()</span><br><span class="line">  好处：将processSelectorKeys和runAllTasks解耦，可以将runAllTasks的压力分散到其他Selector中</span><br><span class="line">  需要注意：当前线程和处理业务线程可能不是同一个线程，处理业务线程可能是其他EventLoop的单线程</span><br><span class="line"></span><br><span class="line">4.使用netty自己的eventloop来处理业务及返回</span><br><span class="line">  编码：ctx.executor().execute();</span><br><span class="line">  作用：将所有processSelectorKeys先处理完，然后再开始按顺序执行runAllTasks</span><br><span class="line">  需要注意：当前线程和处理业务的线程肯定是同一个线程，都是由用一个EventLoop的单线程处理</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-24.png" alt="system"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ByteToMessageDecoder的拆包会拆好的数据包一个一个传递给下一个handler</span></span><br><span class="line">        ProtocolMessage pmsg = (ProtocolMessage) out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前线程</span></span><br><span class="line">        String ioThreadName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射执行目标方法</span></span><br><span class="line">        ctx.executor().parent().next().execute(() -&gt; &#123;</span><br><span class="line">            String taskThreadName = Thread.currentThread().getName();</span><br><span class="line">            String param = (String) pmsg.msgBody.args[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//String result = ioThreadName + " recv say : 【" + param + "】 and send by " + taskThreadName;</span></span><br><span class="line"></span><br><span class="line">            Object result = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//反射调用API</span></span><br><span class="line">                Object object = Dispatcher.get(pmsg.msgBody.name);</span><br><span class="line">                Class&lt;?&gt; clazz = object.getClass();</span><br><span class="line">                Method m = clazz.getMethod(pmsg.msgBody.method, pmsg.msgBody.parameterTypes);</span><br><span class="line">                result = m.invoke(object, pmsg.msgBody.args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写结果集</span></span><br><span class="line">                <span class="keyword">byte</span>[] resultBytes = SerializableUtils.toBytes(result);</span><br><span class="line">                MsgHeader header = <span class="keyword">new</span> MsgHeader(MsgHeader.recvProtocol, pmsg.header.uuid, resultBytes.length);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] headerBytes = SerializableUtils.toBytes(header);</span><br><span class="line">                ByteBuf byteBuf = PooledByteBufAllocator.DEFAULT.heapBuffer(headerBytes.length + resultBytes.length);</span><br><span class="line">                byteBuf.writeBytes(headerBytes);</span><br><span class="line">                byteBuf.writeBytes(resultBytes);</span><br><span class="line">                ctx.writeAndFlush(byteBuf);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Provider发送完消息后回过头看Consumer的接收回复消息的Handler</span></span><br><span class="line"><span class="comment">//Consumer也用了拆包，所以这里是一个完整的数据包，回调CallBck唤醒阻塞的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.解析数据转换成对象</span></span><br><span class="line">        ProtocolMessage pmsg = (ProtocolMessage) out;</span><br><span class="line">        <span class="comment">//2.获取uuid回调callback</span></span><br><span class="line">        CallBackUtils.callback(pmsg.header.uuid, pmsg.result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ConcurrentHashMap&lt;String, SynchronousQueue&lt;Object&gt;&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String uuid, SynchronousQueue queue)</span> </span>&#123;</span><br><span class="line">        map.put(uuid, queue);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//往队列里塞返回值，使得Consumer的调用线程不再阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(String uuid, Object result)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronousQueue queue = map.get(uuid);</span><br><span class="line">        queue.put(result);</span><br><span class="line">        <span class="comment">//移除掉已经使用的内容，否则map会很大</span></span><br><span class="line">        map.remove(uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/io-base/io-25.png" alt="system"></p>
<p><img src="/images/io-base/io-27.png" alt="system"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/io-base/io-26.png" alt="system"></p>
<p><img src="/images/io-base/io-28.png" alt="system"></p>
<p><img src="/images/io-base/io-29.png" alt="system"></p>
<p><img src="/images/io-base/io-30.png" alt="system"></p>
<blockquote>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2020年11月26日 00:07</p>
        <p>原始链接： <a class="post-url" href="/2020/10/29/io-base/" title="&#39;内存与IO，磁盘IO，网络IO&#39;">https://midkuro.gitee.io/2020/10/29/io-base/</a></p>
        <footer>
            <a href="https://midkuro.gitee.io">
                <img src="/images/logo.gif" alt="Kuro">
                Kuro
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://midkuro.gitee.io/2020/10/29/io-base/&title=《'内存与IO，磁盘IO，网络IO'》 — Kuro's Blog&pic=images/java.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://midkuro.gitee.io/2020/10/29/io-base/&title=《'内存与IO，磁盘IO，网络IO'》 — Kuro's Blog&source=坚持 是一种品格" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://midkuro.gitee.io/2020/10/29/io-base/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《'内存与IO，磁盘IO，网络IO'》 — Kuro's Blog&url=https://midkuro.gitee.io/2020/10/29/io-base/&via=https://midkuro.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://midkuro.gitee.io/2020/10/29/io-base/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://midkuro.gitee.io/2020/10/29/io-base/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/NIO/" class="color4">NIO</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#内存与IO，磁盘IO，网络IO"><span class="post-toc-text">内存与IO，磁盘IO，网络IO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件描述符"><span class="post-toc-text">文件描述符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#虚拟内存和内存映射"><span class="post-toc-text">虚拟内存和内存映射</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#磁盘IO"><span class="post-toc-text">磁盘IO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#网络IO"><span class="post-toc-text">网络IO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BIO"><span class="post-toc-text">BIO</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NIO"><span class="post-toc-text">NIO</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Linux内核函数"><span class="post-toc-text">Linux内核函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多路复用器"><span class="post-toc-text">多路复用器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#底层实现"><span class="post-toc-text">底层实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#状态"><span class="post-toc-text">状态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单Selector单线程"><span class="post-toc-text">单Selector单线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#单Selector多线程"><span class="post-toc-text">单Selector多线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多Selector单线程"><span class="post-toc-text">多Selector单线程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Netty响应式编程"><span class="post-toc-text">Netty响应式编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缓冲池概念"><span class="post-toc-text">缓冲池概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PooledByteBuf"><span class="post-toc-text">PooledByteBuf</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PooledDirectByteBuf"><span class="post-toc-text">PooledDirectByteBuf</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#PooledHeapByteBuf"><span class="post-toc-text">PooledHeapByteBuf</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ByteBuf"><span class="post-toc-text">ByteBuf</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#客户端"><span class="post-toc-text">客户端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#服务端"><span class="post-toc-text">服务端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#优化"><span class="post-toc-text">优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty客户端"><span class="post-toc-text">Netty客户端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty服务端"><span class="post-toc-text">Netty服务端</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#手写RPC框架"><span class="post-toc-text">手写RPC框架</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#消费者"><span class="post-toc-text">消费者</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动态代理"><span class="post-toc-text">动态代理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协议"><span class="post-toc-text">协议</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链接池"><span class="post-toc-text">链接池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#生产者"><span class="post-toc-text">生产者</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现类"><span class="post-toc-text">实现类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解码器"><span class="post-toc-text">解码器</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2020/10/29/jvm-base/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          &#39;JVM 虚拟机&#39;
        
      </span>
    </a>
  
  
    <a href="/2020/10/24/spring-circularReferences/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">&#39;Spring的循环依赖&#39;</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="io-base" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyuQBWutQ';
        var conf = '7882bf42fa9e8bed0d20d7c215c57a71';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2020 Kuro<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://midkuro.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/ActiveMQ/">ActiveMQ</a><a class="category-link" href="/categories/Algorithm/">Algorithm</a><a class="category-link" href="/categories/Cache/">Cache</a><a class="category-link" href="/categories/Config/">Config</a><a class="category-link" href="/categories/Cryptography/">Cryptography</a><a class="category-link" href="/categories/Docker/">Docker</a><a class="category-link" href="/categories/Druid/">Druid</a><a class="category-link" href="/categories/Elasticsearch/">Elasticsearch</a><a class="category-link" href="/categories/Eureka/">Eureka</a><a class="category-link" href="/categories/Feign/">Feign</a><a class="category-link" href="/categories/Firewall/">Firewall</a><a class="category-link" href="/categories/HTTPS/">HTTPS</a><a class="category-link" href="/categories/HashMap/">HashMap</a><a class="category-link" href="/categories/Hystrix/">Hystrix</a><a class="category-link" href="/categories/JVM/">JVM</a><a class="category-link" href="/categories/Jenkins/">Jenkins</a><a class="category-link" href="/categories/Kubernetes/">Kubernetes</a><a class="category-link" href="/categories/LVS/">LVS</a><a class="category-link" href="/categories/MYSQL/">MYSQL</a><a class="category-link" href="/categories/Mybatis/">Mybatis</a><a class="category-link" href="/categories/NIO/">NIO</a><a class="category-link" href="/categories/Nacos/">Nacos</a><a class="category-link" href="/categories/Netty/">Netty</a><a class="category-link" href="/categories/Nginx/">Nginx</a><a class="category-link" href="/categories/Nginx/Redis/">Redis</a><a class="category-link" href="/categories/Nodejs/">Nodejs</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/RocketMQ/">RocketMQ</a><a class="category-link" href="/categories/SSO/">SSO</a><a class="category-link" href="/categories/Seata/">Seata</a><a class="category-link" href="/categories/Security/">Security</a><a class="category-link" href="/categories/Sentinel/">Sentinel</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/Spring/Mybatis/">Mybatis</a><a class="category-link" href="/categories/Spring/Mybatis/SpringMVC/">SpringMVC</a><a class="category-link" href="/categories/Starter/">Starter</a><a class="category-link" href="/categories/Stream/">Stream</a><a class="category-link" href="/categories/Synchronized/">Synchronized</a><a class="category-link" href="/categories/Systemctl/">Systemctl</a><a class="category-link" href="/categories/Thread/">Thread</a><a class="category-link" href="/categories/Zuul/">Zuul</a><a class="category-link" href="/categories/binary/">binary</a><a class="category-link" href="/categories/springMVC/">springMVC</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16.36px;">ActiveMQ</a> <a href="/tags/Algorithm/" style="font-size: 10.91px;">Algorithm</a> <a href="/tags/Cryptography/" style="font-size: 11.82px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19.09px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 12.73px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17.27px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 10.91px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 12.73px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 10.91px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 13.64px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 11.82px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 11.82px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 12.73px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10.91px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15.45px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 11.82px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 14.55px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.64px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18.18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 12.73px;">Thread</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/ActiveMQ/" style="font-size: 16.36px;">ActiveMQ</a> <a href="/tags/Algorithm/" style="font-size: 10.91px;">Algorithm</a> <a href="/tags/Cryptography/" style="font-size: 11.82px;">Cryptography</a> <a href="/tags/DevOps/" style="font-size: 19.09px;">DevOps</a> <a href="/tags/Docker/" style="font-size: 12.73px;">Docker</a> <a href="/tags/Elasticsearch/" style="font-size: 17.27px;">Elasticsearch</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/HashMap/" style="font-size: 10.91px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 12.73px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Kubernetes/" style="font-size: 10.91px;">Kubernetes</a> <a href="/tags/LVS/" style="font-size: 10px;">LVS</a> <a href="/tags/Linux/" style="font-size: 13.64px;">Linux</a> <a href="/tags/MYSQL/" style="font-size: 11.82px;">MYSQL</a> <a href="/tags/Mybatis/" style="font-size: 11.82px;">Mybatis</a> <a href="/tags/NIO/" style="font-size: 12.73px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10.91px;">Netty</a> <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 15.45px;">Redis</a> <a href="/tags/RocketMQ/" style="font-size: 11.82px;">RocketMQ</a> <a href="/tags/Spring/" style="font-size: 14.55px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.64px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 18.18px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Thread/" style="font-size: 12.73px;">Thread</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>